#tag ClassProtected Class GUIObjInherits Canvas	#tag Event		Function ConstructContextualMenu(base as MenuItem, x as Integer, y as Integer) As Boolean		  Draw		  		  dim i, n as integer		  dim Beat, Pitch as integer		  dim CurrentTrack as TrackObj		  dim Note as NoteObj		  		  //get the NoteObj the user clicked on in the editor		  Beat = ((X - kKeyPicWidth)) \ ResolutionX + ScrollDeltaX		  Pitch = Abs(((Y - kTotalRulerHeight) \ ResolutionY) - MIDILib.kMIDINoteCount + 1) - ScrollDeltaY		  Note = ParentWindow.NoteMgr.GetNote(Beat, Pitch)		  		  if X > kKeyPicWidth and Y > kTotalRulerHeight then //Editor Area		    		    if Note = nil then		      for i = Ubound(ParentWindow.NoteMgr.Selection) DownTo 0		        if ParentWindow.NoteMgr.Selection(i) <> nil then		          If ParentWindow.NoteMgr.Selection(i) IsA NoteObj then		            dim mNote as NoteObj		            mNote = ParentWindow.NoteMgr.Selection(i)		            //the above line is raising a NilObjectException in certain instances.		            //Possibly when deselecting a selection when the selection was made with drag selection.		            ParentWindow.NoteMgr.RemoveSelection(mNote)		          End If		        end if		      next		      base.Append(MusicChangeKey)		      return true		    end if		    		    //if this Note's Track isn't selected, don't do anything.		    'dim ActiveTrack as TrackObj		    'ActiveTrack = ParentWindow.TrackListObj1.GetCurrentTrack		    if Note.Track <> ParentWindow.TrackListObj1.CurrentTrack then		      beep		      Return false		    end if		    		    ParentWindow.NoteMgr.EditNote(Note) //this manages note selection.		    		  end if		  		  base.Append(NotesEditNotes)		  base.append(New MenuItem(MenuItem.TextSeparator))		  base.Append(NotesMakeChord)		  base.Append(NotesRemoveChord)		  base.Append(NotesBreakChord)		  base.Append(NotesAlterChord)		  base.append(New MenuItem(MenuItem.TextSeparator))		  base.Append(NotesGroup)		  base.Append(NotesUngroup)		  base.append(New MenuItem(MenuItem.TextSeparator))		  base.Append(EditCut)		  base.Append(EditCopy)		  base.Append(EditPaste)		  base.Append(EditClear)		  		  return true		  		End Function	#tag EndEvent	#tag Event		Function ContextualMenuAction(hitItem as MenuItem) As Boolean		  select case hitItem.Name		  case "Edit Notes..."		    WindowEditNote.Show		  case "Make Chord..."		    WindowMakeChord.Show		  case "Remove Chord"		  case "Break Chord"		  case "Alter Chord..."		  case "Group"		  case "Ungroup"		  case "Cut"		  case "Copy"		    ParentWindow.EditMgr.Copy		  case "Paste"		  case "Clear"		  case "Change Key..."		    WindowChangeKey.Show		  end select		  		  return true		End Function	#tag EndEvent	#tag Event		Sub EnableMenuItems()		  dim i as integer		  		  //check the clipboard		  If UBound(CopyMgr.CopyClipboard) > -1 then		    EditPaste.Enable		  End If		  		  //check the selection array		  if Ubound(ParentWindow.NoteMgr.Selection) > -1 then //if there are objects selected		    EditCut.Enable		    EditCopy.Enable		    EditClear.Enable		    		    EditSelectAll.Enabled = false		    EditSelectNone.Enable		    		    NotesEditNotes.Enable		    		    for i = 0 to Ubound(ParentWindow.NoteMgr.Selection)		      if ParentWindow.NoteMgr.Selection(i) <> nil then		        if ParentWindow.NoteMgr.Selection(i) IsA NoteObj then		          NotesMakeChord.Enable		          NotesRemoveChord.Enabled = false		          NotesBreakChord.Enabled = false		          NotesAlterChord.Enabled = false		        end if		        if ParentWindow.NoteMgr.Selection(i) IsA ChordObj then		          NotesRemoveChord.Enable		          NotesBreakChord.Enable		          NotesAlterChord.Enable		        end if		      end if		    next		    		    NotesGroup.Enable		  else		    NotesEditNotes.Enabled = false		    NotesMakeChord.Enabled = false		    		    NotesRemoveChord.Enabled = false		    NotesBreakChord.Enabled = false		    NotesAlterChord.Enabled = false		    		    NotesGroup.Enabled = false		    		  end if		  		  if Ubound(ParentWindow.NoteMgr.Notes) = -1 then		    NotesEditNotes.Enabled = false		    NotesMakeChord.Enabled = false		  end if		  		  MusicChangeKey.Enable		End Sub	#tag EndEvent	#tag Event		Function KeyDown(Key As String) As Boolean		  select case Asc(Key)		  case 8		    ParentWindow.EditMgr.Delete		    Draw		    return true		  end select		End Function	#tag EndEvent	#tag Event		Function MouseDown(X As Integer, Y As Integer) As Boolean		  #if kLogEvents		    'Log("GUIObj.MouseDown(" + Str(X) + ", " + Str(Y) + ")")		  #endif		  		  SetFocus		  		  If IsContextualClick then return false		  		  DownX = X		  DownY = Y		  		  dim i, n as integer		  dim Beat, Pitch as integer		  dim Note, mNote as NoteObj		  dim mTrack as TrackObj		  		  //get the NoteObj the user clicked on in the editor		  //beat and pitch is used later for other functions, see the different areas below the editor		  Beat = ((X - kKeyPicWidth)) \ ResolutionX + ScrollDeltaX		  Pitch = Abs(((Y - kTotalRulerHeight) \ ResolutionY) - MIDILib.kMIDINoteCount + 1) - ScrollDeltaY		  Note = ParentWindow.NoteMgr.GetNote(Beat, Pitch)		  		  if X >= kKeyPicWidth and Y >= kTotalRulerHeight then //Editor Area		    select case EditStatus		    case kEditStatus_Add //ADD		      if Note = nil then		        Beat = Beat \ SnapTo * SnapTo		        		        dim newNote as NoteObj = ParentWindow.NoteMgr.CreateNote(Beat, Pitch, -1)		        ParentWindow.TrackListObj1.CurrentTrack.AddObject(newNote)		        		        ParentWindow.NoteMgr.ResetSelectionToObject(newNote)		        		        dim CommandMouseCreateNote as CommandMouseCreateNoteObj = new CommandMouseCreateNoteObj(ParentWindow)		        ParentWindow.CommandMgr.InvokeCommand(CommandMouseCreateNote) 		      else		        beep		        return false		      end if		    case kEditStatus_Edit //EDIT		      		      if Note = nil then //deselect everything if nothing was clicked		        ParentWindow.NoteMgr.SelectNone		        Draw		        DragSelectMode = true		        return true		      end if		      		      //if this Note's Track isn't selected, don't do anything.		      		      if Note.Track <> ParentWindow.TrackListObj1.CurrentTrack then		        beep		        Return false		      end if		      		      #if kLogEvents		        'Log("Note Found: " + Note.Label)		      #endif		      		      NoteClicked = Note		      		      ParentWindow.NoteMgr.EditNote(Note) //this manages note selection.		      ResizeMode = ResizeTabHit(Note, X, Y)		      		      if ResizeMode then		        dim CommandMouseResizeMusic as CommandMouseResizeMusicObj = new CommandMouseResizeMusicObj(ParentWindow)		        ParentWindow.CommandMgr.InvokeCommand(CommandMouseResizeMusic)		      else		        dim CommandMouseMove as CommandMouseMoveObj = new CommandMouseMoveObj(ParentWindow)		        ParentWindow.CommandMgr.InvokeCommand(CommandMouseMove)		      end if		      		    case kEditStatus_Delete //DELETE		      if Note = nil then //don't do anything		        beep		        return false		      else		        //if this Track isn't selected, don't do anything.		        if Note.Track <> ParentWindow.TrackListObj1.CurrentTrack then		          beep		          Return false		        end if		      end if		      		      //this might need to be refactored to take into account groups, or just nothing at all		      'If note.Chord = nil then		      dim CommandMouseDeleteNote as CommandMouseDeleteNoteObj = new CommandMouseDeleteNoteObj(ParentWindow)		      CommandMouseDeleteNote.RecordObject(Note)		      ParentWindow.CommandMgr.InvokeCommand(CommandMouseDeleteNote)		      		      ParentWindow.NoteMgr.DestroyNote(Note)		      'else		      'ParentWindow.NoteMgr.DestroyNote(Note.Chord.Root)		      'End If		      		      ParentWindow.WindowNeedsSaving = true		      		    end Select		    		  elseif X < kKeyPicWidth and Y >= kTotalRulerHeight then //Key Area		    		    dim theTrack as TrackObj = ParentWindow.TrackListObj1.CurrentTrack		    dim theInstrument as integer = theTrack.Instrument		    NotePlayer.Instrument = theInstrument		    NotePlayer.PlayNote(Pitch, theTrack.Level)		    		    NotePlayerLastNotePlayed = Pitch		    NotePlayerLastInstrumentPlayed = theInstrument		    NotePlayerLastVelocityPlayed = theTrack.Level		    		  elseif X >= kKeyPicWidth and Y < kTotalRulerHeight then //CursorArea		    		    CursorHit(X)		    		  end if //Editor, Keys, Cursor Areas		  		  Draw		  		  return true		End Function	#tag EndEvent	#tag Event		Sub MouseDrag(X As Integer, Y As Integer)		  #if kLogEventsVerbose		    if X - DownX <> 0 or Y - DownY <> 0 then 		      'Log("GUIObj.MouseDrag(" + Str(X) + ", " + Str(Y) + ")")		    end if		  #endif		  		  //we're not editing...		  if me.EditStatus <> 0 then return		  //...and we didn't drag anywhere.		  if X - DownX = 0 and Y - DownY = 0 then return		  		  dim i, n, p, q, r as integer		  dim Note as NoteObj		  dim Chord as ChordObj		  dim m as integer		  dim TrackCount, noteCount, pitchCount as integer		  dim Track as TrackObj		  dim PitchX as integer		  dim PitchY as integer		  		  dim deltaX, deltaY as integer		  		  dim objectCount, o as integer		  dim chordNoteCount, c as integer		  		  dim mX1, mX2, mY1, mY2 as integer		  		  Track = ParentWindow.TrackListObj1.CurrentTrack		  		  deltaX = ((X - DownX) \ ResolutionX) \ SnapTo * SnapTo		  deltaY = (Y - DownY) \ ResolutionY		  		  if DownX >= kKeyPicWidth and DownY >= kTotalRulerHeight then //Editor Area 		    		    If me.DragSelectMode = false then //if items are selected or we're not in DragSelectMode, move them		      if me.ResizeMode = false then //if we're not resizing move the entire note		        		        //MoveNote(Note, X, Y, deltaX, deltaY)		        		        dim thisNote as Integer = 0		        dim firstNote as integer = 0		        dim lastNote as integer = Ubound(ParentWindow.NoteMgr.Notes)		        		        for thisNote = firstNote to lastNote		          if ParentWindow.NoteMgr.Notes(thisNote) <> Nil then		            dim mNote as NoteObj = ParentWindow.NoteMgr.Notes(thisNote)		            if mNote.Selected and mNote.Locked = false then		              MoveNote(mNote, X, Y, deltaX, deltaY)		            end if		          end if		        next		        		      else //we're just resizing		        		        dim thisNote as Integer = 0		        dim firstNote as integer = 0		        dim lastNote as integer = Ubound(ParentWindow.NoteMgr.Notes)		        		        for thisNote = firstNote to lastNote		          if ParentWindow.NoteMgr.Notes(thisNote) <> Nil then		            dim mNote as NoteObj = ParentWindow.NoteMgr.Notes(thisNote)		            if mNote.Selected AND mNote.Locked = false then		              ChangeNoteLength(mNote, X, Y, deltaX, deltaY)		            end if		          end if		        next		        		      end if		      		      ParentWindow.WindowNeedsSaving = true		      		    else //deal with click and drag SelectionNote within the editor area		      		      //save the outermost bounds as pixels for drawing later		      FullX1 = min(DownX, X) + (ScrollDeltaX * ResolutionX) - kKeyPicWidth		      FullY1 = min(DownY, Y) + (ScrollDeltaY * ResolutionY) - kTotalRulerHeight		      FullX2 = max(DownX, X) + (ScrollDeltaX * ResolutionX) - kKeyPicWidth		      FullY2 = max(DownY, Y) + (ScrollDeltaY * ResolutionY) - kTotalRulerHeight		      		      //convert those values into beats and pitches		      dim Beat1, Beat2, Pitch1, Pitch2 as integer		      Beat1 = FullX1 \ ResolutionX		      Pitch1 = Abs((FullY1 \ ResolutionY) - MIDILib.kMIDINoteCount) - 1		      Beat2 = FullX2 \ ResolutionX		      Pitch2 = Abs((FullY2 \ ResolutionY) - MIDILib.kMIDINoteCount) - 1		      		      //with this method, the selection essentially "blinks" on and off.		      //what really ought to happen is to go through each object, check all the notes and if one is in the bounds, select the object.		      		      dim currentTrack as TrackObj = ParentWindow.TrackListObj1.CurrentTrack		      dim thisObject as Integer = 0		      dim firstObject as integer = 0		      dim lastObject as integer = Ubound(currentTrack.Music)		      		      for thisObject = firstObject to lastObject		        if currentTrack.Music(thisObject) <> nil then		          		          dim theObject as MusicObj = currentTrack.Music(thisObject)		          		          dim thisNote as integer = 0		          dim firstNote as integer = 0		          dim lastNote as integer = UBound(theObject.NoteList)		          		          for thisNote = firstNote to lastNote		            if theObject.NoteList(thisNote) <> Nil then		              		              dim theSingleNote as NoteObj = theObject.NoteList(thisNote)		              dim WithinBounds as Boolean = theSingleNote.IsNoteWithinDragBounds(Beat1, Pitch1, Beat2, Pitch2)		              		              if WithinBounds then		                		                #if kLogProcesses		                  Log("ParentWindow.NoteMgr.AddSelectionFromNote(theSingleNote)")		                #endif		                		                ParentWindow.NoteMgr.AddSelectionFromNote(theSingleNote)		                		                Exit for thisNote		              else		                		                #if kLogProcesses		                  Log("ParentWindow.NoteMgr.RemoveSelection(theSingleNote)")		                #endif		                		                ParentWindow.NoteMgr.RemoveSelection(theSingleNote)		              end if		              		            end if //theObject.NoteList(thisNote) <> Nil		            		          next //thisNote = firstNote to lastNote		          		        end if //theObject.NoteList(thisNote) <> Nil then		      next //thisObject = firstObject to lastObject		      		    end if //me.DragSelectMode = false		    		  elseif DownX >= kKeyPicWidth and DownY < kTotalRulerHeight then //CursorArea		    MoveCursor(X, Y, deltaX, deltaY)		  end if		  		  ParentWindow.ResizeBars		End Sub	#tag EndEvent	#tag Event		Sub MouseMove(X As Integer, Y As Integer)		  #if kLogEventsVerbose		    'Log("GUIObj.MouseMove(" + Str(X) + ", " + Str(Y) + ")")		  #endif		  		  dim beat, pitch as integer		  dim note as noteObj		  		  //get the NoteObj the user clicked on in the editor		  Beat = ((X - kKeyPicWidth)) \ ResolutionX + ScrollDeltaX		  Pitch = Abs(((Y - kTotalRulerHeight) \ ResolutionY) - MIDILib.kMIDINoteCount + 1) - ScrollDeltaY		  Note = ParentWindow.NoteMgr.GetNote(Beat, Pitch)		  		  if note <> nil then		    me.HelpTag = "Label: " + Note.Label + EndOfLine + "ID: " + Str(Note.ID)		  end if		  		  #if kLogEvents //show mouse coordinates in editor		    'ParentWindow.Title = Str(X - kKeyPicWidth) + "." + Str(Y - kTotalRulerHeight)		  #endif		End Sub	#tag EndEvent	#tag Event		Sub MouseUp(X As Integer, Y As Integer)		  #if kLogEvents		    'Log("GUIObj.MouseUp(" + Str(X) + ", " + Str(Y) + ")")		  #endif		  		  if DownX >= kKeyPicWidth and DownY >= kTotalRulerHeight then //Editor Area		    		  elseif DownX < kKeyPicWidth and DownY >= kTotalRulerHeight then //Key Area		    		  elseif DownX >= kKeyPicWidth and DownY < kTotalRulerHeight then //CursorArea		    		  end if //Editor, Keys, Cursor Areas		  		  DragSelectMode = false		  ResizeMode = false		  		  if NoteClicked <> nil then		    if NoteClicked.IsAltered then		      ParentWindow.CommandMgr.CurrentCommand.AddRedoRecordObjs		    else		      ParentWindow.CommandMgr.RemoveLastCommand		    end if		  end if		  		  NoteClicked = nil		  		  if NotePlayerLastNotePlayed <> -1 then		    NotePlayer.PlayNote(NotePlayerLastNotePlayed, 0)		  end if		  NotePlayerLastNotePlayed = -1		  		  ParentWindow.PlayMgr.ClearCursorSelection		  		  Draw		End Sub	#tag EndEvent	#tag Event		Function MouseWheel(X As Integer, Y As Integer, deltaX as Integer, deltaY as Integer) As Boolean		  #if kLogEvents		    'Log("GUIObj.MouseWheel(" + Str(X) + ", " + Str(Y) + ", " + Str(deltaX) + ", " + Str(deltaY) + ")")		  #endif		  		  if (me.Height - kTotalRulerHeight) <= MIDILib.kMIDINoteCount * me.ResolutionY then		    ParentWindow.xScrollBar.Value = deltaX + ParentWindow.xScrollBar.Value		    ParentWindow.yScrollBar.Value = deltaY + ParentWindow.yScrollBar.Value		  end if		  		  return true		End Function	#tag EndEvent	#tag Event		Sub Open()		  //can't do this here, there's no WindowLog to log to.		  '#if kLogEvents		  'Log("GUIObj.Open")		  '#endif		  		  buffer = newPicture(me.Width, me.Height, 32)		  		  EditStatus = kEditStatus_Default		  		  NotePlayer = new NotePlayer		End Sub	#tag EndEvent	#tag Event		Sub Paint(g As Graphics)		  g.drawPicture buffer, 0, 0		End Sub	#tag EndEvent	#tag Method, Flags = &h21		Private Sub ChangeNoteLength(Note as NoteObj, X as integer, Y as integer, deltaX as integer, deltaY as integer)		  #if kLogMethods		    'Log("GUIObj.ChangeNoteLength")		  #endif		  //called from me.MouseDown() if me.ResizeMode = true		  		  if deltaX mod SnapTo = 0 then Note.Length = Note.OldLength + deltaX		  		  if note.Chord <> nil then note.Chord.Length = note.Length		  		  if Note.Length < SnapTo then Note.Length = SnapTo		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub CursorHit(X as integer)		  #if kLogMethods		    'Log("CursorHit(" + Str(X) + ")")		  #endif		  		  dim actualX as integer = X + (ScrollDeltaX * ResolutionX) - kKeyPicWidth		  		  ParentWindow.PlayMgr.ClearCursorSelection		  		  dim StartCursorX as integer = ParentWindow.PlayMgr.StartCursor.StartBeat * ResolutionX		  dim StartCursorX1 as integer = GetRightAlignCursorX1(StartCursorX)		  dim StartCursorX2 as integer = StartCursorX + kRulerPicHeight		  		  if actualX >= StartCursorX1 AND actualX <= StartCursorX2 then		    ParentWindow.PlayMgr.StartCursor.Selected = true		    ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.StartCursor		  end if		  		  dim StopCursorX as integer = ParentWindow.PlayMgr.StopCursor.StartBeat * ResolutionX		  dim StopCursorX1 as integer = GetLeftAlignCursorX1(StopCursorX)		  dim StopCursorX2 as integer = StopCursorX1 + kRulerPicHeight		  		  if actualX >= StopCursorX1 AND actualX <= StopCursorX2 then		    ParentWindow.PlayMgr.StopCursor.Selected = true		    ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.StopCursor		  end if		  		  If ParentWindow.PlayMgr.LoopPlay then		    dim LoopStartCursorX as integer = ParentWindow.PlayMgr.LoopStartCursor.StartBeat * ResolutionX		    dim LoopStartCursorX1 as integer = GetRightAlignCursorX1(LoopStartCursorX)		    dim LoopStartCursorX2 as integer = LoopStartCursorX1 + kRulerPicHeight		    		    if actualX >= LoopStartCursorX1 AND actualX <= LoopStartCursorX2 then		      ParentWindow.PlayMgr.LoopStartCursor.Selected = true		      ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.LoopStartCursor		    end if		    		    dim LoopStopCursorX as integer = ParentWindow.PlayMgr.LoopStopCursor.StartBeat * ResolutionX		    dim LoopStopCursorX1 as integer = GetLeftAlignCursorX1(LoopStopCursorX)		    dim LoopStopCursorX2 as integer = LoopStopCursorX1 + kRulerPicHeight		    		    if actualX >= LoopStopCursorX1 AND actualX <= LoopStopCursorX2 then		      ParentWindow.PlayMgr.LoopStopCursor.Selected = true		      ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.LoopStopCursor		    end if		  End If		  		  dim EditCursorX as integer = ParentWindow.PlayMgr.EditCursor.StartBeat * ResolutionX		  dim EditCursorX1 as integer = GetCenterAlignCursorX1(EditCursorX)		  dim EditCursorX2 as integer = EditCursorX1 + kRulerPicHeight		  		  if actualX >= EditCursorX1 AND actualX <= EditCursorX2 then		    ParentWindow.PlayMgr.EditCursor.Selected = true		    ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.EditCursor		  end if		  		  		  if ParentWindow.PlayMgr.SelectedCursor <> nil then		    ParentWindow.PlayMgr.SelectedCursor.OldStartBeat = ParentWindow.PlayMgr.SelectedCursor.StartBeat		  end if		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Draw()		  #if kLogMethods		    'Log("GUIObj.Draw")		  #endif		  		  //called from everywhere. Any change to an object or the interface calls here.		  		  //prep the compiled image. If ANYTHING goes wrong, stop.		  buffer = newPicture(me.Width, me.Height, 32)		  if buffer = nil or buffer.Width <> me.Width or buffer.Height <> me.Height then		    MsgBox "Draw: Out of memory."		    Quit		  end if		  		  //set the length of the song		  SetSongLength		  		  //prep the ruler		  If DrawRuler = false then		    MsgBox "DrawRuler: Out of memory."		    Quit		  end if		  		  //prep the cursor area		  If DrawCursorArea = false then		    MsgBox "DrawRuler: Out of memory."		    Quit		  end if		  		  //prep the keys		  If DrawKeys = false then		    MsgBox "DrawKeys: Out of memory."		    Quit		  end if		  		  //prep the editor		  If DrawEditor = false then		    MsgBox "DrawEditor: Out of memory."		    Quit		  End If		  		  //prep the corner		  If DrawCorner = false then		    MsgBox "DrawCorner: Out of memory."		    Quit		  End If		  		  dim g as Graphics		  g = buffer.Graphics		  		  //draw the ruler		  g.DrawPicture(RulerPic, KeysPic.Width, 0)		  		  //draw the cursors		  g.DrawPicture(CursorAreaPic, KeysPic.Width, kRulerPicHeight)		  		  //draw the keys		  g.DrawPicture(KeysPic, 0, kTotalRulerHeight)		  		  //draw the editor		  g.DrawPicture(EditorPic, KeysPic.Width, kTotalRulerHeight)		  		  //draw the corner. No purpose yet, but this can be used for status info, icons, etc.		  g.DrawPicture(CornerPic, 0 ,0)		  		  //draw the dividing lines		  g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		  g.DrawLine(KeysPic.Width, 0, KeysPic.Width, Height) //Vertical		  'g.DrawLine(0, RulerPic.Height, Width, RulerPic.Height) //horizontal		  g.DrawLine(0, kTotalRulerHeight, Width, kTotalRulerHeight) //horizontal		  		  //draw an outline to better distingiush the editor from the interface		  g.DrawRect(0, 0, g.Width, g.Height)		  		  //draw the compiled pic		  Graphics.DrawPicture(buffer, 0, 0)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawChordOutlines(g as graphics)		  #if kLogMethods		    'Log("GUIObj.DrawChordOutlines")		  #endif		  		  dim thisTrack as integer = 0		  dim firstTrack as integer = 0		  dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		  		  for thisTrack = lastTrack DownTo firstTrack		    dim track as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0)		    if track <> nil then		      if track.Visible then		        		        dim thisChord as integer = 0		        dim firstChord as integer = 0		        dim lastChord as integer = Ubound(ParentWindow.NoteMgr.Chords)		        		        for thisChord = firstChord to lastChord		          if ParentWindow.NoteMgr.Chords(thisChord) <> nil then		            dim Chord as ChordObj = ParentWindow.NoteMgr.Chords(thisChord)		            if Chord.Track = track then		              dim ChordOutline as GroupOutlineObj = GetOutline(Chord)		              if ChordOutline <> Nil then		                me.EditorPic.Graphics.DrawPicture(ChordOutline.Pic, ChordOutline.X, ChordOutline.Y)		              end if		            end if		          end if		        next		        		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCorner() As Boolean		  #if kLogMethods		    'Log("GUIObj.DrawCorner")		  #endif		  		  //Called by me.Draw		  //this is that odd corner in the top left of the canvas		  //not quite sure what to do with it.		  		  dim picWidth, picHeight as integer		  		  picWidth = kKeyPicWidth		  picHeight = kTotalRulerHeight		  		  CornerPic = NewPicture(picWidth, picHeight, 32)		  		  if CornerPic = nil or CornerPic.Width <> picWidth or CornerPic.Height <> picHeight then		    return false		  end if		  		  dim g as Graphics		  g = CornerPic.Graphics		  		  g.ForeColor = ParentWindow.SongMgr.kColorWhite		  g.FillRect(0, 0, g.Width, g.Height)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCursor(EditCursor as EditCursorObj, g as Graphics, EditCursorX as integer) As boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursor(EditCursor)")		  #endif		  		  dim EditCursorPic as Picture = NewPicture(kRulerPicHeight, kRulerPicHeight, 32)		  if EditCursorPic = nil then return false		  		  //draw the background		  EditCursorPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		  EditCursorPic.Graphics.FillRect(0, 0, EditCursorPic.Width, EditCursorPic.Height)		  		  //draw the main shape just a pixel smaller than you want so we make a black border later		  dim mColor as color = ParentWindow.SongMgr.ColorEditCursor		  dim ColorR as integer = ParentWindow.SongMgr.ColorEditCursor.Red		  dim ColorG as integer = ParentWindow.SongMgr.ColorEditCursor.Green		  dim ColorB as integer = ParentWindow.SongMgr.ColorEditCursor.Blue		  		  if EditCursor.Selected = true then		    mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		  end if		  		  EditCursorPic.Graphics.ForeColor = mColor		  		  dim shapePoints(0) as integer		  shapePoints.Append(1) //top left X		  shapePoints.Append(1) //top left Y		  shapePoints.Append(1) //middle left X		  shapePoints.Append(8) //middle left Y		  shapePoints.Append(8) //bottom middle X		  shapePoints.Append(15) //bottom middle Y		  shapePoints.Append(15) //middle right X		  shapePoints.Append(8) //middle right Y		  shapePoints.Append(15) //top right X		  shapePoints.Append(1) //top right Y		  		  EditCursorPic.Graphics.FillPolygon(shapePoints)		  		  //draw the mask of the shape the size you want to make a clean mask without any white noise		  		  //background again		  EditCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		  EditCursorPic.Mask.Graphics.FillRect(0, 0, EditCursorPic.Width, EditCursorPic.Height)		  		  //shape again		  EditCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		  		  dim shapeMaskPoints(0) as integer		  		  shapeMaskPoints.Append(0) //top left X		  shapeMaskPoints.Append(0) //top left Y		  shapeMaskPoints.Append(0) //middle left X		  shapeMaskPoints.Append(8) //middle left Y		  shapeMaskPoints.Append(8) //bottom middle X		  shapeMaskPoints.Append(16) //bottom middle Y		  shapeMaskPoints.Append(16) //middle right X		  shapeMaskPoints.Append(8) //middle right Y		  shapeMaskPoints.Append(16) //top right X		  shapeMaskPoints.Append(0) //top right Y		  		  EditCursorPic.Mask.Graphics.FillPolygon(shapeMaskPoints)		  		  //blit the pic to the CursorAreaPic		  g.DrawPicture(EditCursorPic, EditCursorX, 0)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCursor(LoopStartCursor as LoopStartCursorObj, g as Graphics, LoopStartCursorX as integer) As boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursor(LoopStartCursor)")		  #endif		  		  dim LoopStartCursorPic as Picture = NewPicture(kRulerPicHeight, kRulerPicHeight, 32)		  if LoopStartCursorPic = nil then return false		  		  //draw the background		  LoopStartCursorPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		  LoopStartCursorPic.Graphics.FillRect(0, 0, LoopStartCursorPic.Width, LoopStartCursorPic.Height)		  		  //draw the main shape just a pixel smaller than you want so we make a black border later		  dim mColor as color = ParentWindow.SongMgr.ColorLoopStartCursor		  dim ColorR as integer = ParentWindow.SongMgr.ColorLoopStartCursor.Red		  dim ColorG as integer = ParentWindow.SongMgr.ColorLoopStartCursor.Green		  dim ColorB as integer = ParentWindow.SongMgr.ColorLoopStartCursor.Blue		  		  if LoopStartCursor.Selected = true then		    mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		  end if		  		  LoopStartCursorPic.Graphics.ForeColor = mColor		  		  dim shapePoints(0) as integer		  shapePoints.Append(1)		  shapePoints.Append(1)		  shapePoints.Append(1)		  shapePoints.Append(15)		  shapePoints.Append(15)		  shapePoints.Append(8)		  		  LoopStartCursorPic.Graphics.FillPolygon(shapePoints)		  		  //draw the mask of the shape the size you want to make a clean mask without any white noise		  		  //background again		  LoopStartCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		  LoopStartCursorPic.Mask.Graphics.FillRect(0, 0, LoopStartCursorPic.Width, LoopStartCursorPic.Height)		  		  //shape again		  LoopStartCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		  dim shapeMaskPoints(0) as integer		  		  shapeMaskPoints.Append(0)		  shapeMaskPoints.Append(0)		  shapeMaskPoints.Append(0)		  shapeMaskPoints.Append(16)		  shapeMaskPoints.Append(16)		  shapeMaskPoints.Append(8)		  		  LoopStartCursorPic.Mask.Graphics.FillPolygon(shapeMaskPoints)		  		  //blit the pic to the CursorAreaPic		  g.DrawPicture(LoopStartCursorPic, LoopStartCursorX, 0)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCursor(LoopStopCursor as LoopStopCursorObj, g as Graphics, LoopStopCursorX as integer) As boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursor(LoopStopCursor)")		  #endif		  		  dim LoopStopCursorPic as Picture = NewPicture(kRulerPicHeight, kRulerPicHeight, 32)		  if LoopStopCursorPic = nil then return false		  		  //draw the background		  LoopStopCursorPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		  LoopStopCursorPic.Graphics.FillRect(0, 0, LoopStopCursorPic.Width, LoopStopCursorPic.Height)		  		  //draw the main shape just a pixel smaller than you want so we make a black border later		  dim mColor as color = ParentWindow.SongMgr.ColorLoopStopCursor		  dim ColorR as integer = ParentWindow.SongMgr.ColorLoopStopCursor.Red		  dim ColorG as integer = ParentWindow.SongMgr.ColorLoopStopCursor.Green		  dim ColorB as integer = ParentWindow.SongMgr.ColorLoopStopCursor.Blue		  		  if LoopStopCursor.Selected = true then		    mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		  end if		  		  LoopStopCursorPic.Graphics.ForeColor = mColor		  		  dim shapePoints(0) as integer		  shapePoints.Append(15)		  shapePoints.Append(1)		  shapePoints.Append(1)		  shapePoints.Append(8)		  shapePoints.Append(15)		  shapePoints.Append(15)		  		  LoopStopCursorPic.Graphics.FillPolygon(shapePoints)		  		  //draw the mask of the shape the size you want to make a clean mask without any white noise		  		  //background again		  LoopStopCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		  LoopStopCursorPic.Mask.Graphics.FillRect(0, 0, LoopStopCursorPic.Width, LoopStopCursorPic.Height)		  		  //shape again		  LoopStopCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		  dim shapeMaskPoints(0) as integer		  		  shapeMaskPoints.Append(16)		  shapeMaskPoints.Append(0)		  shapeMaskPoints.Append(0)		  shapeMaskPoints.Append(8)		  shapeMaskPoints.Append(16)		  shapeMaskPoints.Append(16)		  		  LoopStopCursorPic.Mask.Graphics.FillPolygon(shapeMaskPoints)		  		  //blit the pic to the CursorAreaPic		  g.DrawPicture(LoopStopCursorPic, LoopStopCursorX, 0)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCursor(StartCursor as StartCursorObj, g as Graphics, StartCursorX as integer) As boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursor(StartCursor)")		  #endif		  		  dim StartCursorPic as Picture = NewPicture(kRulerPicHeight, kRulerPicHeight, 32)		  if StartCursorPic = nil then return false		  		  //draw the background		  StartCursorPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		  StartCursorPic.Graphics.FillRect(0, 0, StartCursorPic.Width, StartCursorPic.Height)		  		  //draw the main shape just a pixel smaller than you want so we make a black border later		  dim mColor as color = ParentWindow.SongMgr.ColorStartCursor		  dim ColorR as integer = ParentWindow.SongMgr.ColorStartCursor.Red		  dim ColorG as integer = ParentWindow.SongMgr.ColorStartCursor.Green		  dim ColorB as integer = ParentWindow.SongMgr.ColorStartCursor.Blue		  		  if StartCursor.Selected = true then		    mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		  end if		  		  StartCursorPic.Graphics.ForeColor = mColor		  		  dim shapePoints(0) as integer		  shapePoints.Append(1) //top left X		  shapePoints.Append(1) //top left Y		  shapePoints.Append(1) //bottom left X		  shapePoints.Append(15) //bottom left Y		  shapePoints.Append(8) //bottom middle X		  shapePoints.Append(15) //bottom middle Y		  shapePoints.Append(15) //right middle X		  shapePoints.Append(8) //right middle X		  shapePoints.Append(8) //top middle X		  shapePoints.Append(1) //top middle Y		  		  StartCursorPic.Graphics.FillPolygon(shapePoints)		  		  //draw the mask of the shape the size you want to make a clean mask without any white noise		  		  //background again		  StartCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		  StartCursorPic.Mask.Graphics.FillRect(0, 0, StartCursorPic.Width, StartCursorPic.Height)		  		  //shape again		  StartCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		  		  dim shapeMaskPoints(0) as integer		  shapeMaskPoints.Append(0) //top left X		  shapeMaskPoints.Append(0) //top left Y		  shapeMaskPoints.Append(0) //bottom left X		  shapeMaskPoints.Append(16) //bottom left Y		  shapeMaskPoints.Append(8) //bottom middle X		  shapeMaskPoints.Append(16) //bottom middle Y		  shapeMaskPoints.Append(16) //right middle X		  shapeMaskPoints.Append(8) //right middle X		  shapeMaskPoints.Append(8) //top middle X		  shapeMaskPoints.Append(0) //top middle Y		  		  StartCursorPic.Mask.Graphics.FillPolygon(shapeMaskPoints)		  		  //blit the pic to the CursorAreaPic		  g.DrawPicture(StartCursorPic, StartCursorX, 0)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawCursor(StopCursor as StopCursorObj, g as Graphics, StopCursorX as integer) As boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursor(StopCursor)")		  #endif		  		  dim StopCursorPic as Picture = NewPicture(kRulerPicHeight, kRulerPicHeight, 32)		  if StopCursorPic = nil then return false		  		  //draw the background		  StopCursorPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		  StopCursorPic.Graphics.FillRect(0, 0, StopCursorPic.Width, StopCursorPic.Height)		  		  //draw the main shape just a pixel smaller than you want so we make a black border later		  dim mColor as color = ParentWindow.SongMgr.ColorStopCursor		  dim ColorR as integer = ParentWindow.SongMgr.ColorStopCursor.Red		  dim ColorG as integer = ParentWindow.SongMgr.ColorStopCursor.Green		  dim ColorB as integer = ParentWindow.SongMgr.ColorStopCursor.Blue		  		  if StopCursor.Selected = true then		    mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		  end if		  		  StopCursorPic.Graphics.ForeColor = mColor		  		  dim shapePoints(0) as integer		  		  shapePoints.Append(1) //left middle X		  shapePoints.Append(8) //left middle Y		  shapePoints.Append(8) //bottom middle X		  shapePoints.Append(15) //bottom middle Y		  shapePoints.Append(15) //bottom right X		  shapePoints.Append(15) //bottom right Y		  shapePoints.Append(15) //top right X		  shapePoints.Append(1) //top right Y		  shapePoints.Append(8) //top middle X		  shapePoints.Append(1) //top middle Y		  		  StopCursorPic.Graphics.FillPolygon(shapePoints)		  		  //draw the mask of the shape the size you want to make a clean mask without any white noise		  		  //background again		  StopCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		  StopCursorPic.Mask.Graphics.FillRect(0, 0, StopCursorPic.Width, StopCursorPic.Height)		  		  //shape again		  StopCursorPic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		  dim shapeMaskPoints(0) as integer		  		  shapeMaskPoints.Append(0) //left middle X		  shapeMaskPoints.Append(8) //left middle Y		  shapeMaskPoints.Append(8) //bottom middle X		  shapeMaskPoints.Append(16) //bottom middle Y		  shapeMaskPoints.Append(16) //bottom right X		  shapeMaskPoints.Append(16) //bottom right Y		  shapeMaskPoints.Append(16) //top right X		  shapeMaskPoints.Append(0) //top right Y		  shapeMaskPoints.Append(8) //top middle X		  shapeMaskPoints.Append(0) //top middle Y		  		  StopCursorPic.Mask.Graphics.FillPolygon(shapeMaskPoints)		  		  //blit the pic to the CursorAreaPic		  g.DrawPicture(StopCursorPic, StopCursorX, 0)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function DrawCursorArea() As Boolean		  #if kLogMethods		    'Log("GUIObj.DrawCursorArea")		  #endif		  		  //Called by me.Draw		  		  dim picWidth, picHeight as integer		  		  picWidth = Width - kKeyPicWidth		  picHeight = kRulerPicHeight		  		  CursorAreaPic = NewPicture(picWidth, picHeight, 32)		  		  if CursorAreaPic = nil or CursorAreaPic.Width <> picWidth or CursorAreaPic.Height <> picHeight then		    return false		  end if		  		  dim g as Graphics		  g = CursorAreaPic.Graphics		  		  //background color		  g.ForeColor = ParentWindow.SongMgr.ColorGuideRuler		  g.FillRect(0, 0, g.Width, g.Height)		  		  //shadow color		  g.ForeColor = ParentWindow.SongMgr.ColorShadow		  g.DrawLine(0, g.Height - 1, g.Width, g.Height - 1)		  		  dim editorX1 as integer = ScrollDeltaX * ResolutionX		  dim editorX2 as integer = editorX1 + (me.Width - kKeyPicWidth)		  		  dim StartCursorX as integer = ParentWindow.PlayMgr.StartCursor.StartBeat * ResolutionX		  dim StartCursorX1 as integer = StartCursorX 'GetRightAlignCursorX1(StartCursorX)		  dim StartCursorX2 as integer = StartCursorX + kRulerPicHeight		  		  //if picX1 + picX2 >= editorX1 AND picX1 <= editorX1 + editorX2		  if StartCursorX1 + StartCursorX2 >= editorX1 AND StartCursorX1 <= editorX1 + editorX2 then		    if DrawCursor(ParentWindow.PlayMgr.StartCursor, g, StartCursorX1 - (scrollDeltaX * ResolutionX)) = false then return false		  end if		  		  dim StopCursorX as integer = ParentWindow.PlayMgr.StopCursor.StartBeat * ResolutionX		  dim StopCursorX1 as integer = GetLeftAlignCursorX1(StopCursorX)		  dim StopCursorX2 as integer = StopCursorX1 + kRulerPicHeight		  		  if StopCursorX1 + StopCursorX2 >= editorX1 AND StopCursorX1 <= editorX1 + editorX2 then		    if DrawCursor(ParentWindow.PlayMgr.StopCursor, g, StopCursorX1 - (scrollDeltaX * ResolutionX)) = false then return false		  end if		  		  If ParentWindow.PlayMgr.LoopPlay then		    dim LoopStartCursorX as integer = ParentWindow.PlayMgr.LoopStartCursor.StartBeat * ResolutionX		    dim LoopStartCursorX1 as integer = LoopStartCursorX 'GetRightAlignCursorX1(LoopStartCursorX)		    dim LoopStartCursorX2 as integer = LoopStartCursorX1 + kRulerPicHeight		    		    if LoopStartCursorX1 + LoopStartCursorX2 >= editorX1 AND LoopStartCursorX1 <= editorX1 + editorX2 then		      if DrawCursor(ParentWindow.PlayMgr.LoopStartCursor, g, LoopStartCursorX1 - (scrollDeltaX * ResolutionX)) = false then return false		    end if		    		    dim LoopStopCursorX as integer = ParentWindow.PlayMgr.LoopStopCursor.StartBeat * ResolutionX		    dim LoopStopCursorX1 as integer = GetLeftAlignCursorX1(LoopStopCursorX)		    dim LoopStopCursorX2 as integer = LoopStopCursorX1 + kRulerPicHeight		    		    if LoopStopCursorX1 + LoopStopCursorX2 >= editorX1 AND LoopStopCursorX1 <= editorX1 + editorX2 then		      if DrawCursor(ParentWindow.PlayMgr.LoopStopCursor, g, LoopStopCursorX1 - (scrollDeltaX * ResolutionX)) = false then return false		    end if		  End If		  		  dim EditCursorX as integer = ParentWindow.PlayMgr.EditCursor.StartBeat * ResolutionX		  dim EditCursorX1 as integer = GetCenterAlignCursorX1(EditCursorX)		  dim EditCursorX2 as integer = EditCursorX1 + kRulerPicHeight		  		  if EditCursorX1 + EditCursorX2 >= editorX1 AND EditCursorX1 <= editorX1 + editorX2 then		    if DrawCursor(ParentWindow.PlayMgr.EditCursor, g, EditCursorX1 - (scrollDeltaX * ResolutionX)) = false then return false		  end if		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawEditor() As Boolean		  #if kLogMethods		    'Log("GUIObj.DrawEditor")		  #endif		  		  //Called by me.Draw		  		  //Everything appears correctly, but I don't like how this is done. It seems illogical for all sorts of reasons.		  		  dim picWidth, picHeight as integer		  		  picWidth = Width - KeysPic.Width		  picHeight = Height - RulerPic.Height		  		  EditorPic = NewPicture(picWidth, picHeight, 32)		  		  if EditorPic = nil or EditorPic.Width <> picWidth or EditorPic.Height <> picHeight then		    return false		  end if		  		  dim g as Graphics		  g = EditorPic.Graphics		  		  //draw the white key color, which is also the background color just to clear everything (just in case)		  g.ForeColor = ParentWindow.SongMgr.ColorWhiteKey		  g.FillRect (0, 0, g.Width, g.Height)		  		  DrawEditorKeys(g)		  DrawEditorGuides(g)		  DrawChordOutlines(g)		  DrawGroupOutlines(g)		  DrawObjects(g)		  DrawSelectionArea(g)		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawEditorGuides(g as Graphics)		  //draw the note guides		  dim x as integer		  dim measureUnit, newNoteUnit as integer		  dim LineX1, LineY1, LineX2, LineY2 as integer		  		  startX = ScrollDeltaX * ResolutionX		  endX = startX + g.Width		  stepX = ResolutionX		  		  measureUnit = ParentWindow.SongMgr.TimeSignatureBeatsPerMeasure * ParentWindow.SongMgr.TimeSignatureBasicBeat		  newNoteUnit = ParentWindow.NoteMgr.NewNoteLength		  		  for x = startX to endX step stepX		    		    LineX1 = x - startX		    LineY1 = 0		    LineX2 = LineX1		    LineY2 = g.Height		    		    if ParentWindow.yScrollBar.Value = ParentWindow.yScrollBar.Maximum then		      LineY2 = g.Height \ ResolutionY * ResolutionY		    end if		    		    if g.Height > MIDILib.kMIDINoteCount * ResolutionY then		      LineY2 = MIDILib.kMIDINoteCount * ResolutionY		    end if		    		    if (x \ ResolutionX) mod SnapTo = 0 then //draw the SnapTo increment		      g.ForeColor = ParentWindow.SongMgr.ColorEditorNewNoteLength		      g.DrawLine(LineX1, LineY1, LineX2, LineY2)		    end if		    		    if (x \ ResolutionX) mod ParentWindow.SongMgr.TimeSignatureBasicBeat = 0 then //draw the basic beat		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBasicBeat		      g.DrawLine(LineX1, LineY1, LineX2, LineY2)		    end if		    		    if (x \ ResolutionX) mod measureUnit = 0 then //draw measure		      g.ForeColor = ParentWindow.SongMgr.ColorMeasure		      g.DrawLine(LineX1, LineY1, LineX2, LineY2)		    end if		    		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawEditorKeys(g as Graphics)		  //Draw the keys		  dim x, y as integer		  		  SetDrawYParameters		  		  for y = startY to endY step StepY		    		    SetNoteValue(y)		    		    //this is an inverse relationship between notes and pixels		    //and this makes sure we're only doing those values that are playable		    if noteValueRaw <= 0 then		      		      dim topLeft as integer		      topLeft = y - startY - ResolutionY		      		      //draw the key color		      if MusicLib.IsBlackKey(noteValue) then		        g.ForeColor = ParentWindow.SongMgr.ColorBlackKey		      else		        g.ForeColor = ParentWindow.SongMgr.ColorWhiteKey		      end if		      g.FillRect(0, topLeft + 1, g.Width, ResolutionY)		      		      //draw the key divider		      g.ForeColor = ParentWindow.SongMgr.ColorBlackKey		      g.DrawLine(0, topLeft, g.Width, topLeft)		      		      //draw the octave divider		      if MusicLib.IsOctave(NoteValue + 1) <> "X" then		        g.ForeColor = ParentWindow.SongMgr.ColorOctave		        g.DrawLine(0, topLeft, g.Width, topLeft)		      end if		      		      //draw the bottom border		      if NoteValue = 0 then		        g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		        g.DrawLine(0, topLeft + ResolutionY, g.Width, topLeft + ResolutionY)		        g.ForeColor = ParentWindow.SongMgr.ColorGuideWhiteShadowKey		        g.DrawLine(0, topLeft + ResolutionY + 1, g.Width, topLeft + ResolutionY + 1)		      end if		      		    end if		    		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawGroupOutlines(g as graphics)		  #if kLogMethods		    'Log("GUIObj.DrawGroupOutlines")		  #endif		  		  //draw the groups		  dim thisTrack as integer = 0		  dim firstTrack as integer = 0		  dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		  		  for thisTrack = lastTrack DownTo firstTrack		    dim track as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0)		    if track <> nil then		      if track.Visible then		        		        dim thisGroup as integer = 0		        dim firstGroup as integer = 0		        dim lastGroup as integer = Ubound(ParentWindow.NoteMgr.Groups)		        		        for thisGroup = firstGroup to lastGroup		          if ParentWindow.NoteMgr.Groups(thisGroup) <> nil then		            dim group as GroupObj = ParentWindow.NoteMgr.Groups(thisGroup)		            if group.Track = track then		              dim GroupOutline as GroupOutlineObj = GetOutline(group)		              if GroupOutline <> Nil then		                me.EditorPic.Graphics.DrawPicture(GroupOutline.Pic, GroupOutline.X, GroupOutline.Y)		              end if		            end if		          end if		        next		        		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawKeys() As Boolean		  #if kLogMethods		    'Log("GUIObj.DrawKeys")		  #endif		  		  //Called by me.Draw		  		  dim picWidth, picHeight as integer		  		  picWidth = kKeyPicWidth		  picHeight = Height - kRulerPicHeight		  		  KeysPic = NewPicture(picWidth, picHeight, 32)		  		  if KeysPic = nil or KeysPic.Width <> picWidth or KeysPic.Height <> picHeight then		    return false		  end if		  		  dim g as Graphics		  g = KeysPic.Graphics		  		  //draw the white key color, which is also the background color		  g.ForeColor = ParentWindow.SongMgr.ColorWhiteKey		  g.FillRect (0, 0, g.Width, g.Height)		  		  //set the length of the song		  SetSongLength		  		  //draw the grid; do the Keys first so that the black keys are on the bottom.		  //the key must be shifted up by the resolution amount		  dim x, y as integer		  		  SetDrawYParameters		  		  //prep the Note InKey indicators; I think we should make these gradients from 50% to 0% Opaque		  dim thisKey as KeyObj		  if Ubound(ParentWindow.SongMgr.Keys) <> -1 then		    thisKey = ParentWindow.SongMgr.Keys(0)		  end if		  		  for y = startY to endY step StepY		    		    SetNoteValue(y)		    		    //this is an inverse relationship between notes and pixels		    //and this makes sure we're only doing those values that are playable		    if noteValueRaw <= 0 then		      		      dim topLeft as integer		      topLeft = y - startY - ResolutionY		      		      //draw the key color		      if MusicLib.IsBlackKey(noteValue) then		        g.ForeColor = ParentWindow.SongMgr.ColorGuideBlackKey		        g.FillRect(0, topLeft + 1, g.Width, ResolutionY)		        //shadow line		        g.ForeColor = ParentWindow.SongMgr.ColorGuideBlackShadowKey		        g.DrawLine(0, topLeft + ResolutionY - 1, g.Width, topLeft + ResolutionY - 1)		        g.DrawLine(g.Width - 1, topLeft, g.Width - 1, topLeft + ResolutionY)		      else		        g.ForeColor = ParentWindow.SongMgr.ColorGuideWhiteKey		        g.FillRect(0, topLeft + 1, g.Width, ResolutionY)		        g.ForeColor = ParentWindow.SongMgr.ColorGuideWhiteShadowKey		        g.DrawLine(0, topLeft + ResolutionY - 1, g.Width, topLeft + ResolutionY - 1)		        g.DrawLine(g.Width - 1, topLeft, g.Width - 1, topLeft + ResolutionY)		      end if		      		      //draw the Note In Key indicator; these are created at the beginning of the method.		      if thisKey <> nil then		        if thisKey.IsPitchWithinKey(NoteValue) <> -1 then		          //draw the indicator		          if MusicLib.GetNoteName(noteValue) = MusicLib.GetNoteName(thisKey.Tonic) then		            g.DrawPicture(NoteInKeyTonic, 1, topLeft + 1)		          else		            g.DrawPicture(NoteInKey, 1, topLeft + 1)		          end if		        end if		      end if		      		      //draw the octave name		      dim stringX, stringY as integer		      dim octaveName as string		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.TextSize = 9		      stringX = 2		      stringY = y - startY - 2		      octaveName = MusicLib.IsOctave(noteValue)		      if octaveName <> "X" then		        g.DrawString(octaveName, stringX, stringY)		      end if		      		      //draw the key divider		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.DrawLine(0, topLeft, g.Width, topLeft)		      		      if NoteValue = 0 then		        g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine //black line		        g.DrawLine(0, topLeft + ResolutionY, g.Width, topLeft + ResolutionY)		        g.ForeColor = ParentWindow.SongMgr.ColorGuideWhiteShadowKey//shadow line		        g.DrawLine(0, topLeft + ResolutionY + 1, g.Width, topLeft + ResolutionY + 1)		      end if		      		      #if DebugBuild //draw the note name		        g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		        g.TextSize = 9		        if ParentWindow.TrackListObj1.CurrentTrack <> nil and ParentWindow.TrackListObj1.CurrentTrack.Instrument <> 16385 then		          'g.DrawString(Str(noteValue) + " " + MusicLib.GetNoteName(noteValue), g.width - (g.Width / 2) - 6, stringY) //draw the note name		          g.DrawString(Str(noteValue), g.width - (g.Width / 2) - 6, stringY) //draw the note value		        else		          'g.DrawString(MIDILib.GetMIDIPercussionName(noteValue), g.width - (g.Width / 2) - 6, stringY)		        end if		      #endif		      		      if ParentWindow.TrackListObj1.CurrentTrack <> nil and ParentWindow.TrackListObj1.CurrentTrack.Instrument = 16385 then		        g.DrawString(MIDILib.GetMIDIPercussionName(noteValue), g.width - (g.Width / 2) - 6, stringY)		      end if		      		    end if		    		  next		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawObject(Chord as ChordObj)		  #if kLogMethodsVerbose		    'Log("GUIObj.DrawObject(ChordObj)")		  #endif		  		  dim thisNote as Integer = 0		  dim firstNote as Integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      DrawObject(Note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawObject(Group as GroupObj)		  #if kLogMethodsVerbose		    'Log("GUIObj.DrawObject(GroupObj)")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        DrawObject(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        DrawObject(Chord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        DrawObject(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawObject(Note as NoteObj)		  #if kLogMethodsVerbose		    'Log("GUIObj.DrawObject(NoteObj)")		  #endif		  		  //Called by me.DrawEditor		  		  if Note = nil then return		  		  dim editorX1, editorY1, editorX2, editorY2 as integer //"m" need to chance to something more descriptive		  dim noteX, noteY, picX2, picY2, picX1, picY1 as integer		  		  editorX1 = ScrollDeltaX * ResolutionX		  editorX2 = editorX1 + EditorPic.Width		  editorY1 = ScrollDeltaY * ResolutionY		  editorY2 = editorY1 + EditorPic.Height		  		  noteX = Note.StartBeat * ResolutionX		  noteY = Abs(Note.Pitch - MIDILib.kMIDINoteCount) * ResolutionY - ResolutionY //this is going to bite us in the ass later.		  		  picX2 = Note.Length * ResolutionX		  picY2 = ResolutionY		  		  picX1 = noteX		  picY1 = noteY		  		  //is the note within the editor area		  if picX1 + picX2 >= editorX1 AND picX1 <= editorX1 + editorX2 AND picY1 + picY2 >= editorY1 AND picY1 <= editorY1 + editorY2 then		    		    dim ColorR, ColorG, ColorB as integer		    dim mColor as Color		    dim picWidth, picHeight as integer		    dim Pic as Picture		    dim noteTrack as TrackObj = Note.Track		    		    ColorR = noteTrack.VisualCue.Red		    ColorG = noteTrack.VisualCue.Green		    ColorB = noteTrack.VisualCue.Blue		    		    picWidth = picX2		    picHeight = picY2		    Pic = NewPicture(picWidth, picHeight, 32)		    		    if Pic = nil then		      MsgBox "DrawNote: Out of Memory (" + str(picWidth) + "x" + Str(picHeight) + ")"		      Quit		    end if		    		    //this is the outer outline		    Pic.Graphics.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		    Pic.Graphics.DrawRect(0, 0, pic.Width, pic.Height)		    		    //Object selection is a deep selection.		    //if the note, the note.Chord or the note.Group is selected, then this is selected as well.		    if Note.Selected = true then		      mColor = RGB(max((ColorR - 50), 0), max((ColorG - 50), 0), max((ColorB - 50), 0))		    else		      mColor = RGB(ColorR, ColorG, ColorB)		    end if		    		    //this is the visual cue		    Pic.Graphics.ForeColor = mColor		    Pic.Graphics.FillRect(2, 2, pic.Width - 4, pic.Height - 4)		    		    //show it's locked		    if Note.Locked = true then		      //draw a "lock"; actually, it's a peg. A lock is preferred, but this scales when zoomed.		      pic.Graphics.ForeColor = ParentWindow.SongMgr.kColorWhite		      Pic.Graphics.FillOval(3, (pic.Height \ 2) - ((pic.Height \ 3) \ 2), pic.Height \ 3, pic.Height \ 3)		      		      'Pic.Graphics.ForeColor = Note.Melody.VisualCue		      'Pic.Graphics.DrawRect(0, 0, pic.Width, pic.Height)		    end if		    		    //draw the resize tab		    dim ResizeTabColor as Color		    ResizeTabColor = RGB(max((ColorR - 80), 0), max((ColorG - 80), 0), max((ColorB - 80), 0))		    if ResizeMode = false then		      pic.Graphics.ForeColor = ResizeTabColor		    else		      if Note.Selected = true then		        pic.Graphics.ForeColor = ParentWindow.SongMgr.kColorWhite		      else		        pic.Graphics.ForeColor = ResizeTabColor		      end if		    end if		    		    If pic.Width > MIDILib.kNoteLength_64 * 5 then //5 is a resolutionX value that makes a 1/64th into a near perfect (or perfect) square.		      pic.Graphics.FillRect(pic.Width - 10, 1, 9, pic.Height - 2)		    else		      'pic.Graphics.FillRect(pic.Width \ 2, 1, pic.Width \ 2, pic.Height - 2)		    End If		    		    //draw the velocity		    dim VelocityIndicatorColor as Color		    VelocityIndicatorColor = RGB(min((ColorR + 80), 255), min((ColorG + 80), 255), min((ColorB + 80), 255))		    pic.Graphics.ForeColor = VelocityIndicatorColor		    dim velocityPercentage as double		    dim velocityIndicatorLength as Integer		    velocityIndicatorLength= (pic.Width - 3) * (Note.Velocity / MIDILib.kMIDIVelocityMax)		    pic.Graphics.DrawLine(1, pic.Height \ 2, velocityIndicatorLength, picHeight \ 2) //horizontal		    pic.Graphics.DrawLine(velocityIndicatorLength, pic.Height \ 4, velocityIndicatorLength, pic.Height - (pic.Height \ 4)) //vertical		    		    //this is the inner outline		    Pic.Graphics.ForeColor = Note.Track.VisualCue		    Pic.Graphics.DrawRect(1, 1, pic.Width - 2, pic.Height - 2)		    		    //show it's muted		    if Note.Track.Play = false then		      //make it transparent		      pic.Mask.Graphics.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      pic.Mask.Graphics.FillRect(0, 0, pic.Width, pic.Height)		      pic.Mask.Graphics.ForeColor = &c7F7F7F		      pic.Mask.Graphics.FillRect(2, 2, pic.Width - 4, pic.Height - 4)		    end if		    		    me.EditorPic.Graphics.DrawPicture(Pic, noteX - (scrollDeltaX * ResolutionX), noteY - (ScrollDeltaY * ResolutionY))		    		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawObjects(G as graphics)		  #if kLogMethods		    'Log("GUIObj.DrawObjects")		  #endif		  		  dim thisTrack as integer = 0		  dim firstTrack as integer = 0		  dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		  		  for thisTrack = lastTrack DownTo firstTrack //this goes from the bottom track up to the top.		    dim track as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0)		    if track <> nil then		      if track.Visible then		        		        dim thisMusicObject as integer = 0		        dim firstMusicObject as integer = 0		        dim lastMusicObject as integer = Ubound(track.Music)		        		        for thisMusicObject = firstMusicObject to lastMusicObject		          if track.Music(thisMusicObject) <> nil then		            		            if track.Music(thisMusicObject) IsA GroupObj then		              dim mGroup as GroupObj = track.Music(thisMusicObject)		              DrawObject(mGroup)		            end if		            		            if track.Music(thisMusicObject) IsA ChordObj then		              dim mChord as ChordObj = track.Music(thisMusicObject)		              DrawObject(mChord)		            end if		            		            if track.Music(thisMusicObject) IsA NoteObj then		              dim Note as NoteObj = track.Music(thisMusicObject)		              DrawObject(Note)		            end if		            		          end if		        next		        		      end if		    end if		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function DrawRuler() As Boolean		  #if kLogMethods		    'Log("GUIObj.DrawRuler")		  #endif		  		  //Called by me.Draw		  		  dim picWidth, picHeight as integer		  		  picWidth = Width - kKeyPicWidth		  picHeight = kRulerPicHeight		  		  RulerPic = NewPicture(picWidth, picHeight, 32)		  		  if RulerPic = nil or RulerPic.Width <> picWidth or RulerPic.Height <> picHeight then		    return false		  end if		  		  dim g as Graphics		  g = RulerPic.Graphics		  		  //background color		  g.ForeColor = ParentWindow.SongMgr.ColorGuideRuler		  g.FillRect(0, 0, g.Width, g.Height)		  		  //shadow color		  g.ForeColor = ParentWindow.SongMgr.ColorShadow		  g.DrawLine(0, g.Height - 1, g.Width, g.Height - 1)		  		  //draw the ruler lines		  //this code is based on what is used to draw the guides in the Editor. 		  //It doesn't have dynamic zoom (which wasn't entirely necessary; just cool), but it's much cleaner and reliable.		  dim x as integer		  dim measureUnit, newNoteUnit as integer		  dim LineX1, LineY1, LineX2, LineY2 as integer		  		  startX = ScrollDeltaX * ResolutionX		  endX = startX + g.Width		  stepX = ResolutionX		  		  measureUnit = ParentWindow.SongMgr.TimeSignatureBeatsPerMeasure * ParentWindow.SongMgr.TimeSignatureBasicBeat		  newNoteUnit = ParentWindow.NoteMgr.NewNoteLength		  		  g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		  		  for x = startX to endX step stepX		    		    LineX1 = x - startX		    LineY1 = 0		    LineX2 = LineX1		    LineY2 = g.Height		    		    if ParentWindow.yScrollBar.Value = ParentWindow.yScrollBar.Maximum then		      LineY2 = g.Height \ ResolutionY * ResolutionY		    end if		    		    if g.Height > MIDILib.kMIDINoteCount * ResolutionY then		      LineY2 = MIDILib.kMIDINoteCount * ResolutionY		    end if		    		    if (x \ ResolutionX) mod ParentWindow.SongMgr.TimeSignatureBasicBeat = 0 then //draw the basic beat		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.DrawLine(LineX1, LineY1 + (LineY2 \ 2), LineX2, LineY2)		    elseif (x \ ResolutionX) mod SnapTo = 0 then //draw the SnapTo increment		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.DrawLine(LineX1, LineY1 + (LineY2 - 3), LineX2, LineY2)		    end if 		    		    if (x \ ResolutionX) mod measureUnit = 0 then //draw measure		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.DrawLine(LineX1, LineY1, LineX2, LineY2)		      g.ForeColor = ParentWindow.SongMgr.ColorShadow		      g.DrawLine(LineX1 + 1, LineY1 - 1, LineX2 + 1, LineY2)		      g.ForeColor = ParentWindow.SongMgr.ColorEditorBorderLine		      g.TextSize = 9		      g.DrawString(str((x \ ResolutionX \ ParentWindow.SongMgr.TimeSignatureBeatsPerMeasure \ ParentWindow.SongMgr.TimeSignatureBasicBeat) + 1), (x - startX + 2), (g.Height - 6))		    end if		    		  next		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawSelectionArea(g as Graphics)		  //draw the drag select area; matches the same scheme as Mac OS X's		  if DragSelectMode = true then		    dim SelectionPic as Picture		    SelectionPic = NewPicture(Abs(FullX1 - FullX2), Abs(FullY1 - FullY2), 32)		    if SelectionPic <> nil then		      //background		      SelectionPic.Graphics.ForeColor = ParentWindow.TrackListObj1.CurrentTrack.VisualCue		      SelectionPic.Graphics.FillRect(0, 0, SelectionPic.Width, SelectionPic.Height)		      //outline		      SelectionPic.Graphics.ForeColor = ParentWindow.SongMgr.kColorBlack		      SelectionPic.Graphics.DrawRect(0, 0, SelectionPic.Width, SelectionPic.Height)		      //transparency		      SelectionPic.Mask.Graphics.ForeColor = &cE5E5E5		      SelectionPic.Mask.Graphics.FillRect(1, 1, SelectionPic.Width - 2, SelectionPic.Height - 2)		      g.DrawPicture(SelectionPic, FullX1 - (scrollDeltaX * ResolutionX), FullY1 - (scrollDeltaY * ResolutionY))		    end if		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DrawTracks()		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetCenterAlignCursorX1(CursorX as integer) As Integer		  return CursorX - (kRulerPicHeight / 2) + 1		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetLeftAlignCursorX1(CursorX as integer) As Integer		  return CursorX - kRulerPicHeight + 2		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetOutline(Chord as ChordObj) As GroupOutlineObj		  #if kLogMethodsVerbose		    'Log("GUIObj.GetOutline(ChordObj)")		  #endif		  		  dim root as NoteObj = chord.root		  dim chordNoteCount as integer = Ubound(chord.Notes)		  		  dim outlineX1 as integer = root.StartBeat		  dim outlineY1 as integer = root.Pitch		  dim outlineX2 as integer = root.StartBeat		  dim outlineY2 as integer = root.Pitch		  		  //chord outline		  dim c as integer		  for c = chordNoteCount DownTo 0		    if chord.Notes(c) <> nil then		      dim note as NoteObj = chord.Notes(c)		      outlineX1 = min(outlineX1, note.StartBeat)		      outlineX2 = max(outlineX2, note.StartBeat + note.Length)		      outlineY1 = max(outlineY1, note.Pitch)		      outlineY2 = min(outlineY2, note.Pitch)		    end if		  next		  		  outlineY1 = Abs(outlineY1 - MIDILib.kMIDINoteCount)		  outlineY2 = Abs(outlineY2 - MIDILib.kMIDINoteCount)		  		  outlineX1 = (outlineX1 - ScrollDeltaX) * ResolutionX		  outlineX2 = (outlineX2 - ScrollDeltaX) * ResolutionX		  outlineY1 = ((outlineY1 - ScrollDeltaY) * ResolutionY) - ResolutionY		  outlineY2 = (outlineY2 - ScrollDeltaY) * ResolutionY		  		  //Draw the chord outline		  dim chordOutline as Picture		  dim chordOutlineWidth as integer = Abs(outlineX1 - outlineX2)		  dim chordOutlineHeight as integer = Abs(outlineY1 - outlineY2)		  		  chordOutline = NewPicture(chordOutlineWidth, chordOutlineHeight, 32) //coming back as nil, because sometimes Y = 0.		  		  if chordOutline <> nil then		    //background		    chordOutline.Graphics.ForeColor = chord.Track.VisualCue		    chordOutline.Graphics.FillRect(0, 0, chordOutline.Width, chordOutline.Height)		    //transparency		    //fill		    chordOutline.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_080		    chordOutline.Mask.Graphics.FillRect(1, 1, chordOutline.Width - 2, chordOutline.Height - 2)		    //stroke		    chordOutline.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		    chordOutline.Mask.Graphics.DrawRect(0, 0, chordOutline.Width, chordOutline.Height)		  end if		  		  dim GroupOutlineReturn as GroupOutlineObj = New GroupOutlineObj		  		  GroupOutlineReturn.Pic = chordOutline		  GroupOutlineReturn.X = outlineX1		  GroupOutlineReturn.Y = outlineY1		  		  return GroupOutlineReturn		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetOutline(Group as GroupObj) As GroupOutlineObj		  #if kLogMethodsVerbose		    'Log("GUIObj.GetOutline(GroupObj)")		  #endif		  		  //group outline		  dim GroupOutlineReturn as GroupOutlineObj = New GroupOutlineObj		  		  //somehow here we need to intialize the four coordinates		  		  GroupOutlineReturn = Group.GetBounds(GroupOutlineReturn)		  		  dim outlineX1 as integer = GroupOutlineReturn.OutlineX1		  dim outlineY1 as integer = GroupOutlineReturn.OutlineY1		  dim outlineX2 as integer = GroupOutlineReturn.OutlineX2		  dim outlineY2 as integer = GroupOutlineReturn.OutlineY2		  		  outlineY1 = Abs(outlineY1 - MIDILib.kMIDINoteCount)		  outlineY2 = Abs(outlineY2 - MIDILib.kMIDINoteCount)		  		  outlineX1 = (outlineX1 - ScrollDeltaX) * ResolutionX		  outlineX2 = (outlineX2 - ScrollDeltaX) * ResolutionX		  outlineY1 = ((outlineY1 - ScrollDeltaY) * ResolutionY) - ResolutionY		  outlineY2 = (outlineY2 - ScrollDeltaY) * ResolutionY		  		  //Draw the group outline		  		  dim PaddingMax as integer = 6		  dim PaddingOffset as integer = PaddingMax / 2		  dim GroupOutlineArch as integer = PaddingMax * 2		  		  dim groupOutline as Picture		  dim groupOutlineWidth as integer = Abs(outlineX1 - outlineX2) + PaddingMax		  dim groupOutlineHeight as integer = Abs(outlineY1 - outlineY2) + PaddingMax		  		  groupOutline = NewPicture(groupOutlineWidth, groupOutlineHeight, 32) //coming back as nil, because sometimes Y = 0.		  		  if groupOutline <> nil then		    //This creates the bounding outline		    //background		    groupOutline.Graphics.ForeColor = group.Track.VisualCue		    groupOutline.Graphics.FillRect(0, 0, groupOutlineWidth, groupOutlineHeight)		    //transparency		    //background		    groupOutline.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_100		    groupOutline.Mask.Graphics.FillRect(0, 0, groupOutlineWidth, groupOutlineHeight)		    //fill		    groupOutline.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_090		    groupOutline.Mask.Graphics.FillRoundRect(0, 0, groupOutlineWidth, groupOutlineHeight, GroupOutlineArch, GroupOutlineArch)		    //stroke		    groupOutline.Mask.Graphics.ForeColor = ParentWindow.SongMgr.kColorMaskTransparent_000		    groupOutline.Mask.Graphics.DrawRoundRect(0, 0, groupOutlineWidth, groupOutlineHeight, GroupOutlineArch, GroupOutlineArch)		    		  end if		  		  GroupOutlineReturn.Pic = groupOutline		  GroupOutlineReturn.X = outlineX1 - PaddingOffset		  GroupOutlineReturn.Y = outlineY1 - PaddingOffset		  		  return GroupOutlineReturn		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetRightAlignCursorX1(CursorX as integer) As Integer		  return CursorX - (scrollDeltaX * ResolutionX)		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Log(theText as String)		  WindowLog.Log(theText)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub MoveCursor(X as integer, Y as integer, deltaX as integer, deltaY as integer)		  #if kLogMethods		    'Log("GUIObj.MoveCursor(Integer, Integer, deltaX, deltaY)")		  #endif		  		  if ParentWindow.PlayMgr.SelectedCursor = nil then return		  		  ParentWindow.PlayMgr.SelectedCursor.StartBeat = ParentWindow.PlayMgr.SelectedCursor.OldStartBeat + deltaX		  		  //keep the ParentWindow.PlayMgr.SelectedCursor within the bounds of the editor and MIDI		  if ParentWindow.PlayMgr.SelectedCursor.StartBeat < 0 then ParentWindow.PlayMgr.SelectedCursor.StartBeat = 0		  		  //check the bounds of the selected cursor against its pair.		  if ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.StartCursor then		    if ParentWindow.PlayMgr.StartCursor.StartBeat >= ParentWindow.PlayMgr.StopCursor.StartBeat then		      ParentWindow.PlayMgr.StartCursor.StartBeat = ParentWindow.PlayMgr.StopCursor.StartBeat - 1		    end if		  end if		  		  if ParentWindow.PlayMgr.SelectedCursor = ParentWindow.PlayMgr.StartCursor then		    		  end if		  		  ParentWindow.PlayMgr.SelectedCursor.Label = str(ParentWindow.PlayMgr.SelectedCursor.StartBeat)		  		  ParentWindow.WindowNeedsSaving = true		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub MoveNote(Note as NoteObj, X as integer, Y as integer, deltaX as integer, deltaY as integer)		  #if kLogMethods		    'Log("GUIObj.MoveNote(NoteObj, Integer, Integer, deltaX, deltaY)")		  #endif		  		  Note.StartBeat = Note.OldStartBeat + deltaX		  Note.Pitch = Note.OldPitch - deltaY		  		  if note.Chord <> nil then note.Chord.StartBeat = note.StartBeat		  		  //keep the note within the bounds of the editor and MIDI		  if Note.StartBeat < 0 then Note.StartBeat = 0		  'if Note.StartBeat > SongLength then Note.StartBeat = SongLength //we want the user to go out as far as they want.		  if Note.Pitch < 0 then Note.Pitch = 0		  if Y + (ScrollDeltaY * ResolutionY) > MIDILib.kMIDINoteCount * ResolutionY then note.Pitch = 0 //keeps it from "bouncing"		  if Note.Pitch > MIDILib.kMIDINoteCount - 1 then Note.Pitch = MIDILib.kMIDINoteCount - 1		  		  Note.Label = str(Note.Pitch) + "." + str(Note.StartBeat)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub PrepNoteInKeyIndicators()		  #if kLogMethods		    'Log("GUIObj.PrepNoteInKeyIndicators")		  #endif		  		  //called by ParentWindow.SliderZoomY		  		  dim NoteInKeyWidth as integer = kKeyPicWidth \ 2		  dim NoteInKeyHeight as integer = ResolutionY - 1		  		  NoteInKey = NewPicture(NoteInKeyWidth, NoteInKeyHeight, 32)		  		  NoteInKey.Graphics.ForeColor = ParentWindow.SongMgr.ColorGuideNoteInKey		  NoteInKey.Graphics.FillRect(0, 0, NoteInKey.Graphics.Width, NoteInKey.Graphics.Height)		  		  NoteInKeyTonic = NewPicture(NoteInKeyWidth, NoteInKeyHeight, 32)		  NoteInKeyTonic.Graphics.ForeColor = ParentWindow.SongMgr.ColorGuideNoteInKeyTonic		  NoteInKeyTonic.Graphics.FillRect(0, 0, NoteInKeyTonic.Graphics.Width, NoteInKeyTonic.Graphics.Height)		  		  dim OpaqueValue as integer = 0		  dim TransparentValue as integer = 255		  		  dim i as integer		  dim r as integer = OpaqueValue		  dim g as integer = OpaqueValue		  dim b as integer = OpaqueValue		  		  for i = 0 to NoteInKeyWidth		    r = r + (TransparentValue \ NoteInKeyWidth)		    g = g + (TransparentValue \ NoteInKeyWidth)		    b = b + (TransparentValue \ NoteInKeyWidth)		    		    NoteInKey.Mask.Graphics.ForeColor = RGB(r, g, b)		    NoteInKey.Mask.Graphics.DrawLine(i, -1, i, NoteInKeyHeight)		    NoteInKeyTonic.Mask.Graphics.ForeColor = RGB(r, g, b)		    NoteInKeyTonic.Mask.Graphics.DrawLine(i, -1, i, NoteInKeyHeight)		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function ResizeTabHit(Note as NoteObj, X as integer, Y as integer) As Boolean		  #if kLogMethods		    Log("GUIObj.ResizeTabHit(Note as NoteObj, " + Str(X) + ", " + Str(Y) + ")")		  #endif		  		  //called by NoteMgr.MouseDown() after NoteMgr.EditNote(NoteObj)		  //here we blur the line between pixels and beats/pitches.		  //this looks to see if we hit the darkened tab that's on the end of every note.		  		  If Note = nil then return false //nothing was clicked so go away.		  		  dim i as integer		  dim ClickX, ClickY as integer		  dim noteX1, noteY1, noteX2, noteY2 as integer		  dim tabX1, tabX2 as integer		  		  //we convert the note's information into relative pixel values.		  noteX1 = (note.StartBeat * ResolutionX) - (ScrollDeltaX * ResolutionX)		  		  noteX2 = noteX1 + (note.Length * ResolutionX)		  		  noteY2 = (Abs(Note.Pitch - MIDILib.kMIDINoteCount) - ScrollDeltaY) * ResolutionY		  noteY1 = noteY2 - ResolutionY		  		  //we then sort out where the resize tab would be based on that information.		  if Abs(NoteX2 - NoteX1) > MIDILib.kNoteLength_64 * 5 then		    tabX1 = noteX2 - 9		    tabX2 = noteX2		  else		    return false		    'tabX1 = noteX2 \ 2		    'tabX2 = noteX2		  end if		  		  //if the DownXAbsolute value is within the tab, return true.		  if X - kKeyPicWidth >= tabX1 and X - kKeyPicWidth <= tabX2 then 'and Y >= noteY1 and Y <= noteY2		    return true		  end if		  		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetDrawYParameters()		  #if kLogMethods		    'Log("GUIObj.SetDrawYParameters")		  #endif		  		  //called by DrawKeys and DrawEditor (when drawing the keys)		  //to determine where things are drawn.		  		  StartY = ScrollDeltaY * ResolutionY		  EndY = StartY + me.Height - kTotalRulerHeight + ResolutionY		  StepY = ResolutionY		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetNoteValue(Y as integer)		  #if kLogMethodsVerbose		    'Log("GUIObj.SetNoteValue(" + Str(Y) + ")")		  #endif		  		  //called by DrawKeys, DrawEditor, and DrawNote to calculate the inverse		  //relationship between MIDI note values and pixels		  		  NoteValueRaw = (Y \ ResolutionY) - MIDILib.kMIDINoteCount		  NoteValue = Abs(NoteValueRaw)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetSongLength()		  #if kLogMethods		    'Log("GUIObj.SetSongLength")		  #endif		  		  //called by DrawEditor to determine where lines are drawn		  //this sets me.SongLength in pixels.		  		  SongLength = ParentWindow.NoteMgr.GetTotalBeats * ResolutionX		End Sub	#tag EndMethod	#tag Note, Name = About		This is the Mouse-centric user input takes place		It merely displays information and handles mouse clicks.		All calculations are in pixels.		All object manipulation is handled elsewhere.	#tag EndNote	#tag Note, Name = Known Bugs		ALL NEW BUGS NEED TO BE POSTED TOP MUSICSCKETCHBUGS.OO3				[WORKING] MouseDown needs to discriminate which track is active. But, this can't be fixed until we sort out why the hell 		TrackObjs aren't being assigned to PlayObjs.				[FIXED] 1/8 notes in default view don't have a right border. This applies to any pixel dimensions that are the same		as 1/8 notes in default view				[FIXED] Notes are dropped off the left before they should be.				[FIXED?] SetSongLength isn't getting the correct song length.		I think we need a better way to handle measures.		This is really only important for drawing.				[FIXED] Shift clicking an already selected doesn't take it out of the selection.		Forgot the "SelectionNote.Remove(i)" line from the NoteMgr.RemoveNoteFromSelection method				[IGNORE UNTIL NECESSARY] Drag Selection will have to be optimized to draw only the selected area.		The further out the user zooms, the slower the drawing is. This would require a massive refactoring back to pixel-based drawing		and putting in place properties I don't want into the NoteObj				[FIXED] Drag Selection doesn't give good RelativeZ values		Negating RelativeZ out of the equation gives off values as well, but in a different way.		Fixed by having the NoteMgr.EditNote method save the old values each time to all notes in the selection.				[FIXED] Dragging causes the notes to "walk" (e.g. not maintain a consistant relative distance from each other)		Maybe carry distance values across iterations of the loop? I think we tried that in an earler version of		the editor and it didn't work right, or maybe that was as an array?		Fixed with the above bug fix!!!				Maybe we can handle this via NoteMgr.Selection(n). So, instead of going through the track like we are now,		just iterate directily through the selection because selections can only be made in the active track.		It would most likely make for a tigher loop. The only issue is how to deal with chords but maybe we can just		work with the root and no touch the rest. Maybe have the chords check themselves after every move.				[FIXED] //the above line is raising a NilObjectException in certain instances.		//Possibly when deselecting a selection when the selection was made with drag selection.		//this is fixed in NoteMgr.CreateNoteToSelection by checking to make sure that the note in the area isn't already selected.		//Keeping the mouse down kept appending the same notes over and over again.	#tag EndNote	#tag Note, Name = New Features		New Rulers (all optional; only measures and ruler is mandatory)		Tempo (so that we can change tempos mid-song)		Key (so that we can change Keys mid-song)		Start/Stop/Current (for looping and hearing small samples)		Time Signature (so we can change time signatures mid-song)				Drag improvements		I noticed that both Reason and Logic don't show all of the notes (or any note for that matter) during the drag.		They both show the outline of the selection bounds and display the move that way, then just plop the notes where they need to go.				Zoom		Perhaps the Zoom values can apply to double values (.125 - 8.0) and the zoom can calculate from that.				dim i as integer		dim length as integer				for i = 0 to 500 step 1		length = 48 * (i * .01)		me.AppendText(Str(i) + " = " + Str(length))		if i mod 3 = 0 then		me.AppendText(" <-" + EndOfLine)		else		me.AppendText(EndOfLine)		end if		next	#tag EndNote	#tag Note, Name = Refactoring the drawing Major		GOAL: To refactor different areas of GUIObj to actual objects that can be acted upon.				ADVANTAGES:		[ ] Faster drawing by only drawing those areas that are affected, possibly even moving the drawing to threads in some cases.		[ ] This will allow for easier implementation of new rulers AND allow for different ruler options as part of planned features.		[ ] Better encapsulation of code for the different editing actions because GUIObj will only be used to capture Mouse movements and high level drawing only				DISADVANTAGES:		[ ] Because these are method calls to seperate objects there might be no change in latency or more latency maybe added.				WHY:		[ ] It would be possible to implement the cursors necessary for playing and editing, but it will add a lot to the code that's already complex. This makes adding other rulers (tempo) much difficult to maintain.				PSEUDOCODE:		Class GUIEditorObj				Events		MouseDown(X as integer, Y as integer) as boolean		MouseDrag(X as integer, Y as integer)		MouseMove(X as integer, Y as integer)		MouseUp(X as integer, Y as integer)		MouseWheel(X as integer, Y as integer, deltaX as integer, deltaY as integer)		Open				Methods		DrawEditor		DrawChordOutlines		DrawGroupOutlines		GetOutline(MusicObj) as GroupOutlineObj		DrawObject(MusicObj)		DrawObjects		MoveNote		ResizeTabHit		SetDrawYParameters		SetNoteValue		SetSongLength				Class KeyboardRulerObj				Events		MouseDown(X as integer, Y as integer) as boolean; For sample note playing		MouseUp(X as integer, Y as integer); for sample note stopping		MouseWheel(X as integer, Y as integer, deltaX as integer, deltaY as integer); for scrolling up and down		Open				Methods		DrawKeys		PrepNoteInKeyIndicators		SetDrawYParameters		SetNoteValue				Class MeasureRulerObj				Events		Open				Methods		DrawRuler				Class CursorRulerObj		Events		MouseDown(X as integer, Y as integer) as boolean		MouseDrag(X as integer, Y as integer)		MouseMove(X as integer, Y as integer)		MouseUp(X as integer, Y as integer)		Open				Methods		DrawRuler		DrawObjects		DrawObject(CursorObj)		MoveCursor			#tag EndNote	#tag Note, Name = Refactoring the drawing Minor (Cursors only)						Draw Ruler; Height is constant		Draw Cursors; Height is constant		Draw Editor; Width is constant, height is dynamic		Draw CornerPic; dimensions based on other				CursorObj		Position as integer (basically what beat it is on)				Class StartCursorObj inherits from CursorObj		Class StopCursorObj inherits from CursorObj		Class EditCursorObj inherits from CursorObj				Moving the StopCursorObj out moves total beats out.		Moving the StopCursorObj in moves the total beats in, but notes are deleted.			#tag EndNote	#tag Property, Flags = &h21		Private buffer As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private CornerPic As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private CursorAreaPic As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private DownX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private DownY As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private DragSelectMode As Boolean	#tag EndProperty	#tag Property, Flags = &h21		Private EditorPic As Picture	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set by ParentWindow.SetEditMode		#tag EndNote		EditStatus As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private EndX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private EndY As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private FullX1 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private FullX2 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private FullY1 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private FullY2 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private KeysPic As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private NoteClicked As NoteObj	#tag EndProperty	#tag Property, Flags = &h21		Private NoteInKey As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private NoteInKeyTonic As Picture	#tag EndProperty	#tag Property, Flags = &h21		Private NotePlayer As NotePlayer	#tag EndProperty	#tag Property, Flags = &h21		Private NotePlayerLastInstrumentPlayed As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private NotePlayerLastNotePlayed As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private NotePlayerLastVelocityPlayed As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private NoteValue As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private NoteValueRaw As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			Called by DrawRuler, DrawEditor, MouseDown		#tag EndNote		ParentWindow As WindowEditor	#tag EndProperty	#tag Property, Flags = &h21		Private ResizeMode As Boolean	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set by ParentWindow sliders		#tag EndNote		ResolutionX As Integer = 1	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set by ParentWindow sliders		#tag EndNote		ResolutionY As Integer = 16	#tag EndProperty	#tag Property, Flags = &h21		Private RulerPic As Picture	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set by ParentWindow scrollbars		#tag EndNote		ScrollDeltaX As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set by ParentWindow scrollbars		#tag EndNote		ScrollDeltaY As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is set in the ParentWindow.Open() event and by the ParentWindow.PM_SnapTo control			//The value is the note length.		#tag EndNote		SnapTo As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			//this is requested by ParentWindow.ResizeBars		#tag EndNote		SongLength As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private StartX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private StartY As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private StepX As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private StepY As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private X1 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private X2 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private Y1 As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private Y2 As Integer	#tag EndProperty	#tag Constant, Name = kEditStatus_Add, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kEditStatus_Default, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = kEditStatus_Delete, Type = Double, Dynamic = False, Default = \"-1", Scope = Public	#tag EndConstant	#tag Constant, Name = kEditStatus_Edit, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kKeyPicWidth, Type = Double, Dynamic = False, Default = \"64", Scope = Public	#tag EndConstant	#tag Constant, Name = kRulerPicHeight, Type = Double, Dynamic = False, Default = \"17", Scope = Public	#tag EndConstant	#tag Constant, Name = kTotalRulerHeight, Type = Double, Dynamic = False, Default = \"34", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="AcceptFocus"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AcceptTabs"			Visible=true			Group="Behavior"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="AutoDeactivate"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Backdrop"			Visible=true			Group="Appearance"			Type="Picture"			EditorType="Picture"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="DoubleBuffer"			Visible=true			Group="Behavior"			InitialValue="False"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="EditStatus"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Enabled"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="EraseBackground"			Visible=true			Group="Behavior"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Height"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="HelpTag"			Visible=true			Group="Appearance"			Type="String"			EditorType="MultiLineEditor"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="InitialParent"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockBottom"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockLeft"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockRight"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="LockTop"			Visible=true			Group="Position"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			Type="String"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="ResolutionX"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="ResolutionY"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="ScrollDeltaX"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="ScrollDeltaY"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="SnapTo"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="SongLength"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabIndex"			Visible=true			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabPanelIndex"			Group="Position"			InitialValue="0"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="TabStop"			Visible=true			Group="Position"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="UseFocusRing"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Visible"			Visible=true			Group="Appearance"			InitialValue="True"			Type="Boolean"			InheritedFrom="Canvas"		#tag EndViewProperty		#tag ViewProperty			Name="Width"			Visible=true			Group="Position"			InitialValue="100"			Type="Integer"			InheritedFrom="Canvas"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass