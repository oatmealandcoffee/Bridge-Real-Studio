#tag ClassProtected Class CommandMgrObj	#tag Method, Flags = &h21		Private Sub AddToRedoStack(mCommand as Command)		  #if kLogCommandMgrMethods		    WindowLog.Log("AddToRedoStack(Command)")		  #endif		  		  RedoStack.Append(mCommand)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub AddToUndoStack(mCommand as Command)		  #if kLogCommandMgrMethods		    WindowLog.Log("AddToUndoStack(Command)")		  #endif		  		  UndoStack.Append(mCommand)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CanRedo() As Boolean		  #if kLogCommandMgrMethods		    WindowLog.Log("CanRedo as Boolean")		  #endif		  		  if Ubound(RedoStack) <> -1 then 		    return true		  end if		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CanUndo() As Boolean		  #if kLogCommandMgrMethods		    WindowLog.Log("CanUndo as Boolean")		  #endif		  		  if Ubound(UndoStack) <> -1 then		    return true		  end if		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearCurrentCommand()		  #if kLogCommandMgrMethods		    WindowLog.Log("ClearCurrentCommand")		  #endif		  		  CurrentCommand = nil		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CurrentRedoName() As String		  #if kLogCommandMgrMethods		    WindowLog.Log("CurrentRedoName")		  #endif		  		  if CanRedo then		    return RedoStack(Ubound(RedoStack)).Name		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CurrentUndoName() As String		  #if kLogCommandMgrMethods		    WindowLog.Log("CurrentUndoName")		  #endif		  		  if CanUndo then		    return UndoStack(Ubound(UndoStack)).Name		  end if		  		  return ""		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub InvokeCommand(mCommand as Command)		  #if kLogCommandMgrMethods		    WindowLog.Log("InvokeCommand(Command)")		  #endif		  		  // InvokeCommand is an artifact from the original Command design pattern		  // example by William Yu.		  		  AddToUndoStack(mCommand)		  CurrentCommand = mCommand		  		  'mCommand.FirstExecute //this is really for when the command object holds the commands themselves.		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub InvokePostCommandActions()		  #if kLogCommandMgrMethods		    WindowLog.Log("InvokePostCommandActions")		  #endif		  		  If CurrentCommand = nil then return		  		  CurrentCommand.AddRedoRecordObjs		  		  ClearCurrentCommand		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Redo()		  #if kLogCommandMgrMethods		    WindowLog.Log("Redo")		  #endif		  		  dim mCommand as Command		  		  if UBound(RedoStack) <> -1 then		    // Grab the last Command from our stack (and remove it)		    mCommand = RedoStack.Pop		    		    // Do the Command		    mCommand.Redo		    		    // Add the Command to our undo stack now		    AddToUndoStack(mCommand)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveLastCommand()		  #if kLogCommandMgrMethods		    WindowLog.Log("RemoveLastCommand")		  #endif		  		  //called by GUIObj.MouseUp() when the mouse did NOT move to make an edit.		  		  dim mCommand as Command = UndoStack.Pop		  ClearCurrentCommand		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Undo()		  #if kLogCommandMgrMethods		    WindowLog.Log("Undo")		  #endif		  		  dim mCommand as Command		  		  if UBound(UndoStack) <> -1 then		    // Grab the last Command from our stack (and remove it)		    mCommand = UndoStack.Pop		    		    // Undo the Command		    mCommand.Undo		    		    // Add the Command to our redo stack now		    AddToRedoStack(mCommand)		  end if		End Sub	#tag EndMethod	#tag Note, Name = Action Addition Version History		0.7.6a: CommandMouseCreateNoteObj		0.7.7: Also, recorded how Command names are returned		0.7.8: CommandMouseDeleteNoteObj		[ ] CommandGroupRecordObj has a NilObjectException in Constructor on the line me.Group = Group.Group		   [ ]  Kludge put in place		[ ] A Group's objects are being lost when it gets transferred to the CommandMouseDeleteNoteObj		   [ ] ParentWindow.NoteMgr.DestryObject(MusicObj) will actually completely dismantle the group. I don't think this is necessary, actually.		      [ ] Lines commented out		0.7.9a: CommandMouseMoveMusicObj		[ ] BUG: Somehow, duplicate Undos are being added and created.		   [ ] Fixed in 0.7.10 by adding a conditional in GUIObj.MouseUp based on (X, Y) = (DownX, DownY)		   [ ] BUG HAS RETURNED IN 0.7.16		      [ ] But only sometimes		      [ ] Completing all Undos results de-selection being disabled.		      [ ] Calling SelectAll upon that condition causes an endless loop somewhere (I think in GetTopGroup)		0.7.10: CommandMouseResizeMusicObj		[ ] This is the template for 0.7.11-0.7.17		0.7.11: WindowEditNote.EditMgr.SetVelocity(Velocity_Set_Slider.Value)		[ ] BUG: Duplicate commands on resize		0.7.12: WindowEditNote.EditMgr.ModifyVelocity(Velocity_Mod_Slider.Value) [DONE]		0.7.13: WindowEditNote.EditMgr.SetLength(NewLength) [DONE]		0.7.14: WindowEditNote.EditMgr.ScaleLength(Length_Scale_Slider.Value) [DONE]		0.7.15: WindowEditNote.EditMgr.ScaleStartBeat(Length_Scale_Slider.Value) [DONE]		0.7.16: Lock/Unlock Notes [DONE]		0.7.17: Bug Fixes		[ ] 0.7.17a: Put in place ResetSelectionToObjectAffected to fix bug 811171254		0.7.18: Make Chord		0.7.18a: Foundation laid		[ ] BUG: Taking resulting selection after undo and making a chord does not appear properly (or behave it looks).		   [ ] SYMPTOM: We're not removing the chord from the root note and the other notes in the chord are still in NoteMgr.Notes(-1)		      [ ] SOLVED: The above symptom was the problem.		0.7.18b: Undo Note to Chord		0.7.18b1: Undo Chord to Chord		0.7.18b2: Undo Group\Note,Note,Note		[ ] BUG: Worked on Notes 1 & 3, but not 2.		   [ ] SYMPTOM: Objects are being changed in a different order than what they were added.		      [ ] RESOLVED: Changed the To to DownTo. But, I have a doubt this will be a long-term solution.		0.7.18b3: Undo Group\Chord,Chord,Chord		0.7.18b4: Undo Group\Note,Group\Note, Note/Note, Note		[ ] BUG: Nested group had a problem selecting chord, and then notes played don't match notes displayed.		   [ ] SYMPTOM: Nested Groups Sample seems to work okay, but there are deeper problems		   [ ] CLUE: ResetSelectionToObjectAffected in Super works with Selection and not RedoSelection. Override method might be the way around this.		   [ ] CLUE: Add three objects, group, make chords, Undo, keep selected, make chord, only roots are grouped but objects ARE NOT grouped		We have to make sure that selections are being managed. So, maybe in SwapOldChordWithNewChord, we go ahead and swap the chord after changing the notes.		Make sure when chenging the notes in the chord that we are leaving the chord and they we're using the correct notes.		One thing to try is rename everything with "Old" and "New" as opposed to "Undo" and "Redo" for easier context management.		   [ ] CLUE: The link from the Notes back to chords and groups isn't being restored, but the links from the chords and groups is.`		      [ ] FIXED: Added the two lines needed to generate. Two f-ing lines!		0.7.18b5: Undo Test Nested Sample		0.7.18b6: THE REDOS BEGIN. Ugh.		0.7.19: Remove Chord		0.7.20: Break Chord		0.7.21: Edit Chord		0.7.22: Group; we'll have to make sure that grouped objects are selected after the command.		0.7.23: Ungroup; we'll have to make sure ungrouped objects are all selected after the command							#tag EndNote	#tag Note, Name = How Commands Work		Commands provide a layer of abstraction between the user actions and the managers.				Since all commands point to a manager linked to a ParentWindow of some sort, this isn't hard				(Menu Command | Mouse Click | Keyboard Command) -> Invoke CommandObj -> CommandObj.Execute -> ManagerObj	#tag EndNote	#tag Note, Name = How Names are Returned		WindowEditor.EnableMenuItems()		   return CommandMgr.CurrentUndoName as string		      return UndoStack(Ubound(UndoStack)).Name as string		         return "[Command Name]" from Command Interface		      			#tag EndNote	#tag Note, Name = Undo-able Action List		'Menu		'    File		'        New		'            Track		'    Edit		'        Cut		'        Paste		'        Clear		'        Delete		'    Notes		'        Edit Notes		'            Velocity		'                Absolute		'                Relative		'            Length		'                Absolute		'                Relative		'        Make Chord		'        Remove Chord		'        Break Chord		'        Edit Chord		'        Group		'        Ungroup		'    Music		'        Change Key		'Window Actions		'    Tracks		'        Add		'        Delete		'        Duplicate		'        Change Track Color		'        Change Track Instrument		'        Chnage Track Name		'    Editor		'        Add Note		'        Edit Objects		'            Move Objects (MouseDown to MouseUp, not in MouseDrag)		'            Resize Objects (MouseDown to MouseUp, not in MouseDrag)		'        Delete Objects		'        Lock Objects		'        Unlock Objects				Special Considerations:		Moving Selections		Perhaps we would keep track of what was in the selection at the time, record the old StartBeat and Pitches, and re-apply them.					#tag EndNote	#tag Property, Flags = &h0		CurrentCommand As Command	#tag EndProperty	#tag Property, Flags = &h0		ParentWindow As WindowEditor	#tag EndProperty	#tag Property, Flags = &h21		Private RedoStack(-1) As Command	#tag EndProperty	#tag Property, Flags = &h21		Private UndoStack(-1) As Command	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass