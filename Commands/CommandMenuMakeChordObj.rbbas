#tag ClassProtected Class CommandMenuMakeChordObjInherits CommandObjImplements Command	#tag Method, Flags = &h0		Sub AddRedoRecordObjs()		  #if kLogMethods		    WindowLog.Log("CommandMusicObjectStateObj.AddRedoRecordObjs")		  #endif		  		  // Part of the Command interface.		  // Duplicated from CommandMusicObjectStateObj		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if ParentWindow.NoteMgr.Selection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = ParentWindow.NoteMgr.Selection(thisMusicObj)		      		      if theMusicObj IsA NoteObj then		        AddRedoRecordObj(NoteObj(theMusicObj))		        RedoSelection.Append(NoteObj(theMusicObj))		        		      elseif theMusicObj IsA ChordObj then		        AddRedoRecordObj(ChordObj(theMusicObj))		        RedoSelection.Append(ChordObj(theMusicObj))		        		      elseif theMusicObj IsA GroupObj then		        AddRedoRecordObj(GroupObj(theMusicObj))		        RedoSelection.Append(GroupObj(theMusicObj))		        		      end if		      		    end if		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor(mParentWindow as WindowEditor)		  // Part of the Command interface.		  // Duplicated from CommandMusicObjectStateObj		  		  // Calling the overridden superclass constructor		  Super.Constructor		  		  ParentWindow = mParentWindow		  		  if Ubound(mParentWindow.NoteMgr.Selection) <> -1 then		    AddUndoRecordObjs		  else		    #if DebugBuild		      WindowLog.Log("CommandMusicObjectStateObj.Constructor(): Ubound(mParentWindow.NoteMgr.Selection) = -1")		    #endif		  end if		  		  Label = Str(Microseconds)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetNewObjectRecord(Chord as ChordObj) As Pair		  dim thisPair as integer = 0		  dim firstPair as integer = 0		  dim lastPair as integer = Ubound(AlteredObjects)		  		  for thisPair = firstPair to lastPair		    if AlteredObjects(thisPair) <> nil then		      		      dim thePair as Pair = AlteredObjects(thisPair)		      dim theNewObject as MakeChordRecordObj = thePair.Right		      		      if theNewObject.AffectedObject IsA ChordObj then		        dim newChord as ChordObj = theNewObject.AffectedObject		        		        if newChord = Chord then 		          return thePair		        end if		        		      end if		    end if		  next		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetNewObjectRecord(Note as NoteObj) As Pair		  dim thisPair as integer = 0		  dim firstPair as integer = 0		  dim lastPair as integer = Ubound(AlteredObjects)		  		  for thisPair = firstPair to lastPair		    if AlteredObjects(thisPair) <> nil then		      		      dim thePair as Pair = AlteredObjects(thisPair)		      dim theNewObject as MakeChordRecordObj = thePair.Right		      		      if theNewObject.AffectedObject IsA NoteObj then		        dim newNote as NoteObj = theNewObject.AffectedObject		        		        if newNote = Note then		          return thePair		        end if		        		      end if		    end if		  next		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetOldObjectRecord(Chord as ChordObj) As Pair		  dim thisPair as integer = 0		  dim firstPair as integer = 0		  dim lastPair as integer = Ubound(AlteredObjects)		  		  for thisPair = firstPair to lastPair		    if AlteredObjects(thisPair) <> nil then		      		      dim thePair as Pair = AlteredObjects(thisPair)		      dim theNewObject as MakeChordRecordObj = thePair.Left		      		      if theNewObject.AffectedObject IsA ChordObj then		        dim newChord as ChordObj = theNewObject.AffectedObject		        		        if newChord = Chord then		          return thePair		        end if		        		      end if		    end if		  next		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetOldObjectRecord(Note as NoteObj) As Pair		  dim thisPair as integer = 0		  dim firstPair as integer = 0		  dim lastPair as integer = Ubound(AlteredObjects)		  		  for thisPair = firstPair to lastPair		    if AlteredObjects(thisPair) <> nil then		      		      dim thePair as Pair = AlteredObjects(thisPair)		      dim theNewObject as MakeChordRecordObj = thePair.Left		      		      if theNewObject.AffectedObject IsA NoteObj then		        dim newNote as NoteObj = theNewObject.AffectedObject		        		        if newNote = Note then		          return thePair		        end if		        		      end if		    end if		  next		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeChordRecord(Chord as ChordObj) As MakeChordRecordObj		  return new MakeChordRecordObj(Me, Chord)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function MakeChordRecord(Note as NoteObj) As MakeChordRecordObj		  return new MakeChordRecordObj(Me, Note)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub MakeUndoRecord(UndoChordRecord as MakeChordRecordObj, RedoChordRecord as MakeChordRecordObj)		  dim RecordPair as Pair = UndoChordRecord : RedoChordRecord		  AlteredObjects.Append(RecordPair)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function Name() As String		  // Part of the Command interface.		  		  #if DebugBuild		    return "CommandMenuMakeChordObj"		  #else		    return "Make Chord"		  #endif		  		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Redo()		  // Part of the Command interface.		  		  #if kLogMethods		    WindowLog.Log("CommandMenuMakeChordObj.Redo")		  #endif		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(Selection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if Selection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = Selection(thisMusicObj)		      		      if theMusicObj IsA NoteObj then		        Redo(NoteObj(theMusicObj))		        		      elseif theMusicObj IsA ChordObj then		        Redo(ChordObj(theMusicObj))		        		      elseif theMusicObj IsA GroupObj then		        Redo(GroupObj(theMusicObj))		        		      end if		      		    end if		  next		  		  ParentWindow.NoteMgr.SetSelectionNoteLists		  		  ResetSelectionToObjectAffected		  		  UpdateWindow		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Redo(Chord as ChordObj)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Redo(Group as GroupObj)		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        Redo(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        Redo(Chord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        Redo(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Redo(Note as NoteObj)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub RemoveChordNotes(Chord as CHordObj)		  dim thisNote as integer = 0		  dim firstNote as integer = 1 //we want to leave the root note alone.		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = lastNote DownTo firstNote		    if Chord.Notes(thisNote) <> nil then		      dim theNote as NoteObj = Chord.Notes(thisNote)		      Chord.Notes.Remove(thisNote)		      		      ParentWindow.NoteMgr.RemoveObjectFromArray(theNote)		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ReplaceNewChordWithOldChord(Chord as ChordObj, OldChordRecord as MakeChordRecordObj)		  RemoveChordNotes(Chord)		  		  dim thisOldNote as integer = 0		  dim firstOldNote as integer = 0		  dim lastOldNote as integer = Ubound(OldChordRecord.Notes)		  		  for thisOldNote = firstOldNote to lastOldNote		    if OldChordRecord.Notes(thisOldNote) <> nil then		      		      dim theOldNote as NoteObj = OldChordRecord.Notes(thisOldNote)		      		      if theOldNote <> Chord.Root then		        Chord.Notes.Append(theOldNote)		        theOldNote.Chord = Chord		        		        //manage the arrays		        ParentWindow.NoteMgr.Notes.Append(theOldNote)		        		      end if		      		    end if		  next		  		  Chord.Settings = OldChordRecord.Settings		  		  Chord.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ReplaceNewChordWithOldNote(Chord as ChordObj, NoteRecord as MakeChordRecordObj)		  // duplicated and edited from EditMgr.SwapNotesAndChord		  		  //get the objects needed for the swap		  dim Note as NoteObj = NoteRecord.AffectedObject		  		  //manage the arrays		  ParentWindow.NoteMgr.RemoveObjectFromArray(Chord)		  		  dim thisNote as integer = 1		  dim firstNote as integer = 1		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = lastNote DownTo firstNote		    if Chord.Notes(thisNote) <> nil then		      		      dim theNote as NoteObj = Chord.Notes(thisNote)		      ParentWindow.NoteMgr.RemoveObjectFromArray(theNote)		      		    end if		  next		  		  Note.Chord = nil		  		  dim Group as GroupObj = Chord.Group		  //manage the parent objects		  if Group <> nil then		    		    ParentWindow.NoteMgr.RemoveObjectFromGroup(Chord, Group)		    Group.Objects.Append(Note)		    Note.Group = Group		    		  else //we're in the track		    		    ParentWindow.NoteMgr.RemoveFromSelection(Chord)		    ParentWindow.NoteMgr.AddToSelection(Note)		    		    ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(Chord)		    ParentWindow.TrackListObj1.CurrentTrack.AddObject(Note)		    		  end if //Group <> nil		  		  Note.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ReplaceOldChordWithNewChord(Chord as ChordObj, NewChordRecord as MakeChordRecordObj)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ReplaceOldNoteWithNewChord(Note as NoteObj, OldNoteRecord as MakeChordRecordObj)		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ResetSelectionToObjectAffectedInRedo()		  #if kLogMethods		    WindowLog.Log("ResetSelectionToObjectAffected")		  #endif		  		  // Part of the Command interface.		  		  ParentWindow.NoteMgr.ClearSelection		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(RedoSelection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if RedoSelection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = RedoSelection(thisMusicObj)		      		      if theMusicObj IsA NoteObj then		        ParentWindow.NoteMgr.AddToSelection(NoteObj(theMusicObj))		        		      elseif theMusicObj IsA ChordObj then		        ParentWindow.NoteMgr.AddToSelection(ChordObj(theMusicObj))		        		      elseif theMusicObj IsA GroupObj then		        ParentWindow.NoteMgr.AddToSelection(GroupObj(theMusicObj))		        		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Undo()		  // Part of the Command interface.		  		  #if kLogMethods		    WindowLog.Log("CommandMenuMakeChordObj.Undo")		  #endif		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(RedoSelection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if RedoSelection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = RedoSelection(thisMusicObj)		      		      'if theMusicObj IsA NoteObj then		      'Undo(NoteObj(theMusicObj))		      'end if		      		      if theMusicObj IsA ChordObj then		        Undo(ChordObj(theMusicObj))		      end if		      		      if theMusicObj IsA GroupObj then		        Undo(GroupObj(theMusicObj))		      end if		      		    end if		  next		  		  ParentWindow.NoteMgr.SetSelectionNoteLists		  		  ResetSelectionToObjectAffected		  		  UpdateWindow		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Undo(Chord as ChordObj)		  dim theAffectedPair as Pair = GetNewObjectRecord(Chord)		  		  if theAffectedPair = nil then		    #if DebugBuild		      MsgBox "CommandMenuMakeChordObj.Undo: GetNewObjectRecord(Chord) = nil"		    #endif		    return		  end if		  		  dim OldObjectRecord as MakeChordRecordObj = theAffectedPair.Left		  		  if OldObjectRecord.AffectedObject IsA ChordObj then		    ReplaceNewChordWithOldChord(Chord, OldObjectRecord)		  end if		  		  if OldObjectRecord.AffectedObject IsA NoteObj then 		    ReplaceNewChordWithOldNote(Chord, OldObjectRecord)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Undo(Group as GroupObj)		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = lastObject DownTo firstObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        Undo(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        Undo(Chord)		      end if		      		      'if Group.Objects(thisObject) IsA NoteObj then		      'dim Note as NoteObj = Group.Objects(thisObject)		      'Undo(Note)		      'end if		      		    end if		  next		  		  Group.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Undo(Note as NoteObj)		  'dim theAffectedPair as Pair = GetNewObjectRecord(Note)		  '		  'if theAffectedPair = nil then		  '#if DebugBuild		  'MsgBox "CommandMenuMakeChordObj.Undo: GetNewObjectRecord(Note) = nil"		  '#endif		  'return		  'end if		  '		  'dim OldObjectRecord as MakeChordRecordObj = theAffectedPair.Left		  '		  'if OldObjectRecord.AffectedObject IsA ChordObj then		  'ReplaceNewChordWithOldChord(Chord, OldObjectRecord)		  'end if		  '		  'if OldObjectRecord.AffectedObject IsA NoteObj then		  'ReplaceNewChordWithOldNote(Note, OldObjectRecord)		  'end if		End Sub	#tag EndMethod	#tag Note, Name = Brainstorm		The actual implementation does not match this, and sucks, but this was really, really, really hard.				Menu.MakeChord		   WindowMakeChord.MakeChord // collects the settings		      EditMgr.MakeChord(Settings) // goes through the selection and changes all notes and chords; new chords are collected in EditMgr.Chords(-1), pre-existing chords are simply changed.		         EditMgr.MakeChord(Settings, MusicObj) // This is where the actual work is done.         		      EditMgr.SwapNotesAndChords  //and this is where all of the note and chord objects come together.				So, at two points, we need to collect		[ ] In EditMgr.MakeChord(integer, Chord)		   [ ] New chords created		   [ ] The notes new chords replaced		[ ] In EditMgr.MakeChord(integer, Note) (or EditMgr.SwapNotesAndChords)		   [ ] The chords that were altered		   [ ] The chords that were altered original settings.				Current methods in CommandObj don't allow for this nested addition of objects. It's supposed to go by the selection.		We can add methods to the Command interface, but that would muddy the paradigm for everything else.				One idea is to dig through the selection, get the objects that would be affected, and then in Swap notes and chords, get the chords added.		SO, make records before and after. An idea for matching new/altered chords to their original objects is to use Pairs. Left being the original		object and right being the new object. 				Problem is pre-existing chords are simply recalculated, so we would need the original settings (save as a chord) and the new settings that are recalculated on Redo.				We'll need to duplicate the EditMgr.SwapNotesAndChords code for Redo.		Undo will simply be the opposite of that on the surface.				We also need to handle cancel				Plan B--		We could go by selection by getting the notes and the chords for Undo.		For Redo, we would go through and if we come across a chord, then check the root to see if it matches.		If it matches, make a pair.		If it was a chord before, find the chord amongst the Redo records, and make a pair.				Either way, we're going to need some new methods that will muddy the waters. One idea to mitigate this is maybe create events for the CommandObj and put code in there.		The key here is to reuse code as much as possible and work around the pre-existing.				Plan to go with...		We can typecast the CurrentCommand property to this object, and run the methods that way.				So, we create pairs at MakeChord(integer, MusicObj)		 For Chords		Create a Record object that records the chord, contained notes, and settings		Precommand on the left				Undo and Redo just swap the objects. Undo = left and Redo = Right		For pre-existing chords, we will keep track of the notes and the settings for the pre- and post-action chords, and swap them out as necessary.				Grab the selection as usual so we know what objects are affected.	#tag EndNote	#tag Note, Name = How this works		Get the selection		Get the affected objects and their states		Swap as necessary				EditMgr.MakeChord(Integer) -> Constructor		   EditMgr.MakeChord(Integer, NoteObj)		      MakeChordRecord(Note)		      MakeUndoRecord(MakeChordRecordObj, MakeChordRecordObj)		   EditMgr.MakeChord(Integer, ChordObj) 		      MakeChordRecord(Chord)		      MakeUndoRecord(MakeChordRecordObj, MakeChordRecordObj)		CurrentCommand.AddRedoRecordObjs		   AddRedoRecordObj(ChordObj)		   AddRedoRecordObj(NoteObj)						Constructor		   AddUndoRecordObjs		      AddUndoRecordObj(MusicObj) // Standard placing everything in Selection				EditMgr.MakeChord(Integer) -> AddRedoRecordObjs		   AddRedoRecordObj(MusicObj) // New; Takes the updated selection and adds to RedoSelection				Undo		   Undo(ChordObj)		      ReplaceNewChordWithOldChord(Chord, MakeChordRecordObj)		         GetNewObjectRecord(Chord)		         RemoveChordNotes(Chord)		            // Chord notes are replaced here. There is no tracking of Group vs Track because the chord object doesn't get altered		         Chord.SetNoteList		      ReplaceNewChordWithOldNote(Chord, MakeChordRecordObj)		   Undo(NoteObj) // Doesn't happen on Undo		   Undo(GroupObj) // Go look for more chords.		   ResetSelectionToObjectAffected				MakeChordRecord(NoteObj | ChordObj) // Creates a record of the object's state		MakeUndoRecord(MakeChordRecordObj, MakeChordRecordObj) // Matches the old object with the new object		GetNewObjectRecord(Chord) // Gets the object states		RemoveChordNotes(Chord) // Gets the new chord "out"		Chord.SetNoteList // Reset the object	#tag EndNote	#tag Note, Name = Pseudocode Chord to Chord		Sud EditMgr.MakeChord(Integer, ChordObj)		   ' get pre-command chord information		   dim UndoChord as Chord				   // chord creation code				   ' get the post-command chord information		   dim RedoChord as Chord		   CommandMenuMakeChordObj(CommandMgr.CurrentCommand).RecordObjects(UndoChord, RedoChord)				End Sud				Sud CommandMenuMakeChord.RecordObjects(UndoChord as ChordObj, RedoChord as ChordObj)		   dim UndoChordRecord as MakeChordRecordObj = new MakeChordRecord(Me, UndoChord)		   dim RedoChordRecord as MakeChordRecordObj = new MakeChordRecord(Me, RedoChord)		   MakeUndoRecord(UndoChordRecord, RedoChordRecord)		End Sud				Sub MakeUndoRecord(UndoChordRecord as MakeChordRecord, RedoChordRecord as MakeChordRecord)		   dim RecordPair as Pair = UndoChordRecord : RedoChordRecord		   AlteredObjects.Append(RecordPair)		End Sub	#tag EndNote	#tag Note, Name = Pseudocode MakeChordRecordObj		Class MakeChordRecordObj				   Property Object as Variant		   Property Notes(-1) as NoteObj		   Property Settings as Integer				   Sub Constructor(mParentCommand as CommandMenuMakeChordObj, mChord as ChordObj)		      ParentCommand =  mParentCommand		      RecordChord(mChord)		   End Sub				   Sub RecordChord(mChord as ChordObj)		      Chord = mChord		      RecordNotes(Chord)		      Settings = Chord.Settings		   End Sub				   Sub RecordNotes(mChord)		      // Loops through and records all of the notes		   End Sub				End Class			#tag EndNote	#tag Note, Name = Pseudocode Note to Chord		Sud EditMgr.MakeChord(Integer, NoteObj)		   		   ' buffer the note		   dim UndoNote as NoteObj = Note				  // Chord Creation Code				  ' Buffer the new chord		  dim RedoChord as ChordObj = Chord		  CommandMenuMakeChordObj(CommandMgr.CurrentCommand).RecordObjects(UndoNote, RedoChord)				End Sud				Sud CommandMenuMakeChord.RecordObjects(UndoNote as NoteObj, RedoChord as ChordObj)		   dim UndoNoteRecord as MakeChordRecordObj = new MakeChordRecord(Me, UndoNote)		   dim RedoChordRecord as MakeChordRecordObj = new MakeChordRecord(Me, RedoChord)		   MakeUndoRecord(UndoNoteRecord, RedoChordRecord)		End Sud				Sud CommandMenuMakeChord.MakeUndoRecord(UndoNoteRecord as MakeChordRecord, RedoChordRecord as MakeChordRecord)		   dim RecordPair as Pair = UndoNoteRecord : RedoChordRecord		   AlteredObjects.Append(RecordPair)		End Sud	#tag EndNote	#tag Note, Name = Pseudocode Undo/Redo		Sud Undo // Going from New Chord back to old object (Right->Left)		   For each item in the selection		      If item is a Chord then		         Get the NewChordRecord in AlteredObjects.Right as MakeChordRecord		         Get the OldObjectRecord in AlteredObject.Left as MakeChordRecord				         if the OldObjectRecord.Object is a Chord then		            Remove the Notes		            Replace the notes with what is in the OldObjectRecord		            Replace the settings with what is in the OldObjectRecord		         end if				         if the OldObjectRecord.Object is a NoteObj		            Swap the chord in NewChordRecord with the Note in OldObjectRecord		         end if		      end if				      If Item is a Note then		         // error; do nothing		        end if		   Next		End Sud				Sud Redo // Going from the old object to the new chord (Left->Right)		   for each item in the selection		      if item is a chord		         Get the NewChordRecord in AlteredObjects.Right as MakeChordRecord		         Get the OldObjectRecord in AlteredObject.Left as MakeChordRecord				         if the OldObjectRecord is a Chord then		            Remove the Notes		            Replace the notes with what is in the NewChordRecord		            Replace the settings with what is in the NewChordRecord		         end if				         if the OldObjectRecord is a Note then		            Swap the note with the chord in NewChordRecord		         end if		      end if		   next		End Sud					#tag EndNote	#tag Property, Flags = &h1		Protected AlteredObjects(-1) As Pair	#tag EndProperty	#tag Property, Flags = &h1		Protected RedoSelection(-1) As Variant	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Description"			Group="Behavior"			Type="String"			InheritedFrom="CommandObj"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Label"			Group="Behavior"			Type="String"			InheritedFrom="CommandObj"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="MusicObjCount"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="CommandObj"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass