#tag ClassProtected Class CommandObj	#tag Method, Flags = &h1		Protected Sub AddRedoRecordObj(Chord as ChordObj)		  'Chords.Append(Chord)		  		  dim CommandChordRecord as CommandChordRecordObj = new CommandChordRecordObj(Chord)		  CommandRedoRecords.Append(CommandChordRecord)		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote To lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      AddRedoRecordObj(Note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddRedoRecordObj(mGroup as GroupObj)		  'Groups.Append(mGroup)		  		  dim CommandGroupRecord as CommandGroupRecordObj = new CommandGroupRecordObj(mGroup)		  CommandRedoRecords.Append(CommandGroupRecord)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(mGroup.Objects)		  		  for thisObject = firstObject to lastObject		    if mGroup.Objects(thisObject) <> nil then		      		      if mGroup.Objects(thisObject) IsA GroupObj then		        dim Group as GroupObj = mGroup.Objects(thisObject)		        AddRedoRecordObj(Group)		      end if		      		      if mGroup.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = mGroup.Objects(thisObject)		        AddRedoRecordObj(Chord)		      end if		      		      if mGroup.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = mGroup.Objects(thisObject)		        AddRedoRecordObj(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddRedoRecordObj(Note as NoteObj)		  'Notes.Append(Note)		  		  dim CommandNoteRecord as CommandNoteRecordObj = new CommandNoteRecordObj(Note)		  CommandRedoRecords.Append(CommandNoteRecord)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddUndoRecordObj(Chord as ChordObj)		  Chords.Append(Chord)		  		  dim CommandChordRecord as CommandChordRecordObj = new CommandChordRecordObj(Chord)		  CommandUndoRecords.Append(CommandChordRecord)		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote To lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      AddUndoRecordObj(Note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddUndoRecordObj(mGroup as GroupObj)		  Groups.Append(mGroup)		  		  dim CommandGroupRecord as CommandGroupRecordObj = new CommandGroupRecordObj(mGroup)		  CommandUndoRecords.Append(CommandGroupRecord)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(mGroup.Objects)		  		  for thisObject = firstObject to lastObject		    if mGroup.Objects(thisObject) <> nil then		      		      if mGroup.Objects(thisObject) IsA GroupObj then		        dim Group as GroupObj = mGroup.Objects(thisObject)		        AddUndoRecordObj(Group)		      end if		      		      if mGroup.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = mGroup.Objects(thisObject)		        AddUndoRecordObj(Chord)		      end if		      		      if mGroup.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = mGroup.Objects(thisObject)		        AddUndoRecordObj(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddUndoRecordObj(Note as NoteObj)		  Notes.Append(Note)		  		  dim CommandNoteRecord as CommandNoteRecordObj = new CommandNoteRecordObj(Note)		  CommandUndoRecords.Append(CommandNoteRecord)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddUndoRecordObjs()		  #if kLogMethods		    WindowLog.Log("AddUndoRecordObjs")		  #endif		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if ParentWindow.NoteMgr.Selection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = ParentWindow.NoteMgr.Selection(thisMusicObj)		      		      if theMusicObj IsA NoteObj then		        AddUndoRecordObj(NoteObj(theMusicObj))		        Selection.Append(NoteObj(theMusicObj))		        		      elseif theMusicObj IsA ChordObj then		        AddUndoRecordObj(ChordObj(theMusicObj))		        Selection.Append(ChordObj(theMusicObj))		        		      elseif theMusicObj IsA GroupObj then		        AddUndoRecordObj(GroupObj(theMusicObj))		        Selection.Append(GroupObj(theMusicObj))		        		      end if		      		    end if		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyRedoState(Chord as ChordObj)		  dim CommandChordRecord as CommandChordRecordObj = GetRedoRecordObj(Chord)		  		  if CommandChordRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandChordRecordObj: CommandChordRecord = nil")		    #endif		    		    return		  end if		  		  CommandChordRecord.ApplyState		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote To lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      ApplyRedoState(Note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyRedoState(Group as GroupObj)		  dim CommandGroupRecord as CommandGroupRecordObj = GetRedoRecordObj(Group)		  		  if CommandGroupRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandGroupRecordObj: CommandGroupRecord = nil")		    #endif		    		    return		  end if		  		  CommandGroupRecord.ApplyState		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        ApplyRedoState(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        ApplyRedoState(Chord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        ApplyRedoState(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyRedoState(Note as NoteObj)		  dim CommandNoteRecord as CommandNoteRecordObj = GetRedoRecordObj(Note)		  		  if CommandNoteRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandNoteRecordObj: CommandNoteRecord = nil")		    #endif		    		    return		  end if		  		  CommandNoteRecord.ApplyState		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyUndoState(Chord as ChordObj)		  dim CommandChordRecord as CommandChordRecordObj = GetUndoRecordObj(Chord)		  		  if CommandChordRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandChordRecordObj: CommandChordRecord = nil")		    #endif		    		    return		  end if		  		  CommandChordRecord.ApplyState		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote To lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      ApplyUndoState(Note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyUndoState(Group as GroupObj)		  dim CommandGroupRecord as CommandGroupRecordObj = GetUndoRecordObj(Group)		  		  if CommandGroupRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandGroupRecordObj: CommandGroupRecord = nil")		    #endif		    		    return		  end if		  		  CommandGroupRecord.ApplyState		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        ApplyUndoState(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        ApplyUndoState(Chord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        ApplyUndoState(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ApplyUndoState(Note as NoteObj)		  dim CommandNoteRecord as CommandNoteRecordObj = GetUndoRecordObj(Note)		  		  if CommandNoteRecord = nil then		    #if DebugBuild		      WindowLog.Log("CommandMouseMoveObj.ApplyRedoState:CommandNoteRecordObj: CommandNoteRecord = nil")		    #endif		    		    return		  end if		  		  CommandNoteRecord.ApplyState		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  MusicObjCount = ObjectCount		  Description = Str(MusicObjCount)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetRedoRecordObj(Chord as ChordObj) As CommandChordRecordObj		  dim thisCommandChordRecord as integer = 0		  dim firstCommandChordRecord as integer = 0		  dim lastCommandChordRecord as integer = Ubound(CommandRedoRecords)		  		  for thisCommandChordRecord = firstCommandChordRecord to lastCommandChordRecord		    if CommandRedoRecords(thisCommandChordRecord) <> nil then		      if CommandRecordObj(CommandRedoRecords(thisCommandChordRecord)).RecordedObject = Chord then		        		        dim theCommandChordRecord as CommandChordRecordObj = CommandRedoRecords(thisCommandChordRecord)		        		        'if theCommandChordRecord.Chord = Chord then		        return theCommandChordRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetRedoRecordObj(Group as GroupObj) As CommandGroupRecordObj		  dim thisCommandGroupRecord as integer = 0		  dim firstCommandGroupRecord as integer = 0		  dim lastCommandGroupRecord as integer = Ubound(CommandRedoRecords)		  		  for thisCommandGroupRecord = firstCommandGroupRecord to lastCommandGroupRecord		    if CommandRedoRecords(thisCommandGroupRecord) <> nil then		      if CommandRecordObj(CommandRedoRecords(thisCommandGroupRecord)).RecordedObject = Group then		        		        dim theCommandGroupRecord as CommandGroupRecordObj = CommandRedoRecords(thisCommandGroupRecord)		        		        'if theCommandGroupRecord.Group = Group then		        return theCommandGroupRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetRedoRecordObj(Note as NoteObj) As CommandNoteRecordObj		  dim thisCommandNoteRecord as integer = 0		  dim firstCommandNoteRecord as integer = 0		  dim lastCommandNoteRecord as integer = Ubound(CommandRedoRecords)		  		  for thisCommandNoteRecord = firstCommandNoteRecord to lastCommandNoteRecord		    if CommandRedoRecords(thisCommandNoteRecord) <> nil then		      if CommandRecordObj(CommandRedoRecords(thisCommandNoteRecord)).RecordedObject = Note then		        		        dim theCommandNoteRecord as CommandNoteRecordObj = CommandRedoRecords(thisCommandNoteRecord)		        		        'if theCommandNoteRecord.Note = Note then		        return theCommandNoteRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetUndoRecordObj(Chord as ChordObj) As CommandChordRecordObj		  dim thisCommandChordRecord as integer = 0		  dim firstCommandChordRecord as integer = 0		  dim lastCommandChordRecord as integer = Ubound(CommandUndoRecords)		  		  for thisCommandChordRecord = firstCommandChordRecord to lastCommandChordRecord		    if CommandUndoRecords(thisCommandChordRecord) <> nil then		      if CommandRecordObj(CommandUndoRecords(thisCommandChordRecord)).RecordedObject = Chord then		        		        dim theCommandChordRecord as CommandChordRecordObj = CommandUndoRecords(thisCommandChordRecord)		        		        'if theCommandChordRecord.Chord = Chord then		        return theCommandChordRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetUndoRecordObj(Group as GroupObj) As CommandGroupRecordObj		  dim thisCommandGroupRecord as integer = 0		  dim firstCommandGroupRecord as integer = 0		  dim lastCommandGroupRecord as integer = Ubound(CommandUndoRecords)		  		  for thisCommandGroupRecord = firstCommandGroupRecord to lastCommandGroupRecord		    if CommandUndoRecords(thisCommandGroupRecord) <> nil then		      if CommandRecordObj(CommandUndoRecords(thisCommandGroupRecord)).RecordedObject = Group then		        		        dim theCommandGroupRecord as CommandGroupRecordObj = CommandUndoRecords(thisCommandGroupRecord)		        		        'if theCommandGroupRecord.Group = Group then		        return theCommandGroupRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetUndoRecordObj(Note as NoteObj) As CommandNoteRecordObj		  dim thisCommandNoteRecord as integer = 0		  dim firstCommandNoteRecord as integer = 0		  dim lastCommandNoteRecord as integer = Ubound(CommandUndoRecords)		  		  for thisCommandNoteRecord = firstCommandNoteRecord to lastCommandNoteRecord		    if CommandUndoRecords(thisCommandNoteRecord) <> nil then		      if CommandRecordObj(CommandUndoRecords(thisCommandNoteRecord)).RecordedObject = Note then		        		        dim theCommandNoteRecord as CommandNoteRecordObj = CommandUndoRecords(thisCommandNoteRecord)		        		        'if theCommandNoteRecord.Note = Note then		        return theCommandNoteRecord		        'end if		        		      end if		    end if		  next		  		  return nil		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub ResetSelectionToObjectAffected()		  #if kLogMethods		    WindowLog.Log("ResetSelectionToObjectAffected")		  #endif		  		  // Part of the Command interface.		  		  ParentWindow.NoteMgr.ClearSelection		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(Selection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if Selection(thisMusicObj) <> nil then		      dim theMusicObj as MusicObj = Selection(thisMusicObj)		      		      if theMusicObj IsA NoteObj then		        ParentWindow.NoteMgr.AddToSelection(NoteObj(theMusicObj))		        		      elseif theMusicObj IsA ChordObj then		        ParentWindow.NoteMgr.AddToSelection(ChordObj(theMusicObj))		        		      elseif theMusicObj IsA GroupObj then		        ParentWindow.NoteMgr.AddToSelection(GroupObj(theMusicObj))		        		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub UpdateWindow()		  #if kLogMethodsVerbose		    Log("UpdateWindow")		  #endif		  		  ParentWindow.ResizeBars		  		  ParentWindow.WindowNeedsSaving = true		  		End Sub	#tag EndMethod	#tag Note, Name = Command Specific Notes		When an object is deleted, it's not just a note.		A note can be part of a larger object, like a chord...		...or a group, which can be nested. 				The Command can come from two different directions				GUIObj.MouseDown() -> ParentWindow.NoteMgr.DestroyNote(Note) -> DestroyObject(MusicObj)		* Selection not required, just the passed Note to find the parent object				WindowEditor.EditClear -> EditMgr.Delete -> EditMgr -> DestroyObjects		* Selection Required				We need two commands	#tag EndNote	#tag Note, Name = CommandRecord Hierarchy		CommandRecordUndoMusicObj contains all of the PRE command states. This gets applied in Undo		CommandRecordRedoMusicObj contains all POST command states. This gets applied in Redo.				Interface CommandRecord		Sub Constructor(mMusicObj as Variant)		//Here is where the object is handed off to the CommandRecordObj for applying the appropriate properties.		//the properties are the state of the object BEFORE the command. So, these are applied on Unexecute		End Sub				Sub CreateUndoRecord(mMusicObj as Variant		//This gets called after the command is executed via ParentWindow.CommandMgr.InvokeInvokeCommand(Command)		End Sub		End Interface				Class CommandRedoRecordObj MusicObj				End Class				Class CommandRecordNoteObj CommandRecordObj Interface CommandRecord		Public Note as NoteObj		[Duplicate NoteObj Specific Properties]		End Class				Class CommandRecordChordObj CommandRecordObj Interface CommandRecord		Public Chord as ChordObj		[Duplicate ChordObj Specific Properties]		End Class				Class CommandRecordGroupObj CommandRecordObj Interface CommandRecord		Public Group as GroupObj		[Duplicate GroupObj Specific Properties]		End Class				Class CommandUndoRecordObj CommandRecordObj Interface CommandRecord				End Class			#tag EndNote	#tag Note, Name = How These Work		CommandObjs have to keep in context if the command		* requires a selection		* requires a passed object (instead of a selection)		* is transitory (parameters have to be selected)		* is a single click				At their base, they are only concerned with the state of objects.		They need to record relevant properties before and after the command.				Commands are applied at the object level, so the CommandObj needs to keep 		track of everything the same way.				For example, when adding a group, the created GroupObj is set the ObjectAdded		property, and all of the objects that were added to the group, are placed in the 		Notes, Chords, and Groups.				CommandObjs should not take code out of the rest of the architecture. They		should only be passed objects when necessary or grab what it needs and 		be concerned about those objects' state				CommandObjs should not duplicate anything. They should only hold reference to		pre-existing objects.				The following methods are for capturing and applying the state of all of the properties of nested MusicObjs:		AddUndoRecordObj(MusicObj), AddRedoRecordObj(MusicObj), ApplyUndoState(MusicObj), ApplyRedoState(MusicObj)		The name ApplyUndo and ApplyRedo was changed to specify state because sometimes we'll need to 		ApplyUndo and ApplyRedo but not be concerned about the entire state, like in object creation and destruction	#tag EndNote	#tag Note, Name = Sequence of Events		Note Creation		Construction		   Create CommandNoteCreateObj(ParentWindow, NoteObj)		      ObjectAdded = NoteObj		      Create CommandNoteCreateRecordObj(NoteObj)		         Apply NoteObj properties to CommandNoteCreateObj properties		      Add CommandNoteCreateObj to CommandUndoRecords 		      Add CommandNoteCreateObj to CommandRedoRecords 		Undo		   Find NoteObj(ObjectAdded) in ParentWindow.NoteMgr.Notes		   Remove from array		   Find NoteObj(ObjectAdded) in ParentWindow.TrackListObj1.CurrentTrack		   Remove from Array		   UpdateWindow				Redo		   Append NoteObj(ObjectAdded) to ParentWindow.NoteMgr.Notes		   UpdateWindow				Group Creation		Construction		   Create CommandCreateGroupObj(ParentWindow, GroupObj)		   ObjectAdded = GroupObj		   Add Objects in ParentWindow.NoteMgr.Selection to each of the Notes, Chords, and Groups arrays				Undo		   Find GroupOBj(ObjectAdded) in ParentWindow.NoteMgr.Groups		   Remove from Array		   Find each object in Notes, Chords, Groups and set MusicObj.Group to nil		   		Redo		   Append GroupObj(ObjectAdded) to ParentWindow.NoteMgr.Groups		   Set MusicObj.Group property for all objects in Notes, Chords, and Groups to GroupObj(ObjectAdded)				Object Editing (transitory)		Construction		   Create CommandResizeMusicObj(ParentWindow, GroupObj)		   For each object in selection		      Add Object in ParentWindow.NoteMgr.Selection to Notes, Chords, and Groups arrays		      Create CommandRecordObj		      Save State		      Add to CommandUndoRecords				At end of command		   For each object in selection		      Create CommandRedoRecords		      Save State		      Add to CommandRedoRecords				Undo		   For Each object in CommandUndoRecords		      Apply State				Redo		   For each object in CommandRedoRecords		      Apply State	#tag EndNote	#tag Note, Name = Things to Remember		Be sure both the NoteMgr arrays and the CurrentTrack.Music array is managed			#tag EndNote	#tag Property, Flags = &h1		Protected Chords(-1) As ChordObj	#tag EndProperty	#tag Property, Flags = &h1		Protected CommandRedoRecords(-1) As Variant	#tag EndProperty	#tag Property, Flags = &h1		Protected CommandUndoRecords(-1) As Variant	#tag EndProperty	#tag Property, Flags = &h0		Description As String	#tag EndProperty	#tag Property, Flags = &h1		Protected Groups(-1) As GroupObj	#tag EndProperty	#tag Property, Flags = &h0		Label As String	#tag EndProperty	#tag Property, Flags = &h0		MusicObjCount As Integer	#tag EndProperty	#tag Property, Flags = &h1		Protected Notes(-1) As NoteObj	#tag EndProperty	#tag Property, Flags = &h1		Protected ObjectAdded As Variant	#tag EndProperty	#tag Property, Flags = &h1		Protected ObjectRemoved As Variant	#tag EndProperty	#tag Property, Flags = &h0		ParentWindow As WindowEditor	#tag EndProperty	#tag Property, Flags = &h1		Protected Selection(-1) As Variant	#tag EndProperty	#tag Property, Flags = &h1		Protected Track As TrackObj	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Description"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Label"			Group="Behavior"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="MusicObjCount"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass