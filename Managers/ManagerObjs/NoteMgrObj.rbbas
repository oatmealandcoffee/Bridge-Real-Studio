#tag ClassProtected Class NoteMgrObjInherits ManagerObj	#tag Method, Flags = &h0		Sub AddObjectToArray(Chord as ChordObj)		  //called by EditMgr.Paste		  //called by AddObjectToArray(Group)		  //called by TrackListObj.DuplicateTrack		  		  Chords.Append Chord		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(Chord.Notes)		  		  for thisObject = firstObject to lastObject		    if Chord.Notes(thisObject) <> nil then		      		      dim Note as NoteObj = Chord.Notes(thisObject)		      AddObjectToArray(Note)		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddObjectToArray(Group as GroupObj)		  //called by EditMgr.Paste		  //called by AddObjectToArray(Group)		  //called by TrackListObj.DuplicateTrack		  		  Groups.Append Group		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        AddObjectToArray(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        AddObjectToArray(Chord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        AddObjectToArray(Note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddObjectToArray(Note as NoteObj)		  //called by EditMgr.Paste		  //called by AddObjectToArray(Group)		  //called by AddObjectToArray(Chord)		  //called by TrackListObj.DuplicateTrack		  		  Notes.Append Note		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddSelectionFromNote(Note as NoteObj)		  #if kLogMethods		    Log("AddSelectionFromNote(NoteObj)")		  #endif		  		  //called by GUIObj.MouseDrag and NoteMgr.EditNote		  		  If IsNoteSelected(Note) = true then return		  'If Note.Selected then return		  		  Note.SetOldData		  		  If Note.Group = Nil then		    if Note.Chord = Nil then		      AddToSelection(Note)		    Else		      If note.Chord.Group = nil then		        AddToSelection(Note.Chord)		      Else		        dim TopGroup as GroupObj = GetTopGroup(Note.Chord.Group)		        AddToSelection(TopGroup)		      End If		    End If		  Else		    dim TopGroup as GroupObj = GetTopGroup(Note.Group)		    AddToSelection(TopGroup)		  End if		  		  SetSelectionNoteLists		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddToSelection(Chord as ChordObj)		  #if kLogMethods		    Log("NoteMgrObj.AddToSelection(ChordObj)")		  #endif		  		  //called by AddSelectionFromNote		  		  if chord = nil then return //this may bite us later		  		  Chord.SelectObj		  Selection.Append Chord		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddToSelection(Group as GroupObj)		  #if kLogMethods		    Log("NoteMgrObj.AddToSelection(GroupObj)")		  #endif		  		  //called by AddSelectionFromNote		  		  if Group = nil then return //this may bite us later		  		  Group.SelectObj		  Selection.Append Group		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub AddToSelection(Note as NoteObj)		  #if kLogMethods		    Log("NoteMgrObj.AddToSelection(NoteObj)")		  #endif		  		  //called by AddSelectionFromNote		  		  if Note = nil then return //this may bite us later		  		  Note.SelectObj		  Selection.Append Note		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ClearSelection()		  #if kLogMethods		    Log("NoteMgrObj.ClearSelection")		  #endif		  		  // called from SelectAll, SelectNone, MakeGroup, CommandMusicObjectStateObj.Undo		  		  dim thisMusicObj as integer = 0		  dim firstMusicObj as integer = 0		  dim lastMusicObj as integer = Ubound(Selection)		  		  for thisMusicObj = firstMusicObj to lastMusicObj		    if Selection(thisMusicObj) <> nil then		      		      if Selection(thisMusicObj) IsA GroupObj then		        dim Group as GroupObj = Selection(thisMusicObj)		        Group.DeselectObj		      end if		      		      if Selection(thisMusicObj) IsA ChordObj then		        dim Chord as ChordObj = Selection(thisMusicObj)		        Chord.DeselectObj		      end if		      		      if Selection(thisMusicObj) IsA NoteObj then		        dim Note as NoteObj = Selection(thisMusicObj)		        Note.DeselectObj		      end if		      		    end if		  next		  		  		  Redim Selection(-1)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CloneObject(Chord as ChordObj) As ChordObj		  dim NewChord as ChordObj = new ChordObj		  		  'NewChord.ApplyRootSettingsToChord = Chord.ApplyRootSettingsToChord //Method		  'NewChord.DeselectObj = Chord.DeselectObj //Method		  'NewChord.Group = Chord.Group //OBJECT		  NewChord.Hidden = Chord.Hidden		  'NewChord.ID = Chord.ID //For file saving only		  NewChord.Label = Chord.Label		  NewChord.Length = Chord.Length //does not apply, but we'll stillapply anyway		  NewChord.Locked = Chord.Locked		  NewChord.Name = Chord.Name		  		  //NewChord.Notes = Chord.Notes		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  for thisNote = firstNote To lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      dim NewNote as NoteObj = CloneObject(Note)		      NewNote.Chord = NewChord		      NewChord.Notes.Append NewNote		    end if		  next		  		  'NewChord.OldLength = Chord.OldLength //for mouse actions		  'NewChord.OldStartBeat = Chord.OldStartBeat //for mouse actions		  'NewChord.RemoveNote = Chord.RemoveNote //method		  		  //NewChord.Root = Chord.Root		  If NewChord.Notes(0) <> nil then		    NewChord.Root = NewChord.Notes(0)		  End If		  		  NewChord.Selected = Chord.Selected		  'NewChord.SelectObj = Chord.SelectObj //Method		  NewChord.Settings = Chord.Settings		  NewChord.StartBeat = Chord.StartBeat //does not apply, but we'll still apply anyway		  'NewChord.Track = Chord.Track //OBJECT		  NewChord.Type = Chord.Type		  NewChord.Velocity = Chord.Velocity //does not apply, but we'll still apply anyway		  		  return NewChord		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CloneObject(Group as GroupObj) As GroupObj		  dim NewGroup as GroupObj = new GroupObj		  		  'NewGroup.Constructor = Group.Constructor //does not apply		  'NewGroup.DeselectObj = Group.DeselectObj //Method		  'NewGroup.GetBounds = Group.GetBounds //Method		  'NewGroup.Group = Group.Group //OBJECT		  NewGroup.Hidden = Group.Hidden		  'NewGroup.ID = Group.ID //FileMgrObj		  NewGroup.Label = Group.Label		  'NewGroup.Length = Group.Length //does not apply		  NewGroup.Locked = Group.Locked		  NewGroup.Name = Group.Name		  		  //NewGroup.Objects = Group.Objects		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        dim NewNestedGroup as GroupObj = CloneObject(mGroup)		        NewNestedGroup.Group = NewGroup		        NewGroup.Objects.Append NewNestedGroup		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim mChord as ChordObj = Group.Objects(thisObject)		        dim NewChord as ChordObj = CloneObject(mChord)		        NewChord.Group = NewGroup		        NewGroup.Objects.Append NewChord		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim mNote as NoteObj = Group.Objects(thisObject)		        dim NewNote as NoteObj = CloneObject(mNote)		        NewNote.Group = NewGroup		        NewGroup.Objects.Append NewNote		      end if		    end if		  next		  		  'NewGroup.OldLength = Group.OldLength //Mouse Actions		  'NewGroup.OldStartBeat = Group.OldStartBeat //Mouse Actions		  'NewGroup.RemoveObject = Group.RemoveObject //Method		  NewGroup.Selected = Group.Selected		  'NewGroup.SelectObj = Group.SelectObj //Method		  'NewGroup.StartBeat = Group.StartBeat //does not apply		  'NewGroup.Track = Group.Track //OBJECT		  'NewGroup.UnGroupObj = Group.UnGroupObj //object		  'NewGroup.Velocity = Group.Velocity //does not apply		  		  return NewGroup		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CloneObject(Note as NoteObj) As NoteObj		  dim NewNote as NoteObj = new NoteObj		  		  'NewNote.Chord = note.Chord //OBJECT		  'NewNote.DeselectObj = note.DeselectObj //Method		  'NewNote.Group = note.Group //OBJECT		  NewNote.Hidden = note.Hidden		  'NewNote.ID = note.ID //For File saving and opening only		  NewNote.Label = note.Label		  NewNote.Length = note.Length		  NewNote.Locked = note.Locked		  NewNote.Name = note.Name		  'NewNote.NextNote = note.NextNote //OBJECT		  'NewNote.OldLength = note.OldLength //managed in Mouse actions		  'NewNote.OldPitch = note.OldPitch //managed in Mouse actions		  'NewNote.OldStartBeat = note.OldStartBeat //managed in Mouse actions		  NewNote.Pitch = note.Pitch		  'NewNote.PreviousNote = note.PreviousNote //OBJECT		  NewNote.Selected = note.Selected		  'NewNote.SelectObj = note.SelectObj //Method		  NewNote.StartBeat = note.StartBeat		  'NewNote.Track = note.Track //OBJECT		  NewNote.Velocity = note.Velocity		  		  return NewNote		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function CreateNote(Beat as integer, Pitch as integer, Length as integer) As NoteObj		  //called by ChordObj.CalculatePitches		  //called by ChordObj.AddNote		  //called by GUIObj.MouseDown(); 		  //NOTE: Track assignments are handled by the calling method		  		  dim Note as NoteObj = New NoteObj		  		  Note.StartBeat = Beat		  Note.Pitch = Pitch		  		  if Length = -1 then		    Note.Length = NewNoteLength		  else		    Note.Length = Length		  end if		  		  Note.DeselectObj		  Note.Velocity = MIDILib.kMIDIVelocityMax \ 2		  		  //this is here to fix a problem with new chords not dragging correctly when going straight from creation to drag		  Note.OldLength = Note.Length		  Note.OldPitch = Note.Pitch		  Note.OldStartBeat = Note.StartBeat		  		  //create the metadata		  Note.Label = str(Pitch) + "." + str(Beat)		  		  Notes.Append Note		  		  Notes(Ubound(Notes)).Track = ParentWindow.TrackListObj1.CurrentTrack		  		  Note.SetNoteList		  		  'ParentWindow.PlayMgr.SetStopCursorToEnd //this ought to be a preference		  		  return Note		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub DestroyNote(Note as NoteOBj)		  //called by GUIObj.MouseDown() on press delete key		  //called by GUIObj.EditClear		  //called by TrackListObj.DeleteTrack		  		  If Note.Group = Nil then		    if Note.Chord = Nil then		      DestroyObject(Note)		    Else		      If note.Chord.Group = nil then		        DestroyObject(note.Chord)		      Else		        dim TopGroup as GroupObj = GetTopGroup(Note.Chord.Group)		        DestroyObject(TopGroup)		      End If		    End If		  Else		    dim TopGroup as GroupObj = GetTopGroup(Note.Group)		    DestroyObject(TopGroup)		  End if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DestroyObject(Chord as ChordObj)		  #if kLogMethods		    Log("NoteMgr.DestroyObject(ChordObj)")		  #endif		  		  //remove from selection		  Chord.DeselectObj		  dim thisObject as Integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Selection)		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      if Selection(thisObject) IsA ChordObj then		        if Selection(thisObject) = Chord then		          Selection.Remove(thisObject)		        end if		      end if		    end if		  next		  		  //remove from the track		  if Chord.Track <> nil then		    Chord.Track.RemoveObject(Chord)		  end if		  		  //Remove the notes		  thisObject = 0		  firstObject = 0		  lastObject = UBound(Chord.Notes)		  for thisObject = lastObject DownTo firstObject		    if Chord.Notes(thisObject) <> nil then		      dim Note as NoteObj = Chord.Notes(thisObject)		      'Chord.Notes.Remove(thisObject) //commented out to allow CommandMouseDeleteNoteObj to work properly.		      DestroyObject(Note)		    end if		  next		  		  //remove from Chords array		  thisObject = 0		  firstObject = 0		  lastObject = Ubound(Chords)		  for thisObject = lastObject DownTo firstObject		    if Chords(thisObject) <> nil then		      if Chords(thisObject) = Chord then		        Chords.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DestroyObject(Group as GroupObj)		  #if kLogMethods		    Log("NoteMgr.DestroyObject(GroupObj)")		  #endif		  		  //remove from selection		  Group.DeselectObj		  dim thisObject as Integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Selection)		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      if Selection(thisObject) IsA GroupObj then		        if Selection(thisObject) = Group then		          Selection.Remove(thisObject)		        end if		      end if		    end if		  next		  		  //remove from the track		  if Group.Track <> nil then		    Group.Track.RemoveObject(Group)		  end if		  		  //remove the objects		  thisObject = 0		  firstObject = 0		  lastObject = Ubound(Group.Objects)		  for thisObject = lastObject DownTo firstObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        'Group.Objects.Remove(thisObject) //commented out to allow CommandMouseDeleteNoteObj to work properly.		        DestroyObject(mGroup)		        		      elseif Group.Objects(thisObject) IsA ChordObj then		        dim mChord as ChordObj = Group.Objects(thisObject)		        'Group.Objects.Remove(thisObject) //commented out to allow CommandMouseDeleteNoteObj to work properly.		        DestroyObject(mChord)		        		      elseif Group.Objects(thisObject) IsA NoteObj then		        dim mNote as NoteObj = Group.Objects(thisObject)		        'Group.Objects.Remove(thisObject) //commented out to allow CommandMouseDeleteNoteObj to work properly.		        DestroyObject(mNote)		        		      end if		      		    end if		  next		  		  //remove from Groups array		  thisObject = 0		  firstObject = 0		  lastObject = Ubound(Groups)		  for thisObject = lastObject DownTo firstObject		    if Groups(thisObject) <> nil then		      if Groups(thisObject) = Group then		        Groups.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DestroyObject(Note as NoteObj)		  #if kLogMethods		    Log("NoteMgr.DestroyObject(NoteObj)")		  #endif		  		  //remove from selection		  Note.DeselectObj		  dim thisObject as Integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Selection)		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      if Selection(thisObject) IsA NoteObj then		        if Selection(thisObject) = Note then		          Selection.Remove(thisObject)		        end if		      end if		    end if		  next		  		  //remove from the track		  if Note.Track <> nil then		    Note.Track.RemoveObject(Note)		  end if		  		  //remove from Notes array		  thisObject = 0		  firstObject = 0		  lastObject = Ubound(Notes)		  for thisObject = lastObject DownTo firstObject		    if Notes(thisObject) <> nil then		      if Notes(thisObject) = Note then		        Notes.Remove(thisObject)		      end if		    end if		  next		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub EditNote(Note as NoteObj)		  //Called from GUIObj.MouseDown		  //Manages Shift-Clicks		  		  if Keyboard.ShiftKey = true then //we're selecting more than one object.		    if Note.Selected = true then //if a selected object was selected, deselect it.		      RemoveSelection(Note)		    else //add unselected object to the SelectionNote		      AddSelectionFromNote(Note)		    end if		  else //we're selecting only one object		    if note.Selected = false then		      SelectNone		      AddSelectionFromNote(Note)		    end if		  end if		  		  //this loop ensures all notes in the selection stay in formation while dragging		  //I've tried placing this in all sorts of places, but this method is where it works and logically should be.		  //Just leave it at the end		  //DO NOT TOUCH! 		  		  dim thisNote as Integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Notes)		  		  for thisNote = firstNote to lastNote		    if Notes(thisNote) <> Nil then		      dim mNote as NoteObj = Notes(thisNote)		      if mNote.Selected then		        mNote.SetOldData		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetNote(Beat as integer, Pitch as integer) As NoteObj		  //called from GUIObj.MouseDown()		  		  FoundNote = nil		  		  dim thisTrack as integer = 0		  dim firstTrack as integer = 0		  dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		  		  for thisTrack = firstTrack to lastTrack		    dim track as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0)		    if track <> nil then		      if track.Visible then		        		        dim thisMusicObject as integer = 0		        dim firstMusicObject as integer = 0		        dim lastMusicObject as integer = Ubound(track.Music)		        		        for thisMusicObject = firstMusicObject to lastMusicObject		          if track.Music(thisMusicObject) <> nil then		            		            if track.Music(thisMusicObject) IsA GroupObj then		              dim mGroup as GroupObj = track.Music(thisMusicObject)		              GetNoteInObject(mGroup, Beat, Pitch)		            end if		            		            if track.Music(thisMusicObject) IsA ChordObj then		              dim mChord as ChordObj = track.Music(thisMusicObject)		              GetNoteInObject(mChord, Beat, Pitch)		            end if		            		            if track.Music(thisMusicObject) IsA NoteObj then		              dim Note as NoteObj = track.Music(thisMusicObject)		              GetNoteInObject(Note, Beat, Pitch)		            end if		            		          end if		        next		        		      end if		    end if		  next		  		  return foundNote		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub GetNoteInObject(Chord as ChordObj, Beat as integer, Pitch as integer)		  dim thisNote as Integer = 0		  dim firstNote as Integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.Notes(thisNote) <> nil then		      dim Note as NoteObj = Chord.Notes(thisNote)		      GetNoteInObject(Note, Beat, Pitch)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub GetNoteInObject(Group as GroupObj, Beat as integer, Pitch as integer)		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        GetNoteInObject(mGroup, Beat, Pitch)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Group.Objects(thisObject)		        GetNoteInObject(Chord, Beat, Pitch)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim Note as NoteObj = Group.Objects(thisObject)		        GetNoteInObject(Note, Beat, Pitch)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub GetNoteInObject(Note as NoteObj, Beat as integer, Pitch as integer)		  if IsNoteWithinBounds(Note, Beat, Pitch) = true then 		    foundNote = Note		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetObject(Chord as ChordObj) As ChordObj		  dim foundObject as ChordObj		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Chords)		  		  for thisObject = firstObject to lastObject		    if Chords(thisObject) <> nil then		      if Chords(thisObject) = Chord then		        foundObject = Chords(thisObject)		      end if		    end if		  next		  		  return foundObject		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetObject(Group as GroupObj) As GroupObj		  dim foundObject as GroupObj		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Groups)		  		  for thisObject = firstObject to lastObject		    if Groups(thisObject) <> nil then		      if Groups(thisObject) = Group then		        foundObject = Groups(thisObject)		      end if		    end if		  next		  		  return foundObject		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetObject(Note as NoteObj) As NoteObj		  dim foundObject as NoteObj		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Notes)		  		  for thisObject = firstObject to lastObject		    if Notes(thisObject) <> nil then		      if Notes(thisObject) = Note then		        foundObject = Notes(thisObject)		      end if		    end if		  next		  		  return foundObject		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetTopGroup(Group as GroupObj) As GroupObj		  #if kLogMethods		    Log("GetTopGroup(GroupObj)")		  #endif		  		  Dim ThisGroup as GroupObj = Group		  Dim TopGroup as GroupObj		  		  do		    		    TopGroup = ThisGroup		    		    if TopGroup <> nil then		      		      ThisGroup = TopGroup.Group		      		      if TopGroup = ThisGroup then //this should get us out of an endless loop generated in Undos.		        ThisGroup = nil		      end if		      		    end if		  loop until ThisGroup = nil		  		  return TopGroup		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetTopObject(Note as NoteObj) As MusicObj		  //called by CommandMouseDeleteNoteObj		  		  If Note.Group = Nil then		    if Note.Chord = Nil then		      Return Note		    Else		      If note.Chord.Group = nil then		        Return note.Chord		      Else		        dim TopGroup as GroupObj = GetTopGroup(Note.Chord.Group)		        Return TopGroup		      End If		    End If		  Else		    dim TopGroup as GroupObj = GetTopGroup(Note.Group)		    Return TopGroup		  End if		  		  Return Note		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetTotalBeats() As Integer		  #if kLogMethods		    'Log("NoteMgrObj.GetTotalBeats")		  #endif		  		  //called by GUIObj.SetSongLength to help determine length of song in pixels		  		  'TimeSignatureBeatsPerMeasure = 4		  'TimeSignatureBasicBeat = MIDILib.kNoteLength_04 //48		  dim defaultBeats as integer = 4 * 48 * 4 //4 measures.		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Notes)		  		  if lastNote > -1 then		    dim maxBeats as integer = 0		    		    for thisNote = firstNote to lastNote		      if Notes(thisNote) <> nil then		        dim theNote as NoteObj = Notes(thisNote)		        MaxBeats = Max(MaxBeats, theNote.StartBeat + theNote.Length)		      end if		    next		    		    #If kLogProcesses		      'Log("TotalBeats: " + Str(MaxBeats))		    #endif		    		    return MaxBeats		  End if		  		  '#If kLogProcesses		  'Log("defaultBeats: " + Str(defaultBeats))		  '#endif		  		  return defaultBeats		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function IsNoteSelected(Note As NoteObj) As Boolean		  //Deprecated. Was called by AddSelectionFromNote(Note).		  		  dim NoteSelected as Boolean = false		  		  If Note.Group = Nil then		    if Note.Chord = Nil then		      if Note.Selected = true then 		        NoteSelected = true		      end if		    Else		      If note.Chord.Group = nil then		        if Note.Chord.Selected = true then		          Note.Selected = true		        end if		      Else		        if Note.Chord.Group.Selected = true then		          NoteSelected = true		        end if		      End If		    End If		  Else		    if Note.Group.Selected = true then		      NoteSelected = true		    End if		  End If		  		  return NoteSelected		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function IsNoteWithinBounds(Note as NoteObj, Beat as integer, Pitch as integer) As Boolean		  //called by GetNote		  		  if Note.StartBeat <= Beat and Note.StartBeat + Note.Length >= Beat and Note.Pitch = Pitch then		    return true		  end if		  		  return false		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Log(theText as string)		  WindowLog.Log(theText)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveFromSelection(Chord as ChordObj)		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(Selection)		  		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      if Selection(thisObject) = Chord then		        Chord.DeselectObj		        Selection.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveFromSelection(Group as GroupObj)		  dim TopGroup as GroupObj = GetTopGroup(Group)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(Selection)		  		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      if Selection(thisObject) = TopGroup then		        TopGroup.DeselectObj		        Selection.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveFromSelection(Note as NoteObj)		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Selection)		  		  for thisNote = lastNote DownTo firstNote		    if Selection(thisNote) <> nil then		      if Selection(thisNote) = Note then		        Note.DeselectObj		        Selection.Remove(thisNote)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveObjectFromArray(Chord as ChordObj)		  //remove from the chords array		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Chords)		  		  for thisObject = lastObject DownTo firstObject		    if Chords(thisObject) <> nil then		      if Chords(thisObject) = Chord then		        Chords.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveObjectFromArray(Group as GroupObj)		  //remove from the groups array		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(groups)		  		  for thisObject = lastObject DownTo firstObject		    if groups(thisObject) <> nil then		      if groups(thisObject) = group then		        groups.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveObjectFromArray(Note as NoteObj)		  //remove from the notes array		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(notes)		  		  for thisObject = lastObject DownTo firstObject		    if notes(thisObject) <> nil then		      if notes(thisObject) = note then		        notes.Remove(thisObject)		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveObjectFromGroup(Chord as ChordObj, Group as GroupObj)		  dim thisChord as integer = 0		  dim firstChord as integer = 0		  dim lastChord as integer = Ubound(Group.Objects)		  		  for thisChord = lastChord DownTo firstChord		    if Group.Objects(thisChord) <> nil then		      		      if Group.Objects(thisChord) IsA ChordObj then		        dim theChord as ChordObj = Group.Objects(thisChord)		        if theChord = Chord then		          theChord.Group = nil		          Group.Objects.Remove(thisChord)		        end if		      end if		      		    end if		  next		  		  Group.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveObjectFromGroup(Note as NoteObj, Group as GroupObj)		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Group.Objects)		  		  for thisNote = lastNote DownTo firstNote		    if Group.Objects(thisNote) <> nil then		      		      if Group.Objects(thisNote) IsA NoteObj then		        dim theNote as NoteObj = Group.Objects(thisNote)		        if theNote = Note then		          Group.Objects.Remove(thisNote)		          note.Group = nil		        end if		      end if		      		    end if		  next		  		  Group.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveSelection(Note as NoteObj)		  if Ubound(Selection) = -1 then return		  		  If Note.Group = Nil then		    if Note.Chord = Nil then		      RemoveFromSelection(Note)		    Else		      If note.Chord.Group = nil then		        RemoveFromSelection(Note.Chord)		      Else		        dim TopGroup as GroupObj = GetTopGroup(note.Chord.Group)		        RemoveFromSelection(TopGroup)		      End If		    End If		  Else		    dim TopGroup as GroupObj = GetTopGroup(note.Group)		    RemoveFromSelection(TopGroup)		  End if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ResetSelectionToObject(Chord as ChordObj)		  //add selection here		  ParentWindow.NoteMgr.SelectNone		  ParentWindow.NoteMgr.AddToSelection(Chord)		  		  SetSelectionNoteLists		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ResetSelectionToObject(Group as GroupObj)		  //add selection here		  ParentWindow.NoteMgr.SelectNone		  ParentWindow.NoteMgr.AddToSelection(Group)		  		  SetSelectionNoteLists		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ResetSelectionToObject(Note as NoteObj)		  //add selection here		  ParentWindow.NoteMgr.SelectNone		  ParentWindow.NoteMgr.AddSelectionFromNote(Note)		  		  'SetSelectionNoteLists // This is redundant here, handled in last command		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SelectAll()		  #if kLogMethods		    Log("NoteMgrObj.SelectAll")		  #endif		  		  //called by WindowEditor.Menu.SelectAll		  		  SelectNone		  		  dim Track as TrackObj = ParentWindow.TrackListObj1.CurrentTrack		  		  dim thisObject as Integer = 0		  dim firstObject as Integer = 0		  dim lastObject as integer = Ubound(Track.Music)		  		  for thisObject = firstObject To lastObject		    if Track.Music(thisObject) <> nil then		      		      If Track.Music(thisObject) IsA GroupObj then		        dim Group as GroupObj = Track.Music(thisObject)		        dim TopGroup as GroupObj = GetTopGroup(Group)		        AddToSelection(TopGroup)		      End If		      		      If Track.Music(thisObject) IsA ChordObj then		        dim Chord as ChordObj = Track.Music(thisObject)		        AddToSelection(Chord)		      End If		      		      If Track.Music(thisObject) IsA NoteObj then		        dim Note as NoteObj = Track.Music(thisObject)		        AddToSelection(Note)		      End If		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SelectNone()		  #if kLogMethods		    Log("NoteMgrObj.SelectNone")		  #endif		  		  //called from GUIObj.MouseDown() when no note was clicked.		  //called by SelectAll		  //This just adds a small layer of abstraction for future commands.		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(Selection)		  		  for thisObject = lastObject DownTo firstObject		    if Selection(thisObject) <> nil then		      		      if Selection(thisObject) IsA GroupObj then		        dim group as GroupObj = Selection(thisObject)		        group.DeselectObj		        		      elseif Selection(thisObject) IsA ChordObj then		        dim chord as ChordObj = Selection(thisObject)		        chord.DeselectObj		        		      elseif Selection(thisObject) IsA NoteObj then		        dim Note as NoteObj = Selection(thisObject)		        Note.DeselectObj		        		      end if		      		    end if		  next		  		  ClearSelection		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetSelectionNoteLists()		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(ParentWindow.NoteMgr.Selection)		  		  if lastObject = -1 then return		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      dim theObject as NoteListInterface = ParentWindow.NoteMgr.Selection(thisObject)		      theObject.SetNoteList		    end if		  next		End Sub	#tag EndMethod	#tag Note, Name = How Notes Are Managed		Notes are THE atomic unit. All paths lead to note				App -> Window -> TrackList -> Track -> Music -> Note		                                             -> Chord -> Note		    -> NoteMgr -> Notes -> Note		               -> Chords -> Chord -> Note		               -> Groups -> Note		                        -> Chord -> Note		                        -> Group -> [Recursive]				When notes are created, they are all placed into Notes, even those that are being		included in chords. The main reason is for easier sorting when playing the music.				Chords are stored in their own master list as entirely separate objects that		reference notes				Groups are stored in their own master list and point to notes and chords (which then point to notes).	#tag EndNote	#tag Note, Name = How to Handle Selections		GUIObj.MouseDown -> NoteMgr.EditNote(Note)				The debate is whether to handle all selections as their core objects here		or to deal with them in the GUIObj.MouseDrag.				We are concerned about the NoteObj specifically when		   Drawing (the code already digs into objects to get the notes)		   Moving (This code uses the SelectionNote property here)		   Resizing 		   Cut/Copy/Paste				The question comes in when chords are changed such that when is it time to rebuild the chord.		If we move the chord, then the notes pitches change and they may not change "proportionally" so 		we then need to do a check (and rebuild if necessary). But if we're changing the track (cut/copy/paste), then		only the metadata really needs to be changed.				I guess the rule of thumb is that the NModule in question shouldn't need to notify the NoteMgr. The NoteMgr holds the selection		and it's up the module that calls the selection to do with it whatever it needs. The core of the NoteMgr was to handle only the core 		functions of creation, desctruction, and selection. I think that's the answer. So, here should only be one selection array as		variant, the MouseDrag should create it's own sequence to move notes and do a chord check (or have the chord check itself), and the		cut/copy/paste need to manage their own digging (actually all modules would need to manage their own digging.				if note.Chord = nil then handle normally		if note.Chord <> nil then add all notes in the chord	#tag EndNote	#tag Note, Name = Known Bugs		All new bug reports need to go to MusicSketchBugs.003				[FIXED] Deleted notes aren't being moved from Notes(i) to NotesTrash(i) when deleted from Track		   [ ] Tracks now delete only every other note.		Changed the loop that deletes the notes to go from 0-N to N-0	#tag EndNote	#tag Property, Flags = &h0		Chords(-1) As ChordObj	#tag EndProperty	#tag Property, Flags = &h21		Private FoundNote As NoteObj	#tag EndProperty	#tag Property, Flags = &h0		Groups(-1) As GroupObj	#tag EndProperty	#tag Property, Flags = &h21		Private mObjectcount As Integer	#tag EndProperty	#tag Property, Flags = &h0		#tag Note			I don't think this here, because this is a directly user-set property.		#tag EndNote		NewNoteLength As Integer	#tag EndProperty	#tag Property, Flags = &h0		Notes(-1) As NoteObj	#tag EndProperty	#tag Property, Flags = &h0		Selection(-1) As Variant	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="NewNoteLength"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass