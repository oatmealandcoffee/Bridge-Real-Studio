#tag ClassProtected Class EditMgrObjInherits ManagerObj	#tag Method, Flags = &h0		Sub BreakChord()		   //this removes the chord from the root note (it leaves the root note)		  		  redim Chords(-1)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisObject)		        BreakChord(mGroup)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim mChord as ChordObj = ParentWindow.NoteMgr.Selection(thisObject)		        BreakChord(mChord)		      end if		      		    end if		  next		  		  BreakChordDestroyChords		  		  ParentWindow.WindowNeedsSaving = true		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub BreakChord(Chord as ChordObj)		  dim thisChordNote as integer = 0		  dim firstChordNote as integer = 0		  dim lastChordNote as integer = Ubound(Chord.Notes)		  		  //break the notes out of the chord to the group or track		  for thisChordNote = firstChordNote to lastChordNote		    if Chord.Notes(thisChordNote) <> nil then 		      		      dim chordNote as NoteObj = Chord.Notes(thisChordNote)		      dim Group as GroupObj = Chord.Group		      chordNote.Chord = nil		      		      if Group <> nil then		        chordNote.Group = Group		        		        Group.Objects.Append chordNote		        		      else //we're in a track		        ParentWindow.TrackListObj1.CurrentTrack.AddObject(chordNote)		        		      end if		      		    end if		  next		  		  Chords.Append Chord //save for removal later		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub BreakChord(Group as GroupObj)		  //keep digging into nested groups		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        BreakChord(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim mChord as ChordObj = Group.Objects(thisObject)		        BreakChord(mChord)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub BreakChordDestroyChords()		  //this removes chords selected by the user to break the chord. So, we want to keep the notes, but 		  //destroy the chord. So, we don't use the DestroyObject methods because that is a deep destruction.		  		  dim thisChord as integer = 0		  dim firstChord as integer = 0		  dim lastChord as integer = Ubound(Chords)		  		  if lastChord > -1 then		    for thisChord = lastChord DownTo firstChord		      if Chords(thisChord) <> nil then		        		        dim theChord as ChordObj = Chords(thisChord)		        		        if theChord.Group <> nil then		          //remove from the chord's group		          dim Group as GroupObj = theChord.Group		          ParentWindow.NoteMgr.RemoveObjectFromGroup(theChord, Group)		          		        else //we're in a track		          ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(theChord)		          		        end if		        		        ParentWindow.NoteMgr.RemoveObjectFromArray(theChord)		        		      end if		    next		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ChangeKey(Settings as integer)		  dim Key as KeyObj		  Key = ParentWindow.SongMgr.Keys(0)		  		  Key.Settings = Settings		  		  if DataLib.GetFlag(DataLib.kFlagKeyType_C, Settings) then Key.Tonic = 0		  if DataLib.GetFlag(DataLib.kFlagKeyType_CsharpDflat, Settings) then Key.Tonic = 1		  if DataLib.GetFlag(DataLib.kFlagKeyType_D, Settings) then Key.Tonic = 2		  if DataLib.GetFlag(DataLib.kFlagKeyType_DsharpEflat, Settings) then Key.Tonic = 3		  if DataLib.GetFlag(DataLib.kFlagKeyType_E, Settings) then Key.Tonic = 4		  if DataLib.GetFlag(DataLib.kFlagKeyType_F, Settings) then Key.Tonic = 5		  if DataLib.GetFlag(DataLib.kFlagKeyType_FsharpGflat, Settings) then Key.Tonic = 6		  if DataLib.GetFlag(DataLib.kFlagKeyType_G, Settings) then Key.Tonic = 7		  if DataLib.GetFlag(DataLib.kFlagKeyType_GsharpAFlat, Settings) then Key.Tonic = 8		  if DataLib.GetFlag(DataLib.kFlagKeyType_A, Settings) then Key.Tonic = 9		  if DataLib.GetFlag(DataLib.kFlagKeyType_AsharpBflat, Settings) then Key.Tonic = 10		  if DataLib.GetFlag(DataLib.kFlagKeyType_B, Settings) then Key.Tonic = 11		  		  if DataLib.GetFlag(DataLib.kFlagKeyMod_Major, Settings) then Key.Key = MusicLib.kKeyMajor		  if DataLib.GetFlag(DataLib.kFlagKeyMod_Minor, Settings) then Key.Key = MusicLib.kKeyMinor		  if DataLib.GetFlag(DataLib.kFlagKeyMod_MinorHarmonic, Settings) then Key.Key = MusicLib.kKeyMinorHarmonic		  if DataLib.GetFlag(DataLib.kFlagKeyMod_MinorMelodic, Settings) then Key.Key = MusicLib.kKeyMinorMelodic		  		  if DataLib.GetFlag(DataLib.kFlagKeyMod_PentatonicMajor, Settings) then Key.Key = MusicLib.kKeyModPentatonicMajor		  if DataLib.GetFlag(DataLib.kFlagKeyMod_PentatonicMinor, Settings) then Key.Key = MusicLib.kKeyModPentatonicMinor		  		  Key.CalculatePitches		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function CheckStartBeat(StartBeat as integer) As Integer		  if StartBeat = 0 then return 0		  		  dim startBeatBuffer as integer		  		  startBeatBuffer = StartBeat		  		  if startBeatBuffer < MIDILib.kNoteLength_64 then startBeatBuffer = MIDILib.kNoteLength_64		  		  return startBeatBuffer		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Copy()		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  redim CopyMgr.CopyClipboard(-1) //clear the clipboard		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisObject)		        dim NewGroup as GroupObj = ParentWindow.NoteMgr.CloneObject(mGroup)		        CopyMgr.CopyClipboard.Append NewGroup		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim mChord as ChordObj = ParentWindow.NoteMgr.Selection(thisObject)		        dim NewChord as ChordObj = ParentWindow.NoteMgr.CloneObject(mChord)		        CopyMgr.CopyClipboard.Append NewChord		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim mNote as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        dim NewNote as NoteObj = ParentWindow.NoteMgr.CloneObject(mNote)		        CopyMgr.CopyClipboard.Append NewNote		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Cut()		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  Copy		  		  DestroyObjects		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Delete()		  #if kLogMethods		    Log("EditMgr.Delete")		  #endif		  		  //Delete is the exact same code as Cut except without the Copy command.		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  DestroyObjects		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DestroyObjects()		  #if kLogMethods		    Log("EditMgr.DestroyObjects")		  #endif		  		  //called by Cut and Delete. Both are the same except Cut calls Copy before destroying anything.		  //Adding an Undo to this would be fairly strainghtforward. 		  //Just append the objects to be destroyed to the command's objects array, and re-append to the NoteMgr and Track.Music arrays		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  dim track as TrackObj = ParentWindow.TrackListObj1.CurrentTrack		  		  //remove the items from the track		  dim thisTrackObject as integer = 0		  dim firstTrackObject as integer = 0		  dim lastTrackObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisTrackObject = firstTrackObject To lastTrackObject		    if ParentWindow.NoteMgr.Selection(thisTrackObject) <> nil then		      dim thisTrackTrackObject as integer = 0		      dim firstTrackTrackObject as integer = 0		      dim lastTrackTrackObject as integer = Ubound(track.Music)		      		      for thisTrackTrackObject = lastTrackTrackObject DownTo firstTrackTrackObject		        if track.Music(thisTrackTrackObject) <> nil then		          if ParentWindow.NoteMgr.Selection(thisTrackObject) = track.Music(thisTrackTrackObject) then		            track.Music.Remove(thisTrackTrackObject)		          end if		        end if		      next		      		    end if		  next		  		  //remove the items in the clipboard from Notes/Chords/Groups (and thus selection)		  dim thisSelectionObject as integer = 0		  dim firstSelectionObject as integer = 0		  dim lastSelectionObject as integer = Ubound(ParentWindow.NoteMgr.Selection) //an OutOfBoundsException. Ubound(Selection was 15) and this was lastSelectionObject was 22 and thisSelectionObject was 21		  		  for thisSelectionObject = lastSelectionObject DownTo firstSelectionObject		    if ParentWindow.NoteMgr.Selection(thisSelectionObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisSelectionObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisSelectionObject)		        ParentWindow.NoteMgr.DestroyObject(mGroup)		        		        'dim FoundGroup as GroupObj = ParentWindow.NoteMgr.GetSelectionObject(mGroup)		        'if FoundGroup <> nil then		        'ParentWindow.NoteMgr.DestroySelectionObject(FoundGroup)		        'end if		        		      elseif ParentWindow.NoteMgr.Selection(thisSelectionObject) IsA ChordObj then		        dim mChord as ChordObj = ParentWindow.NoteMgr.Selection(thisSelectionObject)		        ParentWindow.NoteMgr.DestroyObject(mChord)		        		        'dim FoundChord as ChordObj = ParentWindow.NoteMgr.GetSelectionObject(mChord)		        'if FoundChord <> nil then		        'ParentWindow.NoteMgr.DestroySelectionObject(FoundChord)		        'end if		        		      elseif ParentWindow.NoteMgr.Selection(thisSelectionObject) IsA NoteObj then		        dim mNote as NoteObj = ParentWindow.NoteMgr.Selection(thisSelectionObject)		        ParentWindow.NoteMgr.DestroyObject(mNote)		        		        'dim FoundNote as NoteObj = ParentWindow.NoteMgr.GetSelectionObject(mNote)		        'if FoundNote <> nil then		        'ParentWindow.NoteMgr.DestroySelectionObject(FoundNote)		        'end if		        		      end if		      		    end if		  next		  		  //we don't need to go one by one through the selection on Cut because everything selected gets removed		  //besides when we try to go one by one, Ubound is -1 at this point and we get an OutOfBoundsException		  //But, really, either one of these things works. We'll stick with the method to ensure we only need to		  //change code in one place.		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub LockUnlock()		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  dim CommandButtonLockToggle as CommandButtonLockToggleObj = new CommandButtonLockToggleObj(ParentWindow)		  ParentWindow.CommandMgr.InvokeCommand(CommandButtonLockToggle)		  		  dim noteSelection(-1) as NoteObj		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      dim theObject as MusicObj = ParentWindow.NoteMgr.Selection(thisObject)		      		      dim thisNote as integer = 0		      dim firstNote as integer = 0		      dim lastNote as integer = Ubound(theObject.NoteList)		      		      for thisNote = firstNote to lastNote		        if theObject.NoteList(thisNote) <> nil then		          dim theNote as NoteObj = theObject.NoteList(thisNote)		          noteSelection.Append(theNote)		        end if		      next		      		    end if		  next		  		  dim thisSelectedNote as integer = 0		  dim firstSelectedNote as integer = 0		  dim lastSelectedNote as integer = UBound(noteSelection)		  		  if lastSelectedNote = -1 then return		  		  dim firstValue as Boolean = noteSelection(0).Locked		  		  for thisSelectedNote = firstSelectedNote to lastSelectedNote		    if noteSelection(thisSelectedNote) <> nil then		      dim theSelectedNote as NoteObj = noteSelection(thisSelectedNote)		      		      if theSelectedNote.Locked <> firstValue then		        theSelectedNote.Locked = firstValue		      end if 		      		      if theSelectedNote.Locked = false then		        theSelectedNote.Locked = true		      else		        theSelectedNote.Locked = false		      end if		      		    end if		  next		  		  ParentWindow.CommandMgr.InvokePostCommandActions		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Log(theText as string)		  WindowLog.Log(theText)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MakeAlterChord()		  WindowMakeChord.ParentWindow = me.ParentWindow		  WindowMakeChord.Show		  		  //this gets the last chord selected and gets the settings as a starting point for editing this and other selections		  dim thisChord as integer = 0		  dim firstChord as integer = 0		  dim lastChord as integer = Ubound(ParentWindow.NoteMgr.Chords)		  		  for thisChord = firstChord to lastChord		    if ParentWindow.NoteMgr.Chords(thisChord) <> nil then		      dim theChord as ChordObj = ParentWindow.NoteMgr.Chords(thisChord)		      if theChord.Selected = true then		        WindowMakeChord.GetChord(theChord)		      end if		    end if		  next		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MakeChord(Settings as integer)		  redim Chords(-1)		  		  dim CommandMenuMakeChord as CommandMenuMakeChordObj = new CommandMenuMakeChordObj(ParentWindow)		  ParentWindow.CommandMgr.InvokeCommand(CommandMenuMakeChord)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisObject)		        MakeChord(settings, mGroup)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim mChord as ChordObj = ParentWindow.NoteMgr.Selection(thisObject)		        MakeChord(settings, mChord)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim mNote as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        MakeChord(Settings, mNote)		      end if		      		    end if		  next		  		  SwapNotesAndChords		  		  ParentWindow.NoteMgr.SetSelectionNoteLists		  		  ParentWindow.CommandMgr.InvokePostCommandActions		  		  RefreshParentWindow		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub MakeChord(settings as integer, Chord as ChordObj)		  //From MakeChord when the method came across a chord that was already in the group		  		  //but don't dig into the notes of the chord and make those into chords as well.		  		  //capture chord for undo		  dim OldChordRecord as MakeChordRecordObj = CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeChordRecord(Chord)		  		  Chord.Settings = Settings		  dim ChordMade as Boolean = Chord.CalculatePitches		  		  //capture chord for redo and record the action		  dim NewChordRecord as MakeChordRecordObj = CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeChordRecord(Chord)		  CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeUndoRecord(OldChordRecord, NewChordRecord)		  		  Chord.DeselectObj //SelectObj returns if the object is selected, so we toggle it here to ensure it gets selected		  Chord.SelectObj		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub MakeChord(settings as integer, Group as GroupObj)		  //dig further for other notes and chords.		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        MakeChord(settings, mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim mChord as ChordObj = Group.Objects(thisObject)		        MakeChord(settings, mChord)		      end if		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim mNote as NoteObj = Group.Objects(thisObject)		        MakeChord(Settings, mNote)		      end if		      		    end if		  next		  		  Group.SetNoteList		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub MakeChord(settings as integer, Note as NoteObj)		  if Note.chord <> nil then return //you know, just in case		  		  //capture note for undo		  dim OldNoteRecord as MakeChordRecordObj = CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeChordRecord(Note)		  		  dim Chord as ChordObj = new ChordObj		  		  Chord.ApplyRootSettingsToChord(Note)		  Chord.Settings = Settings		  		  dim ChordMade as boolean = Chord.CalculatePitches		  		  if ChordMade then		    		    if note.Group <> nil then		      		      dim Group as GroupObj = Note.Group		      Chord.Group = Group		    end if		    		    ParentWindow.NoteMgr.Chords.Append Chord		    Chords.Append Chord //save for SwapNotesAndChords		    		    //capture chord for redo and record the action		    dim NewChordRecord as MakeChordRecordObj = CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeChordRecord(Chord)		    CommandMenuMakeChordObj(ParentWindow.CommandMgr.CurrentCommand).MakeUndoRecord(OldNoteRecord, NewChordRecord)		    		  end if		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub MakeGroup()		  //Objects are linked to the groups they are directly tied to.		  //If a note is in a group but not in a chord, then it is linked to the group.		  //If a note is in a chord and the chord is in a group, then the note is linked to the chord, but not the group.		  		  dim NewGroup as GroupObj = new GroupObj		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = UBound(ParentWindow.NoteMgr.Selection)		  		  if lastObject = 0 then return //disallow grouping of one object to itself		  //the problem is that something about grouping and degrouping objects causes		  //group nested more than one deep to not get degrouped		  		  //go through each object in the selection, deselect it, and add to the group		  for thisObject = firstObject To lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisObject)		        mGroup.DeselectObj		        mGroup.Group = NewGroup		        ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(mGroup)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as ChordObj = ParentWindow.NoteMgr.Selection(thisObject)		        chord.DeselectObj		        chord.Group = NewGroup		        ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(chord)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        note.DeselectObj		        note.Group = NewGroup		        ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(note)		      end if		      		      NewGroup.Objects.Append ParentWindow.NoteMgr.Selection(thisObject)		      		    end if		  next		  		  NewGroup.Track = ParentWindow.TrackListObj1.CurrentTrack		  ParentWindow.TrackListObj1.CurrentTrack.AddObject(NewGroup)		  ParentWindow.NoteMgr.Groups.Append NewGroup		  NewGroup.SelectObj		  		  NewGroup.SetNoteList		  		  //clear the selection, and append the group		  ParentWindow.NoteMgr.ClearSelection		  ParentWindow.NoteMgr.Selection.Append NewGroup		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ModifyVelocity(Chord as ChordObj, ChangeVelocity as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ModifyVelocity(ChordObj, " + Str(ChangeVelocity) + ")")		  #endif		  		  chord.Velocity = checkVelocity(chord.Velocity + ChangeVelocity)		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = UBound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.NoteList(thisNote) <> nil then		      dim theNote as NoteObj = Chord.Notes(thisNote)		      ModifyVelocity(theNote, ChangeVelocity)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ModifyVelocity(Group as GroupObj, ChangeVelocity as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ModifyVelocity(GroupObj, " + Str(ChangeVelocity) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisObject)		        ModifyVelocity(note, ChangeVelocity)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim chord as chordObj = Group.Objects(thisObject)		        ModifyVelocity(chord, ChangeVelocity)		      end if		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as groupObj = Group.Objects(thisObject)		        ModifyVelocity(mGroup, ChangeVelocity)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ModifyVelocity(ChangeVelocity as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ModifyVelocity(" + Str(ChangeVelocity) + ")")		  #endif		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  dim CommandEditModifyVelocity as CommandEditModifyVelocityObj = new CommandEditModifyVelocityObj(ParentWindow)		  ParentWindow.CommandMgr.InvokeCommand(CommandEditModifyVelocity)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        ModifyVelocity(note, ChangeVelocity)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as chordObj = ParentWindow.NoteMgr.Selection(thisObject)		        ModifyVelocity(chord, ChangeVelocity)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim group as groupObj = ParentWindow.NoteMgr.Selection(thisObject)		        ModifyVelocity(group, ChangeVelocity)		      end if		      		    end if		  next		  		  ParentWindow.CommandMgr.InvokePostCommandActions		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ModifyVelocity(Note as NoteObj, ChangeVelocity as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ModifyVelocity(NoteObj, " + Str(ChangeVelocity) + ")")		  #endif		  		  note.Velocity = MIDILib.CheckVelocity(note.Velocity + ChangeVelocity)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Paste()		  'get current track		  'for each item in CopyClipboard		  'clone each object		  'append to Notes/Chords		  'append object from Notes/Chords to Track		  'RefreshParentWindow		  		  if Ubound(CopyMgr.CopyClipboard) = -1 then return		  		  dim i, n as integer		  dim track as TrackObj		  dim note as NoteObj		  dim chord as ChordObj		  		  ParentWindow.NoteMgr.SelectNone		  		  track = ParentWindow.TrackListObj1.CurrentTrack		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(CopyMgr.CopyClipboard)		  for thisObject = firstObject to lastObject		    if CopyMgr.CopyClipboard(thisObject) <> nil then		      		      if CopyMgr.CopyClipboard(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = CopyMgr.CopyClipboard(thisObject)		        dim NewGroup as GroupObj = ParentWindow.NoteMgr.CloneObject(mGroup)		        NewGroup.Track = Track		        ParentWindow.NoteMgr.AddObjectToArray(NewGroup)		        ParentWindow.NoteMgr.AddToSelection(NewGroup)		        Track.AddObject(NewGroup)		      end if		      		      if CopyMgr.CopyClipboard(thisObject) IsA ChordObj then		        dim mChord as ChordObj = CopyMgr.CopyClipboard(thisObject)		        dim NewChord as ChordObj = ParentWindow.NoteMgr.CloneObject(mChord)		        NewChord.Track = Track		        ParentWindow.NoteMgr.AddObjectToArray(NewChord)		        ParentWindow.NoteMgr.AddToSelection(NewChord)		        Track.AddObject(NewChord)		      end if		      		      if CopyMgr.CopyClipboard(thisObject) IsA NoteObj then		        dim mNote as NoteObj = CopyMgr.CopyClipboard(thisObject)		        dim NewNote as NoteObj = ParentWindow.NoteMgr.CloneObject(mNote)		        NewNote.Track = Track		        ParentWindow.NoteMgr.AddObjectToArray(NewNote)		        ParentWindow.NoteMgr.AddToSelection(NewNote)		        Track.AddObject(NewNote)		      end if		      		    end if		  next		  		  SetStartBeatsRelativeToEditCursor		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveChord()		  //this removes the chord, but leaves all of the notes even in nested groups		  		  redim Chords(-1)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = ParentWindow.NoteMgr.Selection(thisObject)		        RemoveChord(mGroup)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim mChord as ChordObj = ParentWindow.NoteMgr.Selection(thisObject)		        RemoveChord(mChord)		      end if		      		    end if		  next		  		  BreakChordDestroyChords		  		  ParentWindow.WindowNeedsSaving = true		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub RemoveChord(Chord as ChordObj)		  dim thisChordNote as integer = 0		  dim firstChordNote as integer = 0		  dim lastChordNote as integer = Ubound(Chord.Notes)		  		  //break the notes out of the chord to the group or track		  for thisChordNote = lastChordNote DownTo firstChordNote		    if Chord.Notes(thisChordNote) <> nil then		      		      dim chordNote as NoteObj = Chord.Notes(thisChordNote)		      		      if chordNote = chord.Root then //we're leaving this in the music		        		        dim Group as GroupObj = Chord.Group		        chordNote.Chord = nil		        		        if Group <> nil then		          chordNote.Group = Group		          		          Group.Objects.Append chordNote		          		        else //we're in a track		          ParentWindow.TrackListObj1.CurrentTrack.AddObject(chordNote)		          		        end if		        		      else //this isn't the root, therefore it has to go.		        		        //RemoveObjectFromArray is isolated to the parent group/chord.		        //Notes nested in a group//chord only see the group/chord.		        		        ParentWindow.NoteMgr.RemoveObjectFromArray(chordNote)		        		      end if		      		    end if		  next		  		  Chords.Append Chord //save for removal later.		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub RemoveChord(Group as GroupObj)		  //keep digging into nested groups		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisObject)		        RemoveChord(mGroup)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim mChord as ChordObj = Group.Objects(thisObject)		        RemoveChord(mChord)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveGroup()		  #if kLogMethods		    Log("EditMgrObj.RemoveGroup")		  #endif		  		  dim i, o as integer		  dim Group as GroupObj		  		  for i = UBound(ParentWindow.NoteMgr.Selection) DownTo 0		    if ParentWindow.NoteMgr.Selection(i) <> nil then		      		      if ParentWindow.NoteMgr.Selection(i) IsA GroupObj then		        Group = ParentWindow.NoteMgr.Selection(i)		        		        //we take the contents of the group and place them in the selection and the track		        dim thisGroupedObject as integer = 0		        dim firstGroupedObject as integer = 0		        dim lastGroupedObject as integer = Ubound(Group.Objects)		        		        for thisGroupedObject = firstGroupedObject to lastGroupedObject		          if Group.Objects(thisGroupedObject) <> nil then		            		            if Group.Objects(thisGroupedObject) IsA GroupObj then		              dim nestedGroup as GroupObj = Group.Objects(thisGroupedObject)		              nestedGroup.Group = nil		              ParentWindow.NoteMgr.AddToSelection(nestedGroup)		              ParentWindow.TrackListObj1.CurrentTrack.AddObject(nestedGroup)		            end if		            		            if Group.Objects(thisGroupedObject) IsA ChordObj then		              dim chord as ChordObj = Group.Objects(thisGroupedObject)		              chord.Group = nil		              ParentWindow.NoteMgr.AddToSelection(chord)		              ParentWindow.TrackListObj1.CurrentTrack.AddObject(chord)		            end if		            		            if Group.Objects(thisGroupedObject) IsA NoteObj then		              dim note as NoteObj = Group.Objects(thisGroupedObject)		              note.Group = nil		              ParentWindow.NoteMgr.AddToSelection(note)		              ParentWindow.TrackListObj1.CurrentTrack.AddObject(note)		            end if		            		          end if		        next		        		        //remove the group from the track		        ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(Group)		        		        //remove the group from the selection array		        for i = UBound(ParentWindow.NoteMgr.Selection) DownTo 0		          if ParentWindow.NoteMgr.Selection(i) = Group then		            ParentWindow.NoteMgr.Selection.Remove(i)		          end if		        next		        		        //remove the group from the groups array		        for i = UBound(ParentWindow.NoteMgr.Groups) DownTo 0		          if ParentWindow.NoteMgr.Groups(i) = Group then		            ParentWindow.NoteMgr.Groups.Remove(i)		          end if		        next		        		      end if		    end if		  next		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleLength(Chord as ChordObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleLength(ChordObj, " + Str(Scale) + ")")		  #endif		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = UBound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.NoteList(thisNote) <> nil then		      dim theNote as NoteObj = Chord.Notes(thisNote)		      ScaleLength(theNote, Scale)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleLength(Group as GroupObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleLength(GroupObj, " + Str(Scale) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisObject)		        ScaleLength(note, Scale)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim chord as chordObj = Group.Objects(thisObject)		        ScaleLength(chord, Scale)		      end if		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as groupObj = Group.Objects(thisObject)		        ScaleLength(mGroup, Scale)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ScaleLength(Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleLength(" + Str(Scale) + ")")		  #endif		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  //The Undo action is managed in the menu command because of the group conditional		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleLength(note, Scale)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as chordObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleLength(chord, Scale)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim group as groupObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleLength(group, Scale)		      end if		      		    end if		  next		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleLength(Note as NoteObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleLength(NoteObj, " + Str(Scale) + ")")		  #endif		  		  if Note.Length < MIDILib.kNoteLength_64 then return		  		  Note.Length = MIDILib.CheckLength(Note.Length * (Scale / 100.00))		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleStartBeat(Chord as ChordObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleStartBeat(ChordObj, " + Str(Scale) + ")")		  #endif		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = UBound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.NoteList(thisNote) <> nil then		      dim theNote as NoteObj = Chord.Notes(thisNote)		      ScaleStartBeat(theNote, Scale)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleStartBeat(Group as GroupObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleStartBeat(GroupObj, " + Str(Scale) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisObject)		        ScaleStartBeat(note, Scale)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim chord as chordObj = Group.Objects(thisObject)		        ScaleStartBeat(chord, Scale)		      end if		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as groupObj = Group.Objects(thisObject)		        ScaleStartBeat(mGroup, Scale)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ScaleStartBeat(Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleStartBeat(" + Str(Scale) + ")")		  #endif		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  //The Undo action is managed in the menu command because of the group conditional		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleStartBeat(note, Scale)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as chordObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleStartBeat(chord, Scale)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim group as groupObj = ParentWindow.NoteMgr.Selection(thisObject)		        ScaleStartBeat(group, Scale)		      end if		      		    end if		  next		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ScaleStartBeat(Note as NoteObj, Scale as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.ScaleStartBeat(NoteObj, " + Str(Scale) + ")")		  #endif		  		  //we use CheckLength here to make sure that we don't go any smaller than a 1/64.		  Note.StartBeat = MIDILib.CheckLength(Note.StartBeat * (Scale / 100.00))		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetLength(Chord as ChordObj, NewLength as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetLength(ChordObj, " + Str(NewLength) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Chord.Notes)		  		  for thisObject = firstObject to lastObject		    if Chord.Notes(thisObject) <> nil then		      		      dim theNote as NoteObj = Chord.Notes(thisObject)		      		      SetLength(theNote, NewLength)		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetLength(Group as GroupObj, NewLength as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetLength(GroupObj, " + Str(NewLength) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisObject)		        SetLength(note, NewLength)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim chord as chordObj = Group.Objects(thisObject)		        SetLength(chord, NewLength)		      end if		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as groupObj = Group.Objects(thisObject)		        SetLength(mGroup, NewLength)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetLength(NewLength as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetLength(" + Str(NewLength) + ")")		  #endif		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  dim CommandEditSetLength as CommandEditSetLengthObj = new CommandEditSetLengthObj(ParentWindow)		  ParentWindow.CommandMgr.InvokeCommand(CommandEditSetLength)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetLength(note, NewLength)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as chordObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetLength(chord, NewLength)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim group as groupObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetLength(group, NewLength)		      end if		      		    end if		  next		  		  ParentWindow.CommandMgr.InvokePostCommandActions		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetLength(Note as NoteObj, NewLength as integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetLength(NoteObj, " + Str(NewLength) + ")")		  #endif		  		  Note.Length = NewLength		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetStartBeatsRelativeToEditCursor()		  //called by EditMgr.Paste		  		  //here's where we apply the EditCursorObj.Startbeat to the newly added notes so		  //that the notes are put in position relative to the EditCursorObj as placed		  //by the user.		  //all pasted objects are automatically selected, so we can go by that list of		  //objects for all of this.		  		  //this is supposed to go through the object hierarchy of the selection, but		  //the note lists weren't taking at this point for some reason.		  		  dim copiedNotes(-1) as NoteObj		  		  //first we get all of the copied notes		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = UBound(ParentWindow.NoteMgr.Notes)		  		  for thisNote = firstNote to lastNote		    if ParentWindow.NoteMgr.Notes(thisNote) <> nil then		      dim theNote as NoteObj = ParentWindow.NoteMgr.Notes(thisNote)		      if theNote.Selected then		        copiedNotes.Append(theNote)		      end if		    end if		  next		  		  //then we sort out which note is first so we can sort out the delta		  dim thisCopiedNote as integer = 0		  dim firstCopiedNote as integer = 0		  dim lastCopiedNote as integer = Ubound(copiedNotes)		  		  if lastCopiedNote = -1 then return		  		  dim firstNoteInSelection as NoteObj = copiedNotes(0)		  		  for thisCopiedNote = firstCopiedNote to lastCopiedNote		    if copiedNotes(thisCopiedNote) <> nil then		      dim theCopiedNote as NoteObj = copiedNotes(thisCopiedNote)		      if theCopiedNote.StartBeat < firstNoteInSelection.StartBeat then		        firstNoteInSelection = theCopiedNote		      end if		    end if		  next		  		  dim EditCursorStartBeat as integer = ParentWindow.PlayMgr.EditCursor.StartBeat		  dim PasteDelta as integer = EditCursorStartBeat - firstNoteInSelection.StartBeat		  		  //then we apply the delta all of the notes		  dim thisDeltaNote as integer = 0		  dim firstDeltaNote as integer = 0		  dim lastDeltaNote as integer = UBound(copiedNotes)		  		  for thisDeltaNote = firstDeltaNote to lastDeltaNote		    if copiedNotes(thisDeltaNote) <> nil then		      dim theDeltaNote as NoteObj = copiedNotes(thisDeltaNote)		      theDeltaNote.StartBeat = theDeltaNote.StartBeat + PasteDelta		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetVelocity(Chord as ChordObj, NewVelocity as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetVelocity(ChordObj, " + Str(NewVelocity) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Chord.Notes)		  		  for thisObject = firstObject to lastObject		    if Chord.Notes(thisObject) <> nil then		      		      dim theNote as NoteObj = Chord.Notes(thisObject)		      		      SetVelocity(theNote, NewVelocity)		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetVelocity(Group as GroupObj, NewVelocity as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetVelocity(GroupObj, " + Str(NewVelocity) + ")")		  #endif		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(Group.Objects)		  		  for thisObject = firstObject to lastObject		    if Group.Objects(thisObject) <> nil then		      		      if Group.Objects(thisObject) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisObject)		        SetVelocity(note, NewVelocity)		      end if		      		      if Group.Objects(thisObject) IsA ChordObj then		        dim chord as chordObj = Group.Objects(thisObject)		        SetVelocity(chord, NewVelocity)		      end if		      		      if Group.Objects(thisObject) IsA GroupObj then		        dim mGroup as groupObj = Group.Objects(thisObject)		        SetVelocity(mGroup, NewVelocity)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetVelocity(NewVelocity as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetVelocity(" + Str(NewVelocity) + ")")		  #endif		  		  if Ubound(ParentWindow.NoteMgr.Selection) = -1 then Return		  		  dim CommandEditSetVelocity as CommandEditSetVelocityObj = new CommandEditSetVelocityObj(ParentWindow)		  ParentWindow.CommandMgr.InvokeCommand(CommandEditSetVelocity)		  		  dim thisObject as integer = 0		  dim firstObject as integer = 0		  dim lastObject as integer = Ubound(ParentWindow.NoteMgr.Selection)		  		  for thisObject = firstObject to lastObject		    if ParentWindow.NoteMgr.Selection(thisObject) <> nil then		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA NoteObj then		        dim note as NoteObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetVelocity(note, NewVelocity)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA ChordObj then		        dim chord as chordObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetVelocity(chord, NewVelocity)		      end if		      		      if ParentWindow.NoteMgr.Selection(thisObject) IsA GroupObj then		        dim group as groupObj = ParentWindow.NoteMgr.Selection(thisObject)		        SetVelocity(group, NewVelocity)		      end if		      		    end if		  next		  		  ParentWindow.CommandMgr.InvokePostCommandActions		  		  RefreshParentWindow		  		  ParentWindow.WindowNeedsSaving = true		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SetVelocity(Note as NoteObj, NewVelocity as Integer)		  #if kLogMethods		    Log("WindowEditor.EditMgrObj.SetVelocity(NoteObj, " + Str(NewVelocity) + ")")		  #endif		  		  Note.Velocity = NewVelocity		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SwapNotesAndChords()		  //called by MakeChord(integer)		  		  dim lastChord as integer = Ubound(Chords)		  		  if lastChord = -1 then return		  		  dim thisChord as integer = 0		  dim firstChord as integer = 0		  		  for thisChord = lastChord DownTo firstChord		    if Chords(thisChord) <> nil then		      		      //get the objects needed for the swap		      dim NewChord as ChordObj = Chords(thisChord)		      dim OldNote as NoteObj = NewChord.Root		      dim Group as GroupObj = NewChord.Group		      		      ParentWindow.NoteMgr.RemoveFromSelection(OldNote)		      		      if Group <> nil then		        		        ParentWindow.NoteMgr.RemoveObjectFromGroup(OldNote, Group)		        Group.Objects.Append(NewChord)		        		      else //we're in the track		        		        ParentWindow.NoteMgr.RemoveFromSelection(OldNote)		        ParentWindow.NoteMgr.AddToSelection(NewChord)		        		        ParentWindow.TrackListObj1.CurrentTrack.RemoveObject(OldNote)		        ParentWindow.TrackListObj1.CurrentTrack.AddObject(NewChord)		        		      end if //Group <> nil		      		      NewChord.DeselectObj		      NewChord.SelectObj		      		    end if //Chords(thisChord) <> nil		  next //thisChord = lastChord DownTo firstChord		  		  ParentWindow.NoteMgr.SetSelectionNoteLists		End Sub	#tag EndMethod	#tag Note, Name = How Most Edits Work		Most Edits will look at the selection's object hierarchy and drill down		to the NoteObj. Edits are applied there.				This is because ChordObjs and GroupObjs are just containers for NoteObjs		and have no useful StartBeat, Length, and Velocity parameters.		Also, since certain properties need to be applied to ALL objects in a		hierarchy, we have to drill down anyway.				However, the edits do NOT use the NoteList inherent with each MusicObj		because that would cause an inconsistency between between them and the		object management methods.			#tag EndNote	#tag Property, Flags = &h21		Private Chords(-1) As ChordObj	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass