#tag ClassProtected Class MIDIExport_GarageBand_ObjInherits ManagerObj	#tag Method, Flags = &h1		Protected Sub AddAppleSMPTE()		  Addbytes(BufferMB, 4, kTrack_SMPTEOffset_32)		  		  //&h40000000 		  Addbytes(BufferMB, 8, &h40000000)		  		  //&h0000B000 		  Addbytes(BufferMB, 8, &h0000B000)		  		  //&h0000B020 		  Addbytes(BufferMB, 4, &h0000B020)		  		  //&h0000		  Addbytes(BufferMB, 2, &h0000)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddBytes(MB as MemoryBlock, ByteCount as integer, Value as integer)		  //This appends the value in the MemoryBlock within the required number of bytes.		  //This does not for variable length quantities		  		  dim n as integer		  dim hexValue as string		  		  if ByteCount = 3 then //this is for the tempo, which is always three bytes but not a VLQ		    if Value > 16777215 then Value = 16777215 //if the value is larger then &hFFFFFF then force it to &hFFFFFF		    hexValue = Hex(Value)		    while len(hexValue) < 6 //prepend the string with leading zeros to make it three bytes		      hexValue = "0" + hexValue		    wend		    for n = 1 to 5 step 2 //break down the hex string into 1 byte chunks and append the values		      AddBytes(MB, 1, Val("&h" + Mid(hexValue, n, 2)))		    next		    return		  end if		  		  dim ByteOffset as integer		  		  if MB.Size <> 0 then		    ByteOffset = MB.Size		    MB.Size = MB.Size + ByteCount		  else		    MB.Size = ByteCount		    ByteOffset = 0		  end if		  		  select case ByteCount		  case 1		    MB.Int8Value(ByteOffset) = Value		  case 2		    MB.Int16Value(ByteOffset) = Value		  case 4		    MB.Int32Value(ByteOffset) = Value		  case 8		    MB.Int64Value(ByteOffset) = Value		  else		    MsgBox "There was an error adding " + str(Value) + " as " + str(ByteCount) + " bytes at offset " + str(ByteOffset) + " to a MemoryBlock."		  end select		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddSMPTE()		  //SMPTE Event; may not be necessary		  AddBytes(BufferMB, 4, kTrack_SMPTEOffset_32)		  AddBytes(BufferMB, 1, 0) //Hours (0-23)		  AddBytes(BufferMB, 1, 0) //Minutes (0-59)		  AddBytes(BufferMB, 1, 0) //Seconds (0-59)		  AddBytes(BufferMB, 1, 30) //Frames (24, 25, 29, 30); &h1E		  AddBytes(BufferMB, 1, 0) //Fractional Frames (0-99)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub AddStringToMemoryBlock(theString as string, TheMB as MemoryBlock)		  dim StringLength as integer = lenB(theString)		  		  WriteVarLen(StringLength, TheMB)		  		  dim ByteOffset as integer		  		  if TheMB.Size <> 0 then		    ByteOffset = TheMB.Size		    TheMB.Size = TheMB.Size + StringLength		  else		    TheMB.Size = StringLength		    ByteOffset = 0		  end if		  		  TheMB.StringValue(ByteOffset, StringLength) = theString		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CollectAllTrackNotes(Track as TrackObj)		  //Called by CreateTrack		  		  Redim TrackNotes(-1)		  		  dim thisPlayObj as integer = 0		  dim firstPlayObj as integer = 0		  dim lastPlayObj as integer = Ubound(Track.Music)		  		  for thisPlayObj = firstPlayObj to lastPlayObj		    if Track.Music(thisPlayObj) <> nil then		      		      if Track.Music(thisPlayObj) IsA GroupObj then		        dim group as GroupObj = Track.Music(thisPlayObj)		        CollectNotes(group)		      end if		      		      if Track.Music(thisPlayObj) IsA ChordObj then		        dim chord as ChordObj = Track.Music(thisPlayObj)		        CollectNotes(chord)		      end if		      		      if Track.Music(thisPlayObj) IsA NoteObj then		        dim note as NoteObj = Track.Music(thisPlayObj)		        CollectNotes(note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CollectNotes(Chord as ChordObj)		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Chord.Notes)		  		  for thisNote = firstNote to lastNote		    if Chord.Notes(thisNote) <> nil then		      dim note as NoteObj = Chord.Notes(thisNote)		      CollectNotes(note)		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CollectNotes(Group as GroupObj)		  dim thisPlayObj as integer = 0		  dim firstPlayObj as integer = 0		  dim lastPlayObj as integer = Ubound(Group.Objects)		  		  for thisPlayObj = firstPlayObj to lastPlayObj		    if Group.Objects(thisPlayObj) <> nil then		      		      if Group.Objects(thisPlayObj) IsA GroupObj then		        dim mGroup as GroupObj = Group.Objects(thisPlayObj)		        CollectNotes(mGroup)		      end if		      		      if Group.Objects(thisPlayObj) IsA ChordObj then		        dim chord as ChordObj = Group.Objects(thisPlayObj)		        CollectNotes(chord)		      end if		      		      if Group.Objects(thisPlayObj) IsA NoteObj then		        dim note as NoteObj = Group.Objects(thisPlayObj)		        CollectNotes(note)		      end if		      		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CollectNotes(Note As NoteObj)		  TrackNotes.Append Note		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CombineBufferAndNotes()		  dim thisByte as integer = 0		  dim firstByte as integer = 0		  dim lastByte as integer = NoteMB.Size - 1		  		  BufferMB.Size = 1		  		  for thisByte = firstByte to lastByte		    if thisByte > firstByte then		      BufferMB.Size = BufferMB.Size + 1		    end if		    dim BufferLastByte as integer = BufferMB.Size - 1		    BufferMB.Byte(BufferLastByte) = NoteMB.Byte(thisByte)		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CombineMemoryBlocks(Source as MemoryBlock, Destination as MemoryBlock)		  dim thisByte as integer = 0		  dim firstByte as integer = 0		  dim lastByte as integer = Source.Size - 1		  		  for thisByte = firstByte to lastByte		    'increment destination by a byte		    Destination.Size = Destination.Size + 1		    'get the last destination byte index		    dim DestinationLastByte as integer = Destination.Size - 1		    'apply the source byte value to the last destination byte		    Destination.Byte(DestinationLastByte) = Source.Byte(thisByte)		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateFileStream()		  File = FileLib.ModalSaveAsDialog(ParentWindow, "audio/midi", ParentWindow.Name + "." + FileLib.kFileExtension_MIDI)//file type, name		  		  if File <> nil then		    Write = File.CreateBinaryFile(FileTypes1.AudioMidi)//file type		  else		    //fail silently 'MsgBox "There was a problem creating the MIDI file."		    return		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateHeader()		  //Called by ExportToMIDI		  		  FileMB.Size = 4		  FileMB.Int32Value(0) = kHeader_Header_32		  		  AddBytes(FileMB, 4, kHeader_Length_32)		  AddBytes(FileMB, 2, kHeader_Format_MultipleTrack_16)		  AddBytes(FileMB, 2, ParentWindow.TrackListObj1.ListCount + 1) //Number of tracks; in testing 2 tracks + time sig track (as shown in MIDI spec)		  		  //delta time resolution; was kHeader_TicksPerQuarterNote_16 = 96		  //This wa conformed to MIDILib.kNoteLength_04 (= 48) for easy math).		  AddBytes(FileMB, 2, MIDILib.kNoteLength_04) 		  		  //CreateTrack is next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateKeySignature()		  //BufferMB		  		  dim mKey as KeyObj = ParentWindow.SongMgr.Keys(0)		  if mKey = nil then return		  		  dim mKeyTonic as Integer = ParentWindow.SongMgr.Keys(0).GetKeyTonicFromPitchValue(mKey.Tonic)		  		  dim mKeyKey as String = mKey.Key		  		  dim mKeyTonicValue as integer = &h00		  dim mKeyKeyValue as integer = &h00		  		  'B        11		  'A#/Bb    10		  'A        9		  'G#/Ab    8		  'G        7		  'F#/Gb    6		  'F        5		  'E        4		  'D#/Eb    3		  'D        2		  'C#/Db    1		  'C        0		  		  select case mKeyTonic		  case 1 '07 = C# maj		    mKeyTonicValue = &h07		  case 6 '06 = F# maj		    mKeyTonicValue = &h06		  case 11 '05 = B maj		    mKeyTonicValue = &h05		  case 4'04 = E maj		    mKeyTonicValue = &h04		  case 9 '03 = A maj		    mKeyTonicValue = &h03		  case 2 '02 = D maj		    mKeyTonicValue = &h02		  case 7 '01 = G maj		    mKeyTonicValue = &h01		  case 0 '00 = C maj		    mKeyTonicValue = &h00		  case 5 'FF = F maj		    mKeyTonicValue = &hFF		  case 10 'FE = Bb maj		    mKeyTonicValue = &hFE		  case 3 'FD = Eb maj		    mKeyTonicValue = &hFD		  case 8 'FC = Ab maj		    mKeyTonicValue = &hFC		  case 1 'FB = Db maj		    mKeyTonicValue = &hFB		  case 6 'FA = Gb maj		    mKeyTonicValue = &hFA		  case 11 'F9 = Cb maj 		    mKeyTonicValue = &hF9		  else		    mKeyTonicValue = &h00		  end select		  		  select case mKeyKey		  case MusicLib.kKeyMajor, MusicLib.kKeyModPentatonicMajor		    mKeyKeyValue = 0		  case MusicLib.kKeyMinor, MusicLib.kKeyMinorHarmonic, MusicLib.kKeyMinorMelodic, MusicLib.kKeyModPentatonicMinor		    mKeyKeyValue = 1		  else		    mKeyKeyValue = 0		  end select		  		  AddBytes(BufferMB, 4, kTrack_KeySignatureEvent_32)		  AddBytes(BufferMB, 1, mKeyTonicValue)		  AddBytes(BufferMB, 1, mKeyKeyValue)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTimeSignatureTrack()		  CreateTrackHeader		  		  //Get song name FF 03 VarLen Text		  BufferMB.Size = 1		  BufferMB.UInt8Value(0) = kTrack_DeltaTimeZero_8		  		  //comment out the next 3 commands (and 1 comment) to remove the song name		  'AddBytes(BufferMB, 2, kTrack_Name_16)		  'AddStringToMemoryBlock(ParentWindow.Name, BufferMB)		  '//Time Signature Event		  'AddBytes(BufferMB, 1, kTrack_DeltaTimeZero_8)		  		  AddBytes(BufferMB, 2, kTrack_TimeSigEvent_16)		  AddBytes(BufferMB, 1, kTrack_TimeSigEventLength_8)		  		  AddBytes(BufferMB, 1, GetTimeSignatureNumerator)//time sig numerator; DYNAMIC		  AddBytes(BufferMB, 1, GetTimeSignatureDenominator) //time sig denominator (nn/2^dd); DYNAMIC		  AddBytes(BufferMB, 1, 48) //MIDI Clocks / quarter note; 24 is standard; 48 in MusicSketch		  		  AddBytes(BufferMB, 1, 4) //notated 32nds in 24 MIDI clocks; 8 is standard; 16 in MusicSketch		  		  //tempo event		  AddBytes(BufferMB, 1, kTrack_DeltaTimeZero_8)		  		  AddBytes(BufferMB, 2, kTrack_TempoEvent_16)		  AddBytes(BufferMB, 1, kTrack_TempoEventLength_8)		  		  AddBytes(BufferMB, 3, GetBeatsPerMinute) //BPM: Microseconds per quarternote; 16,777,215 Max; DYNAMIC		  		  //SMPTE Event		  'AddAppleSMPTE //BufferMB; Apple's funky version		  AddSMPTE //BufferMB		  		  //Key Signature		  'CreateKeySignature //BufferMB		  		  CreateTrackFooter		  		  AddBytes(FileMB, 4, BufferMB.Size)		  		  //Add track data to File MB.		  CombineMemoryBlocks(BufferMB, FileMB)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTrack(Track as TrackObj)		  //called by ExportToMIDI		  		  CreateTrackHeader //FileMB		  		  CreateTrackNoteDataHeader(Track) //NoteMB		  		  CreateTrackNoteData(Track) //NoteMB		  		  CombineBufferAndNotes //init BufferMB		  'CombineMemoryBlocks(NoteMB, BufferMB)		  		  CreateTrackFooter //BufferMB		  		  //the whole track has been collected		  //get the size and write to the file's MB		  AddBytes(FileMB, 4, BufferMB.Size)		  		  //Add the track data to the File MB		  CombineMemoryBlocks(BufferMB, FileMB)		  		  //ExportToMIDI is next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTrackFooter()		  AddBytes(BufferMB, 4, kTrack_End_32)		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTrackHeader()		  //Called by ExportToMIDI and CreateTrack		  		  'BufferMB.Size = 4		  'BufferMB.UInt32Value = kTrack_Header_32		  		  AddBytes(FileMB, 4, kTrack_Header_32)		  		  //Track Length. Variable Length Data. 4 bytes every time		  //but first, we need to collect all track data to determine		  //final length into a Buffer, and then add to the buffer		  		  //back to ExportToMIDI and CreateTrack		  //Track data comes next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTrackNoteData(Track as TrackObj)		  //called by CreateTrack		  		  dim ChannelNoteOnEvent as Integer = GetMIDINoteOnEvent(Track)		  		  'get max beats (start + length of furthest out note)		  'for every beat		  dim thisBeat as integer = 0		  dim firstBeat as integer = 0		  dim lastBeat as integer = GetTrackLength		  		  dim deltaTime as integer = kTrack_DeltaTimeZero_8		  		  for thisBeat = firstBeat to lastBeat		    'for every note		    dim thisNote as integer = 0		    dim firstNote as integer = 0		    dim lastNote as integer = Ubound(TrackNotes)		    		    for thisNote = firstNote to lastNote		      dim note as NoteObj = TrackNotes(thisNote)		      if note <> nil then		        		        'collect the note's start beat, start beat + length, pitch, velocity		        dim noteStart as integer = note.StartBeat		        dim noteEnd as integer = note.StartBeat + note.Length		        dim notePitch as integer = note.Pitch		        dim noteVelocity as integer = note.Velocity		        		        'if the note starts on the beat		        if noteStart = thisBeat then		          		          'record the delta time		          if deltaTime = kTrack_DeltaTimeZero_8 then		            AddBytes(NoteMB, 1, kTrack_DeltaTimeZero_8)		          else		            WriteVarLen(deltaTime, NoteMB)		          end if		          		          'record the note on event		          AddBytes(NoteMB, 1, ChannelNoteOnEvent)		          		          'record the note's pitch		          AddBytes(NoteMB, 1, notePitch)		          		          'record the note's velocity		          AddBytes(NoteMB, 1, noteVelocity)		          		          'set the delta time to 0		          deltaTime = kTrack_DeltaTimeZero_8		          		        end if		        		        if noteEnd = thisBeat then		          		          'record the delta time		          if deltaTime = kTrack_DeltaTimeZero_8 then		            AddBytes(NoteMB, 1, kTrack_DeltaTimeZero_8)		          else		            WriteVarLen(deltaTime, NoteMB)		          end if		          		          //this is the original for general MIDI files		          ''record the note on event		          'AddBytes(NoteMB, 1, kTrack_NoteOff_8)		          '		          ''record the note's pitch		          'AddBytes(NoteMB, 1, notePitch)		          '		          ''record the note's velocity		          'AddBytes(NoteMB, 1, noteVelocity)		          '		          ''set the delta time to 0		          'deltaTime = kTrack_DeltaTimeZero_8		          		          //this is the new one for GarageBand		          'record the note on event		          AddBytes(NoteMB, 1, ChannelNoteOnEvent)		          		          'record the note's pitch		          AddBytes(NoteMB, 1, notePitch)		          		          'record the note's velocity		          AddBytes(NoteMB, 1, 0)		          		          'set the delta time to 0		          deltaTime = kTrack_DeltaTimeZero_8		          		        end if		      end if		      		      'next note		    next		    		    'increment the delta time		    deltaTime = deltaTime + 1		    		    'next beat		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub CreateTrackNoteDataHeader(Track as TrackObj)		  //Called by CreateTrack		  		  NoteMB.Size = 1 //reset the size of the buffer		  NoteMB.UInt8Value(0) = kTrack_DeltaTimeZero_8		  		  //comment out the next 6 command (and 1 comment) to remove strings from the MIDI file		  '//Track Name		  'AddBytes(NoteMB, 2, kTrack_Name_16)		  'AddStringToMemoryBlock(Track.Name, NoteMB)		  '//instrument name FF 04 VarLen Text		  'AddBytes(NoteMB, 1, kTrack_DeltaTimeZero_8)		  'AddBytes(NoteMB, 2, kTrack_Instrument_16)		  'AddStringToMemoryBlock(MIDILib.GetMIDInstrumentName(GetTrackInstrument(Track)), NoteMB)		  'AddBytes(NoteMB, 1, kTrack_DeltaTimeZero_8)		  		  AddBytes(NoteMB, 1, GetTrackChannel(Track)) //Channel (either 1 or 10; can be 16)		  AddBytes(NoteMB, 1, GetTrackInstrument(Track)) //Instrument		  		  CollectAllTrackNotes(Track)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ExportToMIDI()		  CreateFileStream		  		  if File <> nil and Write <> nil then		    		    InitializeFile		    SerializeTracks		    CreateHeader		    		    CreateTimeSignatureTrack		    		    dim thisTrack as integer = 0		    dim firstTrack as integer = 0		    dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		    		    for thisTrack = firstTrack to lastTrack		      dim track as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0)		      if track <> nil then		        CreateTrack(track)		      end if		    next		    		    Write.Write FileMB.LeftB(FileMB.Size)		    		  else		    MsgBox "There was a problem writing the MIDI file."		  end if		  		Finally		  if Write <> nil then		    Write.Close		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetBeatsPerMinute() As Integer		  //in Microseconds per MIDI quarter note = MIDILib.kNoteLength_04 = 48 clocks		  		  dim OriginalBeatsPerMinute as integer = ParentWindow.SongMgr.Tempo		  dim BeatsPerMinute as integer = 60000000 / kTrack_DefaultBeatsPerMinute		  		  BeatsPerMinute = 60000000 / OriginalBeatsPerMinute		  		  return min(BeatsPerMinute, kTrack_MaxBeatsPerMinute)		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetMIDINoteOffEvent(Track as TrackObj) As Integer		  //called by CreateTrack		  		  //this returns each track ID as a channel		  //does not take into account the percussion channel (10)		  		  'dim theInstrument as integer = Track.Instrument		  dim ChannelNoteOff as integer = kTrack_NoteOff_8 + Val(Track.ID)		  		  'select case theInstrument		  'case MIDILib.kMIDIPercussion		  'theInstrumentChannel = kTrack_Channel10_8		  'end select		  		  return ChannelNoteOff		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetMIDINoteOnEvent(Track as TrackObj) As Integer		  //called by CreateTrack		  		  //this returns each track ID as a channel		  //does not take into account the percussion channel (10)		  		  'dim theInstrument as integer = Track.Instrument		  dim ChannelNoteOn as integer = kTrack_NoteOn_8 + Val(Track.ID)		  		  'select case theInstrument		  'case MIDILib.kMIDIPercussion		  'theInstrumentChannel = kTrack_Channel10_8		  'end select		  		  return ChannelNoteOn		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetTimeSignatureDenominator() As Integer		  dim timeSigDenominator as integer = &h02		  		  Select Case  me.ParentWindow.PM_BasicBeat.ListIndex		  Case 0 '2		    timeSigDenominator = &h01		  Case 1 '4		    timeSigDenominator = &h02		  End Select		  		  return timeSigDenominator		  		  '2 = 1		  '3 = ?		  '4 = 2		  '5 = ?		  '6 = ?		  '8 = 4		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetTimeSignatureNumerator() As Integer		  dim timeSigNumerator as integer = &h04		  		  Select Case me.ParentWindow.PM_BeatsPerMeasure.ListIndex		  Case 0 '2		    timeSigNumerator = &h02		  Case 1 '3		    timeSigNumerator = &h03		  Case 2 '4		    timeSigNumerator = &h04		  End Select		  		  return timeSigNumerator		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetTrackChannel(Track as TrackObj) As Integer		  //called by CreateTrack		  		  //this returns each track ID as a channel		  //does not take into account the percussion channel (10)		  		  'dim theInstrument as integer = Track.Instrument		  dim theInstrumentChannel as integer = kTrack_Channel01_8 + Val(Track.ID)		  		  'select case theInstrument		  'case MIDILib.kMIDIPercussion		  'theInstrumentChannel = kTrack_Channel10_8		  'end select		  		  return theInstrumentChannel		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetTrackInstrument(Track as TrackObj) As Integer		  //called by CreateTrack		  		  return Track.Instrument		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function GetTrackLength() As Integer		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(TrackNotes)		  dim maxBeats as integer = 0		  		  for thisNote = firstNote to lastNote		    maxBeats = Max(maxBeats, (TrackNotes(thisNote).StartBeat + TrackNotes(thisNote).Length))		  next		  		  Return maxBeats		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub InitializeFile()		  //called by ExportToMIDI		  		  FileMB = NewMemoryBlock(0)		  BufferMB = NewMemoryBlock(0)		  NoteMB = NewMemoryBlock(0)		  		  FileMB.LittleEndian = false		  BufferMB.LittleEndian = false		  NoteMB.LittleEndian = false		  		  //CreateHeader is next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub SerializeTracks()		  dim thisTrack as integer = 0		  dim firstTrack as integer = 0		  dim lastTrack as integer = ParentWindow.TrackListObj1.ListCount - 1		  		  for thisTrack = firstTrack to lastTrack		    dim theTrack as TrackObj = ParentWindow.TrackListObj1.CellTag(thisTrack, 0) 		    theTrack.ID = Str(thisTrack)		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub WriteVarLen(inData as Integer, TheMB as MemoryBlock)		  Dim mb As MemoryBlock		  ' four bytes plus one extra, just in case		  mb = new MemoryBlock(5)		  Dim i As Integer		  i = 0		  ' Convert data from 8 bits to 7 bits plus flag bit		  while (inData > 0)		    ' Get lowest 7 bits of current data		    mb.Byte(i) = Bitwise.BitAnd(inData, &h7f)		    ' slide all the bits of inData 7 bits to the right		    inData = Bitwise.ShiftRight(inData, 7)		    if i > 0 then ' not least significant byte?		      ' set a flag on the byte		      mb.Byte(i) = Bitwise.BitOr(mb.Byte(i), &h80)		    end if		    i = i + 1 ' count up for next byte		  wend		  ' mapping done, now output converted data		  while i > 0 ' i is number-of-bytes plus 1		    ' output most significant bytes		    ' downto least significant		    i = i - 1		    AddBytes(TheMB, 1, mb.Byte(i))		  wend		End Sub	#tag EndMethod	#tag Note, Name = Data Errors		Logic won't even open this thing. it just says "Data Conflict Error".				One clue to what might be happening is in Reason. When it imports a MusicSketch MIDI file, it open the Time Signature track		with the first letter of the song missing, and a portion of the first track at the very end of the song				Also, Reason didn't open the note events correctly. I think events that overlapped cut off other ones.						Part of the problem might be in how byte locations and sizes are managed. 		MemoryBlock.Byte(n) is 0-based		MemoryBlock.Size = n is 1-based				4D 54 68 64		00 00 00 06		00 01		00 03		00 30		4D 54 72 6B		00 00 00 20		00 FF 03 55 6E 74 69 74 6C 65 64 20 31		00 FF 58 04 04 02 30 10		00 FF 51 03 07 A1 20		00 FF 2F 00		4D 54 72 6B		00 00 00 A2		00 FF 03 07 54 72 61 63 6B 20 31		00 FF 04 14 41 63 6F 75 73 74 69 63 20 47 72 61 6E 64 20 50 69 61 6E 6F		00 C0 01		00 90 40 3F		18 80 40 3F		00 90 40 3F		18 80 40 3F		00 90 41 3F		18 80 41 3F		00 90 43 3F		18 80 43 3F		00 90 43 3F		18 80 43 3F		00 90 41 3F		18 80 41 3F		00 90 40 3F		18 80 40 3F		00 90 3E 3F		18 80 3E 3F		00 90 3C 3F		18 80 3C 3F		00 90 3C 3F		18 80 3C 3F		00 90 3E 3F		18 80 3E 3F		00 90 40 3F		18 80 40 3F		00 90 40 3F		24 80 40 3F		00 90 3E 3F		0C 80 3E 3F		00 90 3E 3F		30 80 3E 3F		00 FF 2F 00		4D 54 72 6B		00 00 00 62		00 FF 03 07 54 72 61 63 6B 20 32		00 FF 04 14 41 63 6F 75 73 74 69 63 20 47 72 61 6E 64 20 50 69 61 6E 6F		00 C0 01		00 90 3C 3F		00 90 40 3F		00 90 43 3F		12 80 3C 3F		00 80 40 3F		00 80 43 3F		06 90 3C 3F		00 90 40 3F		00 90 43 3F		00 90 47 3F		12 80 3C 3F		00 80 40 3F		00 80 43 3F		00 80 47 3F		00 FF 2F 00	#tag EndNote	#tag Note, Name = Editing App Comparison		GarageBand		[ ] Now opens MS tracks into tracks AFTER QT conversion		   [ ] Also after conversion all tracks were placed into 1 track with the Time Sig				Reason				Logic Express	#tag EndNote	#tag Note, Name = ExportAsMIDI		For MIDI		1. Gather Header info		2. For each track in the track list		3. For each PlayObj in Music		4. Get the notes and place them in an array		5. Next (3)		6. Write note events		7. Add track to array		8. Next (2)		9. Gather footer info		10. Write the header		11. Write the tracks		12. Write the footer				Gathering note data		get max beats (start + length of furthest out note)				for every beat		for every note				collect the note's start beat, start beat + length, pitch, velocity				if the note starts on the beat		record the delta time		record the note on event		record the note's pitch		record the note's velocity		set the delta time to 0				next note		increment the delta time		next beat				4D 54 68 64		00 00 00 06		00 01		00 03		00 30		4D 54 72 6B		00 00 00 20		00 FF 03 55 6E 74 69 74 6C 65 64 20 31		00 FF 58 04 04 02 30 10		00 FF 51 03 07 A1 20		00 FF 2F 00		4D 54 72 6B		00 00 00 A2		00 FF 03 07 54 72 61 63 6B 20 31		00 FF 04 14 41 63 6F 75 73 74 69 63 20 47 72 61 6E 64 20 50 69 61 6E 6F		00 C0 01		00 90 40 3F		18 80 40 3F		00 90 40 3F		18 80 40 3F		00 90 41 3F		18 80 41 3F		00 90 43 3F		18 80 43 3F		00 90 43 3F		18 80 43 3F		00 90 41 3F		18 80 41 3F		00 90 40 3F		18 80 40 3F		00 90 3E 3F		18 80 3E 3F		00 90 3C 3F		18 80 3C 3F		00 90 3C 3F		18 80 3C 3F		00 90 3E 3F		18 80 3E 3F		00 90 40 3F		18 80 40 3F		00 90 40 3F		24 80 40 3F		00 90 3E 3F		0C 80 3E 3F		00 90 3E 3F		30 80 3E 3F		00 FF 2F 00		4D 54 72 6B		00 00 00 62		00 FF 03 07 54 72 61 63 6B 20 32		00 FF 04 14 41 63 6F 75 73 74 69 63 20 47 72 61 6E 64 20 50 69 61 6E 6F		00 C0 01		00 90 3C 3F		00 90 40 3F		00 90 43 3F		12 80 3C 3F		00 80 40 3F		00 80 43 3F		06 90 3C 3F		00 90 40 3F		00 90 43 3F		00 90 47 3F		12 80 3C 3F		00 80 40 3F		00 80 43 3F		00 80 47 3F		00 FF 2F 00	#tag EndNote	#tag Note, Name = FutureChanges		When we have multiple time signatures in a song file, 		the MIDI time sig math is going to have to change.		See MIDI Manual on how time sig changes are handled.				MIDI has 16 channels (10 is percussion) and unlimited track. Each track can send data to all 16 channels.		We need to sort out the relationship between MusicSketch tracks, MIDI tracks, and MIDI Channels.		Right now ALL TRACKS GO TO CHANNEL 1, but I'm not sure how that affects the track's instrument.			#tag EndNote	#tag Property, Flags = &h1		Protected BufferMB As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected File As FolderItem	#tag EndProperty	#tag Property, Flags = &h1		Protected FileMB As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected NoteMB As MemoryBlock	#tag EndProperty	#tag Property, Flags = &h1		Protected TrackNotes(-1) As NoteObj	#tag EndProperty	#tag Property, Flags = &h1		Protected Write As BinaryStream	#tag EndProperty	#tag Constant, Name = kHeader_DefaultTicksPerQuarterNote_16, Type = Double, Dynamic = False, Default = \"96", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Format_IndTrack_16, Type = Double, Dynamic = False, Default = \"1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Format_MultipleTrack_16, Type = Double, Dynamic = False, Default = \"1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Format_SeqIndSingleTracks_16, Type = Double, Dynamic = False, Default = \"2\r", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Format_SingleTrack_16, Type = Double, Dynamic = False, Default = \"0", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Header_32, Type = Double, Dynamic = False, Default = \"&h4D546864", Scope = Protected	#tag EndConstant	#tag Constant, Name = kHeader_Length_32, Type = Double, Dynamic = False, Default = \"6", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_Channel01_8, Type = Double, Dynamic = False, Default = \"&hC0\r", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_Channel10_8, Type = Double, Dynamic = False, Default = \"&hC9", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_DefaultBeatsPerMinute, Type = Double, Dynamic = False, Default = \"120", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_DefaultChannel_8, Type = Double, Dynamic = False, Default = \"1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_DefaultInstrument_8, Type = Double, Dynamic = False, Default = \"1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_DefaultVelocity_8, Type = Double, Dynamic = False, Default = \"90", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_DeltaTimeZero_8, Type = Double, Dynamic = False, Default = \"&h00", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_End_32, Type = Double, Dynamic = False, Default = \"&h00FF2F00", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_Header_32, Type = Double, Dynamic = False, Default = \"&h4D54726B", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_Instrument_16, Type = Double, Dynamic = False, Default = \"&hFF04", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_KeySignatureEvent_32, Type = Double, Dynamic = False, Default = \"&h00FF5902", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_MaxBeatsPerMinute, Type = Double, Dynamic = False, Default = \"16777215", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_Name_16, Type = Double, Dynamic = False, Default = \"&hFF03", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_NoteOff_8, Type = Double, Dynamic = False, Default = \"&h80", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_NoteOn_8, Type = Double, Dynamic = False, Default = \"&h90", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_SMPTEOffset_32, Type = Double, Dynamic = False, Default = \"&h00FF5405", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_SMPTEOffset_Apple, Type = Double, Dynamic = False, Default = \"&h00FF5405400000000000B0000000B0200000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_SMPTEOffset_ByteLength, Type = Double, Dynamic = False, Default = \"17", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_TempoEventLength_8, Type = Double, Dynamic = False, Default = \"&h03", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_TempoEvent_16, Type = Double, Dynamic = False, Default = \"&hFF51\r", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_TextEvent_16, Type = Double, Dynamic = False, Default = \"&hFF01", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_TimeSigEventLength_8, Type = Double, Dynamic = False, Default = \"&h04", Scope = Protected	#tag EndConstant	#tag Constant, Name = kTrack_TimeSigEvent_16, Type = Double, Dynamic = False, Default = \"&hFF58", Scope = Protected	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass