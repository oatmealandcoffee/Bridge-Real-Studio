#tag ModuleProtected Module DataLib	#tag Method, Flags = &h0		Function ClearFlag(mFlag as integer, mMask as integer) As Integer		  Return Bitwise.BitAnd( Bitwise.OnesComplement( mFlag ), mMask )		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function GetFlag(mFlag as integer, mMask as integer) As Boolean		  return Bitwise.BitAnd( mMask, mFlag ) = mFlag		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function SetFlag(mFlag as integer, mMask as integer) As Integer		  Return Bitwise.BitOr( mMask, mFlag )		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ToggleFlag(mFlag as integer, mMask as integer) As Integer		  Return Bitwise.BitXor( mMask, mFlag )		End Function	#tag EndMethod	#tag Note, Name = Bitmask Information						AND		 |0 1		-----		0|0 0		1|0 1				OR		 |0 1		-----		0|0 1		1|1 0				Complement		The one’s complement operation is a unary 		operation (meaning that it only has one 		operand) and it simply reverses the 		operand’s bits. It corresponds to the 		logical operator Not.				One great use for bitwise operators is as		a way to encode a lot of information into		a little amount of space. Let’s say you are		writing a function that creates an object,		and this object has a bunch of options which		can be set (let’s say there are 10 options).		If you passed in a Boolean for each option,		the method’s parameter list would be very		large indeed! However, you could also use a		single parameter which holds all of the flags		encoded as an integer. This is a very common		construct which you see when working with		declares and it’s called a bitmask. The idea		behind a bitmask is that you assign an option		to each bit in an integer, and the user can		specify they want that option by making its		corresponding bit a one in the mask.		Let’s take a real-world example from one		of the Win32 APIs: CreateWindow. The		CreateWindow API has a set of flags which		you specify to determine various characteristics		of the window you are creating. Is		it a child window? Does it have a border?		Can you resize it? Does it have a title bar?		We’re going to take a look at what some of		the values of these options are, and how		you can use them as a bitmask. Here are		three of the flags you can specify, shown		as hex numbers:		Const WS_CHILD = &h40000000		Const WS_MINIMIZE = &h20000000		Const WS_VISIBLE = &h10000000		These hex numbers may look like magic to		you, but they follow a very special bit pattern		when you view them as binary numbers:		each flag only has one bit set to one, the rest		of the bits are set to zero. Here are the same		constants in binary instead of hex:		Const WS_CHILD = &b10000000000000000000000000		00000		Const WS_MINIMIZE = &b0100000000000000000000		000000000		Const WS_VISIBLE = &b001000000000000000000000		0000000				This means that you can make a bitmask using these flags, and		easily tell what flags are set. For instance, if we had the mask:		&b1010000000000000000000000000000 then we would know that		WS_CHILD and WS_VISIBLE flags are set, but WS_MINIMIZE		was not.				We’re going to develop some helper functions for you which		create a fully functional bitmask using what we’ve learned about		bitwise operators. We’re going to make it so that you can set a		series of flags, test whether a flag is set or not, toggle a flag from		on to off, and clear a flag.				When making the Bitmask class, we’re going to need an Integer to		store the mask into, and four APIs: SetFlag, ToggleFlag, ClearFlag		and TestFlag. The class will look like this:				Class Bitmask				// This property is going to hold the bitmask as an integer. So when we set, clear, or test		// flags, we're going to be operating on a simple integer data type. Note that if you need		// more than 32 flags, you could use an Int64 instead of an Int32/Integer.		Private mMask As Integer				Sub ClearFlag(flag as Integer)		// Now we want to clear the bit in our mask. So that means if the bit		// was one, we want it to become zero. But if the bit was already zero,		// then we want it to stay that way. But we don't want any of the other		// bits to be affected. So what we want to do is a reverse And of sorts, where		// every one bit in the flag should produce a zero in the output, and every zero		// bit in the flag should do nothing. So what we're going to do is toggle all		// of the bits in the flag passed to us using One's Complement, and then And		// the results of that against our mask.				mMask = Bitwise.BitAnd( Bitwise.OnesComplement( flag ), mMask )		End Sub				Sub SetFlag(flag as Integer)		// We're going to be setting a bit to one within our mask, based		// on the flag passed in. If the flag was already one, then we don't		// want to do anything. But if it was zero, we want it to become a		// one. This is the same as the Bitwise Or operator.				mMask = Bitwise.BitOr( mMask, flag )		End Sub				Function TestFlag(flag as Integer) As Boolean		// To test a flag, we need to see whether the bit at that		// position is one or not. We can test to see if the bit		// is a one by doing a bitwise And using the flag and the		// bitmask itself.		//		// Note we're testing to see if the results of the And		// are the same as the flag passed in. If we simply tested		// to see whether the results were equal to zero or not, we		// would fail in the case where the user specified multiple		// flags at once.				return Bitwise.BitAnd( mMask, flag ) = flag		End Function				Sub ToggleFlag(flag as Integer)		// In this case, we want to toggle the bit in the mask based on the flag. So		// if the bit is set, it becomes unset, and if the bit is cleared, it becomes		// set. However, we don't want to affect any of the bits which are not set		// in the flag. So, if we have:		// &b00100 (mask)		// &b00010 (flag)		// We want to get:		// &b00110 (resulting mask)		//		// This should look surprisingly like an Xor operation to you.				mMask = Bitwise.BitXor( mMask, flag )		End Sub				End Class				As you can see, we probably don’t even need the class		at all—every method we wrote was a single line of code!		Frequently, you’re going to run into source code which makes		use of the bitmask concept without having a pretty API to use.		But when you see that source code, you will understand how		and why it works, as well as what it’s being used for because		you now know how to use bitwise operations.				Before you read this article, the bitwise operations may have		been a mystery to you. And within the first few paragraphs,		you were probably remembering boring math lectures from		bygone years. Now that you’ve completed this article, you’ve		mastered bitwise operations and are ready to use them to		your advantage in your own applications. They may not be		glorious, and they seem rather obtuse to the casual observer.		But they’re a powerful way for you to manipulate and encode		information into a compact storage unit.	#tag EndNote	#tag Note, Name = Chord Bitmask Spec		Index   Bit Value         Flag : Source		1*     :     1          : Type Major : ChordType_PM.ListIndex(1)		2      :     2          : Type Minor : ChordType_PM.ListIndex(2)		3      :     4          : Type Diminished : ChordType_PM.ListIndex(3)		4      :     8          : Type Augmented : ChordType_PM.ListIndex(4)		5      :     16         : 		6      :     32         : 		7      :     64         : 		8      :     128        : 		9*     :     256        : Modifier Suspended (Major chords only)		10     :     512        : Modifier Power		11     :     1024       : Modifier First Inversion		12     :     2048       : Modifier Second Inversion		13     :     4096       : Arpeggio Low to High		14     :     8192       : Arpeggio High to Low		15     :     16384      : 		16     :     32768      : 		17*    :     65536      : Extension Seventh Major		18     :     131072     : Extension Seventh Minor		19     :     262144     : Extension Ninth Major		20     :     524288     : Extension Ninth Minor		21     :     1048576    : Extension Eleventh Major		22     :     2097152    : Extension Eleventh Minor		23     :     4194304    : Extension Sixth Major		24     :     8388608    : Extension Sixth Minor		25*    :     16777216   : 		26     :     33554432   : Arpeggio MIDILib.kNoteLength_01		27     :     67108864   : Arpeggio MIDILib.kNoteLength_02		28     :     134217728  : Arpeggio MIDILib.kNoteLength_04		29     :     268435456  : Arpeggio MIDILib.kNoteLength_08		30     :     536870912  : Arpeggio MIDILib.kNoteLength_16		31     :     1073741824 : Arpeggio MIDILib.kNoteLength_32		32     :     2147483648 : Arpeggio MIDILib.kNoteLength_64				1 1		2 2		3 4		4 8		5 10		6 20		7 40		8 80		9 100		10 200		11 400		12 800		13 1000		14 2000		15 4000		16 8000		17 10000		18 20000		19 40000		20 80000		21 100000		22 200000		23 400000		24 800000		25 1000000		26 2000000		27 4000000		28 8000000		29 10000000		30 20000000		31 40000000		32 80000000	#tag EndNote	#tag Note, Name = Key Bitmask Spec		Index   Bit Value         Flag : Source		1*     :     1          : C		2      :     2          : C#/Db		3      :     4          : D		4      :     8          : D#/Eb		5      :     16         : E		6      :     32         : F		7      :     64         : F#/Gb		8      :     128        : G		9*     :     256        : G#/Ab		10     :     512        : A		11     :     1024       : A#/Bb		12     :     2048       : B		13     :     4096       :		14     :     8192       :		15     :     16384      :		16     :     32768      :		17*    :     65536      : Major		18     :     131072     : Minor		19     :     262144     : Harmonic Minor		20     :     524288     : Melodic Minor		21     :     1048576    : 		22     :     2097152    : 		23     :     4194304    : 		24     :     8388608    : 		25*    :     16777216   : Pentatonic Major		26     :     33554432   : Pentatonic Minor		27     :     67108864   :		28     :     134217728  :		29     :     268435456  :		30     :     536870912  :		31     :     1073741824 :		32     :     2147483648 :				1 1		2 2		3 4		4 8		5 10		6 20		7 40		8 80		9 100		10 200		11 400		12 800		13 1000		14 2000		15 4000		16 8000		17 10000		18 20000		19 40000		20 80000		21 100000		22 200000		23 400000		24 800000		25 1000000		26 2000000		27 4000000		28 8000000		29 10000000		30 20000000		31 40000000		32 80000000	#tag EndNote	#tag Constant, Name = kFlagChordArpeggiate_HighToLow, Type = Double, Dynamic = False, Default = \"&h2000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_01, Type = Double, Dynamic = False, Default = \"&h2000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_02, Type = Double, Dynamic = False, Default = \"&h4000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_04, Type = Double, Dynamic = False, Default = \"&h8000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_08, Type = Double, Dynamic = False, Default = \"&h10000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_16, Type = Double, Dynamic = False, Default = \"&h20000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_32, Type = Double, Dynamic = False, Default = \"&h40000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_Length_64, Type = Double, Dynamic = False, Default = \"&h80000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordArpeggiate_LowToHigh, Type = Double, Dynamic = False, Default = \"&h1000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Eleventh_Major, Type = Double, Dynamic = False, Default = \"&h100000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Eleventh_Minor, Type = Double, Dynamic = False, Default = \"&h200000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Ninth_Major, Type = Double, Dynamic = False, Default = \"&h40000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Ninth_Minor, Type = Double, Dynamic = False, Default = \"&h80000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Seventh_Major, Type = Double, Dynamic = False, Default = \"&h10000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Seventh_Minor, Type = Double, Dynamic = False, Default = \"&h20000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Sixth_Major, Type = Double, Dynamic = False, Default = \"&h400000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordExtension_Sixth_Minor, Type = Double, Dynamic = False, Default = \"&h800000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordModifier_FirstInv, Type = Double, Dynamic = False, Default = \"&h400", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordModifier_Power, Type = Double, Dynamic = False, Default = \"&h200", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordModifier_SecondInv, Type = Double, Dynamic = False, Default = \"&h800", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordModifier_Suspended, Type = Double, Dynamic = False, Default = \"&h100", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordType_Augmented, Type = Double, Dynamic = False, Default = \"&h8", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordType_Diminished, Type = Double, Dynamic = False, Default = \"&h4\r", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordType_Major, Type = Double, Dynamic = False, Default = \"&h1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagChordType_Minor, Type = Double, Dynamic = False, Default = \"&h2", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_Major, Type = Double, Dynamic = False, Default = \"&h10000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_Minor, Type = Double, Dynamic = False, Default = \"&h20000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_MinorHarmonic, Type = Double, Dynamic = False, Default = \"&h40000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_MinorMelodic, Type = Double, Dynamic = False, Default = \"&h80000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_PentatonicMajor, Type = Double, Dynamic = False, Default = \"&h1000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyMod_PentatonicMinor, Type = Double, Dynamic = False, Default = \"&h2000000", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_A, Type = Double, Dynamic = False, Default = \"&h200", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_AsharpBflat, Type = Double, Dynamic = False, Default = \"&h400", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_B, Type = Double, Dynamic = False, Default = \"&h800", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_C, Type = Double, Dynamic = False, Default = \"&h1", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_CsharpDflat, Type = Double, Dynamic = False, Default = \"&h2", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_D, Type = Double, Dynamic = False, Default = \"&h4", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_DsharpEflat, Type = Double, Dynamic = False, Default = \"&h8", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_E, Type = Double, Dynamic = False, Default = \"&h10", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_F, Type = Double, Dynamic = False, Default = \"&h20", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_FsharpGflat, Type = Double, Dynamic = False, Default = \"&h40", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_G, Type = Double, Dynamic = False, Default = \"&h80", Scope = Protected	#tag EndConstant	#tag Constant, Name = kFlagKeyType_GsharpAFlat, Type = Double, Dynamic = False, Default = \"&h100", Scope = Protected	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Module#tag EndModule