#tag ClassProtected Class ACSObj	#tag Method, Flags = &h0		Sub Constructor()		  if ACSRandom = nil then		    ACSRandom = new Random		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub CreateNoteLengthArray(LongestLength as NoteLength, ShortestLength as NoteLength, AllowTriplets as Boolean, AllowDotted as Boolean)		  Redim AllowedNoteLengths(-1)		  		  dim mLongestLength as integer = MIDILib.GetNoteLength(LongestLength)		  dim mShortestLength as integer = MIDILib.GetNoteLength(ShortestLength)		  		  dim NoteLengthValue_01 as integer = MIDILib.GetNoteLength(NoteLength.Value_01)		  dim NoteLengthValue_02 as integer = MIDILib.GetNoteLength(NoteLength.Value_02)		  dim NoteLengthValue_04 as integer = MIDILib.GetNoteLength(NoteLength.Value_04)		  dim NoteLengthValue_08 as integer = MIDILib.GetNoteLength(NoteLength.Value_08)		  dim NoteLengthValue_16 as integer = MIDILib.GetNoteLength(NoteLength.Value_16)		  dim NoteLengthValue_32 as integer = MIDILib.GetNoteLength(NoteLength.Value_32)		  dim NoteLengthValue_64 as integer = MIDILib.GetNoteLength(NoteLength.Value_64)		  dim NoteLengthvalue_01_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_01_triplet)		  dim NoteLengthvalue_02_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_02_triplet)		  dim NoteLengthvalue_04_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_04_triplet)		  dim NoteLengthvalue_08_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_08_triplet)		  dim NoteLengthvalue_16_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_16_triplet)		  dim NoteLengthvalue_32_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_32_triplet)		  dim NoteLengthvalue_64_triplet as integer = MIDILib.GetNoteLength(NoteLength.value_64_triplet)		  dim NoteLengthvalue_02_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_02_dotted)		  dim NoteLengthvalue_04_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_04_dotted)		  dim NoteLengthvalue_08_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_08_dotted)		  dim NoteLengthvalue_16_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_16_dotted)		  dim NoteLengthvalue_32_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_32_dotted)		  dim NoteLengthvalue_64_dotted as integer = MIDILib.GetNoteLength(NoteLength.value_64_dotted)		  		  if NoteLengthValue_01 <= mLongestLength and NoteLengthValue_01 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_01)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthvalue_01_triplet)		  		  if NoteLengthValue_02 <= mLongestLength and NoteLengthValue_02 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_02)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthvalue_02_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthvalue_02_dotted)		  		  if NoteLengthValue_04 <= mLongestLength and NoteLengthValue_04 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_04)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthValue_04_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthValue_04_dotted)		  		  if NoteLengthValue_08 <= mLongestLength and NoteLengthValue_08 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_08)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthValue_08_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthValue_08_dotted)		  		  if NoteLengthValue_16 <= mLongestLength and NoteLengthValue_16 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_16)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthValue_16_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthValue_16_dotted)		  		  if NoteLengthValue_32 <= mLongestLength and NoteLengthValue_32 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_32)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthValue_32_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthValue_32_dotted)		  		  if NoteLengthValue_64 <= mLongestLength and NoteLengthValue_64 >= mShortestLength then AllowedNoteLengths.Append(NoteLengthValue_64)		  if AllowTriplets then AllowedNoteLengths.Append(NoteLengthValue_64_triplet)		  if AllowDotted then AllowedNoteLengths.Append(NoteLengthValue_64_dotted)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub CreateRandomMelody(CharacteristicsWeight as integer, LengthVarianceLongest as NoteLength, LengthVarianceShortest as NoteLength, MelodyLengthNotes as integer, LengthAllowTriplets as boolean, LengthAllowDotted as boolean, MelodyLengthMeasures as integer, MelodyLengthUseNotes as Boolean, PitchVarianceMaxHi as integer, PitchVarianceMaxLo as integer, PitchVarianceHighestOctave as Octave, PitchVarianceLowestOctave as Octave)		  //calculate the number of notes or measures we're going to create		  		  //To Do:		  //Pitches need to be coming from the ParentWindow.SongMgr.Keys(0).Pitches array		  //handle when the first pitch isn't in the array		  //- get the closest note (up or down, doesn't matter) and handle from there.		  //handle when the first pitch is outside of the octave limits		  //- change the octave controls to encompass the first pitch upon opening		  //Move note Length Array out of loop		  		  //initialize note count		  dim thisNote as integer = 1		  dim firstNote as integer = 0		  dim lastNote as integer = 0		  		  dim totalBeats as integer = 0		  		  if MelodyLengthUseNotes then		    lastNote = MelodyLengthNotes		  else		    dim measureUnit as integer = ParentWindow.SongMgr.TimeSignatureBeatsPerMeasure * ParentWindow.SongMgr.TimeSignatureBasicBeat		    totalBeats = measureUnit * MelodyLengthMeasures		  end if		  		  //initialize the AllowedNoteLengths		  CreateNoteLengthArray(LengthVarianceLongest, LengthVarianceShortest, LengthAllowTriplets, LengthAllowDotted)		  		  //initialize all counts for tracking		  dim totalBeatCount as integer = 0		  dim stopFlag as Boolean = false		  dim lastNoteStartBeat as integer = 0		  dim currentStartBeat as integer = lastNoteStartBeat		  dim lastNotePitch as integer = 0 //needs to be zero proper math on the first loop iteration		  		  //check to see if a selection has been made		  if Ubound(ParentWindow.NoteMgr.Selection) > -1 then		    		  end if		  		  dim statusBarMaximum as integer = 0		  if MelodyLengthUseNotes then		    statusBarMaximum = lastNote		  else		    statusBarMaximum = totalBeats		  end if		  		  dim StatusWindow as WindowACSProgress = DisplayStatusBarWindow(statusBarMaximum)		  		  do		    		    dim noteStartBeat as integer = currentStartBeat + ParentWindow.PlayMgr.EditCursor.StartBeat		    dim notePitch as integer = 60		    dim noteLength as integer = 0		    		    dim changeAmount as integer = 0		    dim UpDownWeight as integer = ACSRandom.InRange(kRandomMelody_WeightMin, kRandomMelody_WeightMax)		    if UpDownWeight < CharacteristicsWeight then		      changeAmount = ACSRandom.InRange(0, PitchVarianceMaxLo)		    else		      changeAmount = ACSRandom.InRange(0, PitchVarianceMaxHi)		    end if		    notePitch = lastNotePitch + changeAmount		    		    //parse the pitch into the octaves		    dim highestPitch as integer = MusicLib.GetOctaveHighNote(PitchVarianceHighestOctave)		    notePitch = Min(notePitch, highestPitch)		    		    dim lowestPitch as integer = MusicLib.GetOctaveLowNote(PitchVarianceLowestOctave)		    notePitch = Max(notePitch, lowestPitch)		    		    //create length		    noteLength = CreateRandomNoteLength(LengthVarianceLongest, LengthVarianceShortest, LengthAllowTriplets, LengthAllowDotted)		    		    totalBeatCount = currentStartBeat + noteLength		    		    //create new note		    dim newNote as NoteObj = ParentWindow.NoteMgr.CreateNote(noteStartBeat, notePitch, noteLength)		    //add to track		    ParentWindow.TrackListObj1.CurrentTrack.AddObject(newNote)		    		    //check this iteration to see if we've hit the user's settings		    if MelodyLengthUseNotes then		      if thisNote = lastNote then 		        stopFlag = true		      end if		    else		      if totalBeatCount >= totalBeats then 		        stopFlag = true		      end if		    end if		    		    //set up for the next iteration		    lastNotePitch = notePitch		    currentStartBeat = currentStartBeat + noteLength		    thisNote = thisNote + 1		    if MelodyLengthUseNotes then		      StatusWindow.IncrementProgressBar(1)		    else		      StatusWindow.IncrementProgressBar(noteLength)		    end if		    		  loop until stopFlag = true		  		  StatusWindow.Hide		  WindowACSBasicSequence.Hide		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function CreateRandomNoteLength() As Integer		  dim firstNoteLength as integer = 2		  dim lastNoteLength as integer = 4		  dim newNoteLength as integer = MIDILib.kNoteLength_08		  		  dim noteLengthSelector as integer = ACSRandom.InRange(firstNoteLength, lastNoteLength)		  		  select case noteLengthSelector		  case 0		    newNoteLength = MIDILib.kNoteLength_01		  case 1		    newNoteLength = MIDILib.kNoteLength_02		  case 2		    newNoteLength = MIDILib.kNoteLength_04		  case 3		    newNoteLength = MIDILib.kNoteLength_08		  case 4		    newNoteLength = MIDILib.kNoteLength_16		  case 5		    newNoteLength = MIDILib.kNoteLength_32		  case 6		    newNoteLength = MIDILib.kNoteLength_64		  end select		  		  return newNoteLength		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function CreateRandomNoteLength(LongestLength as NoteLength, ShortestLength as NoteLength, AllowTriplets as Boolean, AllowDotted as Boolean) As Integer		  //method 1		  //the note length is a random number between the length limits in beats.		  //the note length is then parsed to the closest NoteLength.value_xx_y		  //a modifier is assigned randomly. If both modifiers are selected, randomly select one, and then randomly assign it.		  'dim longestLengthInBeats as integer = MIDILib.GetNoteLength(LongestLength)		  'dim shortestLengthInBeats as integer = MIDILib.GetNoteLength(ShortestLength)		  		  //method2		  //the note length is a random number assigned to each of the NoteLength.value_xx_y		  //Allowed NoteLength values are assigned to an array		  //the array is sorted		  //the array is shuffled		  //the first value in the array is selected		  		  if Ubound(AllowedNoteLengths) = -1 then return MIDILib.kNoteLength_08		  		  AllowedNoteLengths.Shuffle		  Return AllowedNoteLengths(0)		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function CreateRandomNotePitch(PreviousPitch as integer) As Integer		  dim pitchIndex as integer = ParentWindow.SongMgr.Keys(0).GetPitchIndex(PreviousPitch)		  		  dim varianceUp as integer = 4		  dim varianceDown as integer = -4		  		  dim pitchVariance as integer = ACSRandom.InRange(varianceDown, varianceUp)		  		  dim newPitchIndex as integer = pitchIndex + pitchVariance		  		  if newPitchIndex > Ubound(ParentWindow.SongMgr.Keys(0).Pitches) or newPitchIndex < 0 then		    newPitchIndex = pitchIndex		  end if		  		  return ParentWindow.SongMgr.Keys(0).Pitches(newPitchIndex)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub CreateSequencerSound()		  //see notes on this one to		  		  dim thisRound as integer = 1		  dim firstRound as integer = 1		  dim lastRound as integer = 50		  		  dim mStatusWindow as WindowACSProgress = DisplayStatusBarWindow(lastRound + 2)		  		  for thisRound = firstRound to lastRound		    MakeBasicRandomMelody		    mStatusWindow.IncrementProgressBar(1)		  next		  		  ParentWindow.NoteMgr.SelectAll		  		  mStatusWindow.IncrementProgressBar(1)		  		  ParentWindow.EditMgr.SetLength(MIDILib.kNoteLength_64)		  		  mStatusWindow.IncrementProgressBar(1)		  		  UpdateParentWindow		  		  mStatusWindow.Close		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function DisplayStatusBarWindow(MaxValue as integer) As WindowACSProgress		  StatusWindow = new WindowACSProgress		  StatusWindow.Show		  StatusWindow.ProgressBar1.Maximum = MaxValue		  return StatusWindow		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetStartNotePitch() As Integer		  dim middlePitchIndex as integer = ParentWindow.SongMgr.Keys(0).Pitches(UBound(ParentWindow.SongMgr.Keys(0).Pitches) \ 2)		  		  dim pitchIndexArray(-1) as integer		  		  dim thisHigherPitchIndex as integer = 0		  dim firstHigherPitchIndex as integer = middlePitchIndex + 1		  dim lastHigherPitchIndex as integer = middlePitchIndex + 5		  		  for thisHigherPitchIndex = firstHigherPitchIndex to lastHigherPitchIndex		    dim theHigherPitchIndex as integer = middlePitchIndex + thisHigherPitchIndex		    if theHigherPitchIndex > 0 and theHigherPitchIndex < UBound(ParentWindow.SongMgr.Keys(0).Pitches) then		      pitchIndexArray.Append(theHigherPitchIndex)		    end if		  next		  		  dim thisLowerPitchIndex as integer = 0		  dim firstLowerPitchIndex as integer = middlePitchIndex + 1		  dim lastLowerPitchIndex as integer = middlePitchIndex + 5		  		  for thisLowerPitchIndex = firstLowerPitchIndex to lastLowerPitchIndex		    dim theLowerPitchIndex as integer = middlePitchIndex + thisLowerPitchIndex		    if theLowerPitchIndex > 0 and theLowerPitchIndex < UBound(ParentWindow.SongMgr.Keys(0).Pitches) then		      pitchIndexArray.Append(theLowerPitchIndex)		    end if		  next		  		  dim newPitchIndex as integer = ParentWindow.SongMgr.Keys(0).Pitches(UBound(ParentWindow.SongMgr.Keys(0).Pitches) \ 2)		  		  if UBound(pitchIndexArray) <> -1 then		    pitchIndexArray.Sort		    dim highPitchIndex as integer = pitchIndexArray(0)		    dim lowPitchIndex as integer = pitchIndexArray(Ubound(pitchIndexArray))		    newPitchIndex = ACSRandom.InRange(highPitchIndex, lowPitchIndex)		  end if		  		  return newPitchIndex		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub MakeBasicRandomMelody()		  //get a starter note in the key's pitches		  dim lastNoteStartBeat as integer = 0		  dim lastNotePitch as integer = GetStartNotePitch		  dim lastNoteLength as integer = MIDILib.kNoteLength_08		  		  dim currentStartBeat as integer = lastNoteStartBeat		  		  dim thisNote as integer = 1		  dim firstNote as integer = 2		  dim lastNote as integer = 16		  		  'dim mStatusWindow as WindowACSProgress = DisplayStatusBarWindow(lastNote)		  		  for thisNote = firstNote to lastNote		    dim noteBeat as integer = currentStartBeat		    dim notePitch as integer = CreateRandomNotePitch(lastNotePitch)		    dim noteLength as integer = CreateRandomNoteLength		    		    dim theNote as NoteObj = ParentWindow.NoteMgr.CreateNote(noteBeat, notePitch, noteLength)		    		    ParentWindow.TrackListObj1.CurrentTrack.AddObject(theNote)		    		    currentStartBeat = noteBeat + noteLength		    		    'mStatusWindow.IncrementProgressBar(1)		  next		  		  UpdateParentWindow		  		  'mStatusWindow.IncrementProgressBar(1)		  		  'mStatusWindow.Close		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub UpdateParentWindow()		  ParentWindow.PlayMgr.SetStopCursorToEnd		  ParentWindow.WindowNeedsSaving = true		  ParentWindow.ResizeBars		  ParentWindow.GUIObj1.Draw		End Sub	#tag EndMethod	#tag Note, Name = Create Sequencer Sound		Create multiple rounds of note objects starting at predetermined SnapTos (1/4 - 1/16)		Select all notes created		Set all to 1/32 - 1/64 lengths		On each start beat, sort out which pitch has the highest number of notes.		Place a pre-determined intervaled note (say every 1/8 or 1/6) where that max count is.		On each start beat, based on the number of notes for each pitch, 		   remove the excess pitches and leave only one		   decrease the velocity based on the number of pitches.				Based on a single note		create multiple rounds of note object starting at predetermined SnapTos (1/4-1/16) but all on same pitch, granularity will have to change based on frequency		Options		[ ] Depth		[ ] Number of measures from Note.		[ ] Sequence Frequency (1/64, 1/32, 1/16)		[ ] Velocity variation				Based on a chord or multiple notes		create multiple rounds of note object starting at predetermined SnapTos (1/4-1/16), granularity will have to change based on frequency		Pitch variance based on random selection of pitches in selection		Options		[ ] Depth		[ ] Number of measures from EditCursor		[ ] sequence frequency (1/64, 1/32, 1/16)		[ ] Velocity Variation				Good Sequencer Sounds		18 Percussive Organ		87 Fifths Lead		88 Bass + Lead				13 Marimbas				   					#tag EndNote	#tag Note, Name = How this works		The ACS controls exist in the bottom of the window.		Sequences are generated or altered using a keyboard or button command. (CMD+R)	#tag EndNote	#tag Note, Name = New Sequence Generation		Get Settings		    NoteMgr		    MusicLib		Make Master Sequence (MasterSequenceObj)		    Check Up-Down Melody		    Check Large Jumps		    Check endless loop		Make Phrases (array of PhraseObj)		    Check Tritones		    Check Large Jumps		    Check endless loop		Combine Phrases (recursive?)		Output to NoteMgr (link notes together) (Array of notes in OutputObj)		Refresh	#tag EndNote	#tag Note, Name = Object Hierarchy		ACSObj		* Contains all of the parameter information used to generate the Master sequence and phrases.				\MasterSequenceObj				\PhraseObj				\OutputObj	#tag EndNote	#tag Note, Name = Options for Basic Note Sequence Generation		[ ] Pure Random		   [ ] Pitch		      [ ] Start Pitch		         [ ] If there is one selected, use that		         [ ] If there isn't one selected		            [ ] Highest octave		            [ ] Lowest octave		      [ ] Variance Up		         [ ] For both up and down, this could be based on basic melody theory (like no more than three, avoid 6's, and the like)		      [ ] Variance Down		      [ ] Highest Octave		      [ ] Lowest Octave		   [ ] Length		      [ ] Min Note Length		      [ ] Max Note Length		   [ ] Sequence		      [ ] Max Length		[ ] Sequencer Notes		   [ ] Include Pure Random Options		   [ ] Depth (Number of rounds of Pure Random) (50 is a good balance between depth and speed)		   [ ] Sequencer Interval (typically 1/8 - 1/16)		   [ ] Sequencer Step Length (typically 1/32 - 1/64)		   [ ] Optional Sequencer Melody		      [ ] Note Intervals		         [ ] Pitch		            [ ] Based on Highest/Lowest Velocities		         [ ] Length		            [ ] Based on Highest/Lowest Velocites		   [ ] Optional Object Management		      [ ] Put Sequencer Notes into a GroupObj		      [ ] Put Sequecner Notes into a RepeaterObj (v2)			#tag EndNote	#tag Note, Name = Parameters		Pitches		Base On		Mode (v2)		Scale		Pitch		    Randomly generated		    Pre-selected				Octave Range +n to -n or by Octave Numbers		Recommend Chords		Chord Progesssions				Values		Note value range		    Whole to 1/64				Rest Value Range		    Whole to 1/64		    % of rests at beginning, end, or random locations				Based on rhythm (v2)		    Shuffle		    Swing		    Bass based on rock beats				Notes		Number of pitches		Number of measures		    4 / 8 / 16 / 12 (blues)		Characteristics		    Upward		    Downward		Allow large jumps? (3+ half steps)		Allow Tritones		Allow accidentals				If it is in a pre-existing sequence, do we want to add or delete notes?	#tag EndNote	#tag Note, Name = Preexisting Sequence Alteration		MasterSequenceObj is held in ACS for reference later		NoteObj links to MasterSequenceObj		Note MUST be selected and in a sequence				Get Master Sequence		Analyze Notes/Sequence		Refactor Sequence based on new parameters.	#tag EndNote	#tag Note, Name = Scratch Text				NoteLength.Value_01		NoteLength.Value_02		NoteLength.Value_04		NoteLength.Value_08		NoteLength.Value_16		NoteLength.Value_32		NoteLength.Value_64				NoteLength.value_01_triplet		NoteLength.value_02_triplet		NoteLength.value_04_triplet		NoteLength.value_08_triplet		NoteLength.value_16_triplet		NoteLength.value_32_triplet		NoteLength.value_64_triplet				NoteLength.value_02_dotted		NoteLength.value_04_dotted		NoteLength.value_08_dotted		NoteLength.value_16_dotted		NoteLength.value_32_dotted		NoteLength.value_64_dotted					#tag EndNote	#tag Property, Flags = &h0		ACSRandom As Random	#tag EndProperty	#tag Property, Flags = &h21		Private AllowedNoteLengths(-1) As Integer	#tag EndProperty	#tag Property, Flags = &h0		ParentWindow As WindowEditor	#tag EndProperty	#tag Property, Flags = &h0		StatusWindow As WindowACSProgress	#tag EndProperty	#tag Constant, Name = kRandomMelody_MaxMeasures, Type = Double, Dynamic = False, Default = \"100", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_MaxNotes, Type = Double, Dynamic = False, Default = \"1000", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_MinLength, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_PitchVarianceMaxHi, Type = Double, Dynamic = False, Default = \"12", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_PitchVarianceMaxLo, Type = Double, Dynamic = False, Default = \"-12", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_PitchVarianceMinHi, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_PitchVarianceMinLo, Type = Double, Dynamic = False, Default = \"-1", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_WeightMax, Type = Double, Dynamic = False, Default = \"50", Scope = Public	#tag EndConstant	#tag Constant, Name = kRandomMelody_WeightMin, Type = Double, Dynamic = False, Default = \"-50", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass