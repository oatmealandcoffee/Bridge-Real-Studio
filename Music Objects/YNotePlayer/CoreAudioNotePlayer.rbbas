#tag ClassProtected Class CoreAudioNotePlayerImplements NotePlayerInterface	#tag Method, Flags = &h0		Sub Constructor()		  dim renderFlags,outSize as MemoryBlock		  dim busIndex as integer		  		  dim synthUnit as memoryBlock		  dim usesReverb as MemoryBlock		  dim err as integer		  		  'struct ComponentDescription {		  'OSType componentType;		  'OSType componentSubType;		  'OSType componentManufacturer;		  'unsigned long componentFlags;		  'unsigned long componentFlagsMask;		  '};		  		  		  err = 0		  		  //create the AUGraph		  graph=NewMemoryBlock(4)		  graph.long(0) = 0		  err = SNewAUGraph		  Display "SANewAUGraph = "+str(err)		  		  //open the DLS Synth 		  description = newMemoryBlock(20)		  description.long(0) = OSTypeToLong(kAudioUnitComponentType)//Type		  description.long(4) = OSTypeToLong(kAudioUnitSubType_MusicDevice)//SubType		  description.long(8) = OSTypeToLong(kAudioUnitID_DLSSynth)//Mfg		  description.long(12) =  0//Flags		  description.long(16) = 0//FlagsMask		  synthNode = NewMemoryBlock(4)		  synthNode.long(0) = 0		  err = SAUGraphNewNode(graph, description, 0, 0, synthNode)		  Display "SAUGraphNewNode synthNode = "+str(err)		  		  // Open the filter		  'description.long(0) = OSTypeToLong(kAudioUnitComponentType)//Type		  'description.long(4) = OSTypeToLong(kAudioUnitSubType_Effect)//SubType		  'description.long(8) = OSTypeToLong(kAudioUnitID_Delay)//kAudioUnitID_LowPassFilter)//Mfg		  'description.long(12) =  0//Flags		  'description.long(16) = 0//FlagsMask		  'filterNode = NewMemoryBlock(4)		  'filterNode.long(0) = 0		  'err = SAUGraphNewNode(graph, description, 0, 0, filterNode)		  'Display "SAUGraphNewNode filterNode = "+str(err)		  '#define kAudioUnitID_MatrixReverb   'mrev'		  '#define kAudioUnitID_Delay     'dely'		  '#define kAudioUnitID_LowPassFilter   'lpas'		  '#define kAudioUnitID_HighPassFilter  'hpas'		  '#define kAudioUnitID_BandPassFilter  'bpas'		  '#define kAudioUnitID_PeakLimiter   'lmtr'		  '#define kAudioUnitID_DynamicsProcessor  'dcmp'		  		  // Open the output device		  'description = newMemoryBlock(20)		  description.long(0) = OSTypeToLong(kAudioUnitComponentType)//Type		  description.long(4) = OSTypeToLong(kAudioUnitSubType_Output)//SubType		  description.long(8) = OSTypeToLong(kAudioUnitID_DefaultOutput)//Mfg		  description.long(12) =  0//Flags		  description.long(16) = 0//FlagsMask		  outputNode = NewMemoryBlock(4)		  outputNode.long(0) = 0		  err = SAUGraphNewNode(graph, description, 0, 0, outputNode)		  Display "SAUGraphNewNode outputNode = "+str(err)		  		  // Connect the devices up (with delay unit)		  'err = SAUGraphConnectNodeInput(graph,synthNode,1,filterNode,0)		  'Display "SAUGraphConnectNodeInput synth->filter = "+str(err)		  'err = SAUGraphConnectNodeInput(graph,filterNode,0,outputNode,0)		  'Display "SAUGraphConnectNodeInput filter->output = "+str(err)		  'err = SAUGraphUpdate(graph)		  'Display "SAUGraphUpdate = "+str(err)		  		  // Connect the devices up		  err = SAUGraphConnectNodeInput(graph,synthNode,1,outputNode,0)		  Display "SAUGraphConnectNodeInput synth->filter = "+str(err)		  'err = SAUGraphConnectNodeInput(graph,filterNode,0,outputNode,0)		  'Display "SAUGraphConnectNodeInput filter->output = "+str(err)		  err = SAUGraphUpdate(graph)		  Display "SAUGraphUpdate = "+str(err)		  		  // Open and initialize the audio units		  err = SAUGraphOpen(graph)		  Display "SAUGraphOpen = "+str(err)		  err = SAUGraphInitialize(graph)		  Display "SAUGraphInitialize = "+str(err)		  		  		  #if kErr then		    // Turn off the reverb on the synth 		    'outDescription = newmemoryBlock(4)		    'outDescription.long(0) = 0		    'outClassDataSize = newmemoryBlock(4)		    'outClassData = newmemoryBlock(4)		    'outClassData.long(0) = 0		    		    synthUnit = newmemoryBlock(4)		    err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		    usesReverb = newmemoryBlock(4)		    		    //theAudioUnit as memoryBlock, inID as integer, inScope as integer, 		    //inElement as integer, outData as memoryBlock, ioDataSize as memoryblock		    		    'err = SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global, 0, usesReverb, 4)		    		    		    		    'usesReverb.long(0) = 0		    usesReverb.UInt32Value(0) = 0		    'usesReverb.UInt32Value(0) = 1		    err = SAudioUnitSetProperty(synthUnit, kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global, 0, usesReverb, 4)		    'err = SAudioUnitSetProperty(synthUnit, kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global, 1, usesReverb, 4)		    Display "reverb SAudioUnitSetProperty = "+str(err)		    		    // turn off internal reverb		    'AudioUnitSetProperty(theSynth, kMusicDeviceProperty_UsesInternalReverb,		    'kAudioUnitScope_Global, 0, &reverb, sizeof(UInt32));		    		    		    'UInt32    render_flags_3d;		    'UInt32    outSize = sizeof(render_flags_3d);		    		    		    renderFlags=NewMemoryBlock(4)		    outSize=NewMemoryBlock(4)		    		    		    busIndex = 0		    		    // get the current render flags for this bus		    'result = AudioUnitGetProperty (mMixerUnit,		    'kAudioUnitProperty_3DMixerRenderingFlags,		    'kAudioUnitScope_Input,		    'busIndex,		    '&render_flags_3d,		    '&outSize);		    		    //theAudioUnit as memoryBlock, inID as integer, inScope as integer, inElement as integer, outData as memoryBlock, ioDataSize as memoryblock		    'outSize.long(0) = 4 		    'err = SAudioUnitGetProperty (synthUnit,kAudioUnitProperty_3DMixerRenderingFlags,kAudioUnitScope_Input,busIndex,renderFlags,outSize)		    		    		    // turn on this render flag and then set the bus		    'render_flags_3d |= k3DMixerRenderingFlags_DistanceDiffusion;		    'result = AudioUnitSetProperty(    mMixerUnit,		    'kAudioUnitProperty_3DMixerRenderingFlags,		    'kAudioUnitScope_Input, busIndex,		    '&render_flags_3d,		    'sizeof(render_flags_3d));		    		    'err = SAudioUnitSetProperty(synthUnit, kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global, 0, usesReverb, 4)		    		  #endif		  		  'enum {		  'k3DMixerRenderingFlags_InterAuralDelay			= (1L << 0),		  'k3DMixerRenderingFlags_DopplerShift				= (1L << 1),		  'k3DMixerRenderingFlags_DistanceAttenuation		= (1L << 2),		  'k3DMixerRenderingFlags_DistanceFilter			= (1L << 3),		  'k3DMixerRenderingFlags_DistanceDiffusion		= (1L << 4)		  '};		  		  // turn off internal reverb		  'AudioUnitSetProperty(theSynth, kMusicDeviceProperty_UsesInternalReverb,		  'kAudioUnitScope_Global, 0, &reverb, sizeof(UInt32));		  		  		  		  //LOOK IN AudioUnitProperties.h for these constants:		  //kMusicDeviceProperty_UsesInternalReverb   = kAudioUnitProperty_UsesInternalReverb		  //kAudioUnitProperty_UsesInternalReverb   = 1005,		  		  '// Start playing		  err = SAUGraphStart(graph)		  Display "SAUGraphStart = "+str(err)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  Dispose		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Sub Display(s as string)		  // A debugging method.  We might remove this at some point.		  		  #if DebugBuild then		    'System.debuglog s 		  #endif		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Sub Dispose()		  Declare Function AUGraphStop Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  Declare Function DisposeAUGraph Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  		  dim err as integer		  		  err = SAUGraphStop(graph)		  Display "SAUGraphStop = "+str(err)		  		  'err = DisposeAUGraph (graph)		  'Display "DisposeAUGraph = "+str(err)		  		  'graph.long(0) = 0		  		  // Note from Joe: the above DisposeAUGraph call was commented out in the		  // code received from Erick.  Not yet sure why.		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function GetInstrument() As Integer		  // Part of the NotePlayerInterface interface.		  		  return curInstrument		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function InstrumentCount() As integer		  // Get a count of the instruments in the currently loaded file		  // (or in the built-in set).		  		  dim err as integer		  dim synthUnit as MemoryBlock		  		  //get the synth AudioUnit 		  synthUnit = newmemoryBlock(4)		  err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  		  dim size,count as MemoryBlock//count		  count = newmemoryBlock(4)		  size = newmemoryBlock(4)		  count.long(0) = 0		  size.long(0) = 4//the size will be a long (4 bytes)		  err = SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_InstrumentCount, kAudioUnitScope_Global, 0, count, size)		  		  if err = 0 then		    return count.long(0)		  else		    return 0		  end if		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function InstrumentID(instIndex As Integer) As Integer		  // Get the Instrument ID for a given instrument index.		  		  // get the synth AudioUnit		  Dim synthUnit As New MemoryBlock(4)		  call SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  		  // Get the InstrumentID for this instrument index		  Dim instrumentID As New MemoryBlock(4)		  Dim size As New MemoryBlock(4)		  size.long(0) = 4//the size will be a long (4 bytes)		  call SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_InstrumentNumber, _		  kAudioUnitScope_Global, instindex, instrumentID, size)		  		  return instrumentID.Long(0)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function InstrumentNameByIndex(instIndex as integer) As string		  // Get the name of an instrument, by its index.		  		  dim err as integer		  dim instrumentID,instrumentName,size as MemoryBlock		  dim synthUnit as MemoryBlock		  		  // get the synth AudioUnit		  synthUnit = newmemoryBlock(4)		  err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  		  // Get the InstrumentID for this instrument index 		  instrumentID = newmemoryBlock(4)		  size = newmemoryBlock(4)		  size.long(0) = 4//the size will be a long (4 bytes)		  err = SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_InstrumentNumber, kAudioUnitScope_Global, instindex, instrumentID, size)		  		  instrumentName = newmemoryBlock(256)		  size = newmemoryBlock(4)		  size.long(0) = 256		  err = SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_InstrumentName, kAudioUnitScope_Global, instrumentID.long(0), instrumentName, size)		  'display " name instrumentID.long(0))="+str(instrumentID.long(0))		  return instrumentName.Cstring(0)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function LoadInstrument(f as folderItem) As integer		  // Load a SF2 or DLS file, in order to play instrument(s) from that.		  		  Declare Function FSMakeFSSpec Lib CarbonLib (vRefNum as Short, dirID as Integer, filename as Pstring, spec as Ptr) as Short		  		  dim err as integer		  dim fileName as String		  dim synthUnit, fsSpec as MemoryBlock		  		  Const noError = 0		  Const fileNotFound = -43		  		  //get the synth AudioUnit (we probably already have this from the constructor, but let's load again, just to be snazzy)		  synthUnit = newmemoryBlock(4)		  err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  		  if f<>nil then		    if f.exists then		      fsSpec=NewMemoryBlock(70)		      		      filename = ConvertEncoding(f.Name, Encodings.SystemDefault)		      err = FSMakeFSSpec(f.MacVRefNum, f.MacDirID, fileName, fsSpec)		      		      if (err = fileNotFound) then		        Display ("CANotePlayer.LoadInstrument fileNotFound")		      end if		      		      If err = noError or err = fileNotFound then		        //************************************************************************************************************************		        //  MAJOR LEOPARD/UB FIX : Leopard insists that we stop the graph before we use AudioUnitSetProperty		        //  if we don't, it will crash a mighty crash. I wonder if this will work on Tiger too 		        //  perhaps this start stop stuff should go in the SAudioUnitSetProperty method instead 		        //************************************************************************************************************************		        err = SAUGraphStop(graph)		        if err = noError then		          //load the soundbank 		          err = SAudioUnitSetProperty(synthUnit, kMusicDeviceProperty_SoundBankFSSpec, kAudioUnitScope_Global, 0, fsSpec, 69)		          if err = noError then		            //now restart the graph 		            err = SAUGraphStart(graph)		            if err = noError then		              //success! 		            else		              Display ("CANotePlayer.LoadInstrument SAUGraphStart err : ") + str(err)		            end if		          else 		            Display ("CANotePlayer.LoadInstrument SAudioUnitSetProperty err : ") + str(err)		          end if		        else 		          Display ("CANotePlayer.LoadInstrument SAUGraphStop err : ") + str(err)		        end if		        //************************************************************************************************************************		        		        		      Else 		        'Raise newMacOSException("FSMakeFSSpec", OSError)		        Display "CANotePlayer.LoadInstrument FSMakeFSSpec OSError : " + str(err)		      End if		      		    end if 		  end if 		  		  return err 		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function OSTypeToLong(theOSType as string) As Integer		  		  Dim i, theLong, aChar, thePower As Integer		  Dim s As String		  		  if Len(theOSType)<>4 then		    return -1		  end if		  theLong=0		  aChar=0		  thePower=0		  for i=4 downTo 1		    aChar=Asc(Mid(theOSType, i, 1))		    theLong=theLong+(aChar*(Pow(256, thePower)))		    thePower=thePower+1		  next		  return theLong		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub PlayNote(pitch As Integer, velocity As Integer)		  // Part of the NotePlayerInterface interface.		  		  System.DebugLog "PlayNote:"		  		  dim err as integer		  		  // Simple way (and works on more MIDI devices):		  //err = SMusicDeviceMIDIEvent( &h90, pitch, velocity, curChannel)		  		  // Alternate way -- works only on some, but provides more control:		  Dim dpitch As Single		  if pitch < 256 then		    dpitch = pitch		  else		    dpitch = pitch / 256.0		  end if		  if velocity = 0 then		    Dim idx As Integer = pitchesPlaying.IndexOf( dpitch )		    if idx <> -1 then		      dpitch = notesPlaying( idx )		      'dpitch = notesStarted.Lookup( dpitch, dpitch )		      err = SMusicDeviceStopNote( curChannel, dpitch )		      System.DebugLog "Stopped note " + Str( dpitch ) _		      + " in channel " + Str( curChannel ) + " (result code = " + Str( err ) + ")"		      pitchesPlaying.Remove idx		      notesPlaying.Remove idx		    end if		  else		    Dim instrumentID As Integer = curInstrument - 1		    if curInstrument = 16385 then instrumentID = 0		    err = SMusicDeviceStartNote( instrumentID, curChannel, dpitch, velocity )		    'System.DebugLog "Looking up double value " + Str( dpitch )		    'System.DebugLog "Started note " + notesStarted.Value( dpitch ) + " (from " + Str( dpitch ) + ")" _		    '+ " in channel " + Str( curChannel ) + " (result code = " + Str( err ) + ")"		  end if		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAudioUnitGetProperty(theAudioUnit as memoryBlock, inID as integer, inScope as integer, inElement as integer, outData as memoryBlock, ioDataSize as memoryblock) As integer		  'AudioUnitGetProperty 		  '(AudioUnit  ci,  		  'AudioUnitPropertyID  inID,  		  'AudioUnitScope  inScope,  		  'AudioUnitElement  inElement,  		  'void * outData,  		  'UInt32 * ioDataSize);		  		  Declare Function AudioUnitGetProperty  _		  Lib kAudioUnitLib  _		  (theAudioUnit as Ptr, inID as integer, inScope as integer, inElement as integer, outData as Ptr, ioDataSize as Ptr) as integer		  return AudioUnitGetProperty(theAudioUnit.ptr(0), inID, inScope, inElement, outData, ioDataSize)		  		  'result = AudioUnitGetProperty (		  'synthUnit, kMusicDeviceProperty_InstrumentCount,		  'kAudioUnitScope_Global, 0,		  '(void*)&count, &size		  ');		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAudioUnitSetProperty(theAudioUnit as memoryBlock, inID as integer, inScope as integer, inElement as integer, inData as memoryBlock, inDataSize as integer) As integer		  		  		  Declare Function AudioUnitSetProperty  _		  Lib kAudioUnitLib  _		  (theAudioUnit as Ptr, inID as integer, inScope as integer, inElement as integer, inData as Ptr, inDataSize as integer) as integer		  		  if theAudioUnit<>nil then		    Display "SAudioUnitSetProperty theAudioUnit<>nil "+str(theAudioUnit.Size)		  end if		  		  if inData<>nil then		    Display "SAudioUnitSetProperty inData<>nil"+str(inData.Size)		  end if		  		  Display "SAudioUnitSetProperty inID = "+str(inID)		  Display "SAudioUnitSetProperty inScope = "+str(inScope)		  Display "SAudioUnitSetProperty inElement = "+str(inElement)		  Display "SAudioUnitSetProperty inDataSize = "+str(inDataSize)		  		  return AudioUnitSetProperty(theAudioUnit.ptr(0), inID, inScope, inElement, inData, inDataSize)		  		  //LOOK IN AudioUnitProperties.h for these constants:		  //kMusicDeviceProperty_UsesInternalReverb   = kAudioUnitProperty_UsesInternalReverb		  //kAudioUnitProperty_UsesInternalReverb   = 1005,		  		  //example from SimpleSynth:		  'AudioUnitSetProperty (		  'synthUnit,		  'kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global,		  '0,		  '&usesReverb, sizeof (usesReverb)		  ');		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphConnectNodeInput(inGraph as memoryBlock, srcNode as memoryBlock, inSourceOutputNumber as integer, destNode as memoryBlock, inDestInputNumber as integer) As integer		  		  'AUGraphConnectNodeInput		  'extern OSStatus AUGraphConnectNodeInput(		  'AUGraph inGraph, 		  'AUNode inSourceNode, 		  'UInt32 inSourceOutputNumber, 		  'AUNode inDestNode, 		  'UInt32 inDestInputNumber		  ');		  Declare Function AUGraphConnectNodeInput  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr, inSourceNode as Ptr, inSourceOutputNumber as integer, inDestNode as Ptr, inDestInputNumber as integer) as integer		  return AUGraphConnectNodeInput(inGraph.Ptr(0), srcNode.Ptr(0), inSourceOutputNumber, destNode.Ptr(0), inDestInputNumber)		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphGetNodeInfo(inGraph as memoryblock, inNode as memoryblock, outDescription as integer, outClassDataSize as integer, outClassData as integer, outAudioUnit as memoryblock) As integer		  		  'extern OSStatus AUGraphGetNodeInfo(		  'AUGraph inGraph, 		  'AUNode inNode, 		  'ComponentDescription *outDescription, 		  'UInt32 *outClassDataSize, 		  'void **outClassData, 		  'AudioUnit *outAudioUnit		  ');		  		  Declare Function AUGraphGetNodeInfo  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr, inNode as Ptr, outDescription as integer, outClassDataSize as integer, outClassData as integer, outAudioUnit as Ptr) as integer		  		  return AUGraphGetNodeInfo(inGraph.Ptr(0), inNode.Ptr(0), outDescription, outClassDataSize, outClassData, outAudioUnit)		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphInitialize(inGraph as MemoryBlock) As integer		  		  //extern OSStatus AUGraphInitialize(AUGraph inGraph);		  Declare Function AUGraphInitialize  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  return AUGraphInitialize(inGraph.Ptr(0))		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphNewNode(inGraph as memoryBlock, inDescription as MemoryBlock, inClassDataSize as integer, inClassData as integer, outNode as memoryBlock) As integer		  		  'extern OSStatus AUGraphNewNode(		  'AUGraph inGraph, 		  'const ComponentDescription *inDescription, 		  'UInt32 inClassDataSize, 		  'const void *inClassData, 		  'AUNode *outNode		  ');		  Declare Function AUGraphNewNode  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr, inDescription as Ptr, inClassDataSize as integer, inClassData as integer, outNode as Ptr) as integer		  return AUGraphNewNode(inGraph.Ptr(0), inDescription, inClassDataSize, inClassData, outNode)		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphOpen(inGraph as MemoryBlock) As integer		  //extern OSStatus AUGraphOpen(AUGraph inGraph);		  Declare Function AUGraphOpen  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  return AUGraphOpen( inGraph.Ptr(0) )		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphStart(inGraph as MemoryBlock) As Integer		  //extern OSStatus AUGraphStart(AUGraph inGraph);		  Declare Function AUGraphStart  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  return AUGraphStart( inGraph.Ptr(0) )		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphStop(inGraph as MemoryBlock) As integer		  Declare Function AUGraphStop  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr) as integer		  		  return AUGraphStop( inGraph.Ptr(0) )		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Shared Function SAUGraphUpdate(inGraph as memoryBlock) As integer		  'extern OSStatus AUGraphUpdate(		  'AUGraph inGraph, 		  'Boolean *outIsUpdated		  ');		  Declare Function AUGraphUpdate  _		  Lib kAudioToolboxLib  _		  (inGraph as Ptr, outIsUpdated as integer) as integer		  return AUGraphUpdate(inGraph.Ptr(0), 0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub SetInstrument(instrument As Integer)		  // Part of the NotePlayerInterface interface.		  // Note that NotePlayer notes are 1-based, so we must subtract one		  // to get the internal MIDI instrument number.		  		  curInstrument = instrument		  		  if instrument = 16385 then		    // special case: drum kit, implies channel 9 (and instrument 0)		    curChannel = 9		    instrument = 0		  else		    curChannel = 0		    instrument = instrument - 1		  end if		  		  dim err as integer		  		  Dim bankSelectMSB As Integer = Bitwise.BitAnd(Bitwise.ShiftRight(instrument, 16, 32), &h7F)		  Dim bankSelectLSB As Integer = Bitwise.BitAnd(Bitwise.ShiftRight(instrument, 8, 32), &h7F)		  Dim programChange As Integer = Bitwise.BitAnd(instrument, &h7F)		  		  err = SMusicDeviceMIDIEvent( &hB0, 0, bankSelectMSB, curChannel )		  err = SMusicDeviceMIDIEvent( &hB0, 0, bankSelectLSB, curChannel )		  err = SMusicDeviceMIDIEvent( &hC0, programChange, 0, curChannel )		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetInstrument(instIndex as integer, channel as integer)		  		  dim err as integer		  dim instrumentID,size as MemoryBlock		  dim synthUnit as MemoryBlock		  dim instrument as MemoryBlock		  		  //get the synth AudioUnit		  synthUnit = newmemoryBlock(4)		  err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  'display "setinst : get the synth AudioUnit="+str(err)		  		  //Get the InstrumentID for this instrument index 		  instrumentID = newmemoryBlock(4)		  size = newmemoryBlock(4)		  size.long(0) = 4//the size will be a long (4 bytes)		  err = SAudioUnitGetProperty(synthUnit, kMusicDeviceProperty_InstrumentNumber, _		  kAudioUnitScope_Global, instindex, instrumentID, size)		  'display "setinst : Get the InstrumentID for this instrument index ="+str(err)		  		  'MsgBox "instrumentID.long(0)="+str(instrumentID.long(0))		  		  instrument=newmemoryBlock(3)		  'instrument.byte(0) = 128//Bitwise.BitAnd(Bitwise.ShiftRight(instrumentID.long(0),16,32),&h7F)//bankSelectMSB		  'instrument.byte(1) = 0//Bitwise.BitAnd(Bitwise.ShiftRight(instrumentID.long(0),8,32),&h7F)//bankSelectLSB		  'instrument.byte(2) = 1//Bitwise.BitAnd(instrumentID.long(0),&h7F)//programChange		  		  instrument.byte(0) = Bitwise.BitAnd(Bitwise.ShiftRight(instrumentID.long(0),16,32),&h7F)//bankSelectMSB		  instrument.byte(1) = Bitwise.BitAnd(Bitwise.ShiftRight(instrumentID.long(0),8,32),&h7F)//bankSelectLSB		  instrument.byte(2) = Bitwise.BitAnd(instrumentID.long(0),&h7F)//programChange		  		  		  'SMusicDeviceMIDIEvent(inStatus as integer,inData1 as integer,inData2 as integer, channel as integer)		  'err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(0),0)		  'err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(1),0)		  'err = SMusicDeviceMIDIEvent(&hC0, instrument.byte(2),0,0)		  		  err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(0),channel)		  err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(1),channel)		  err = SMusicDeviceMIDIEvent(&hC0, instrument.byte(2),0,channel)		  		  'err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(0),9)		  'err = SMusicDeviceMIDIEvent(&hB0, 0, instrument.byte(1),9)		  'err = SMusicDeviceMIDIEvent(&hC0, instrument.byte(2),0,9)		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h1		Protected Function SMusicDeviceMIDIEvent(inStatus as integer,inData1 as integer,inData2 as integer, channel as integer) As Integer		  		  		  'for (ch = 0; ch < 16; ch++)		  '>       sts = SMusicDeviceMIDIEvent(gMusicDev, 0x90 + ch, 60 + ch, 127, 0);		  '>     sleep(10);		  '>     for (ch = 0; ch < 16; ch++)		  '>       sts = SMusicDeviceMIDIEvent(gMusicDev, 0x80 + ch, 60 + ch, 127, 0);		  		  '0x90=144		  		  		  'EXTERN_API( ComponentResult )		  'MusicDeviceMIDIEvent(		  'MusicDeviceComponent   ci,		  'UInt32                 inStatus,		  'UInt32                 inData1,		  'UInt32                 inData2,		  'UInt32                 inOffsetSampleFrame)                 FIVEWORDINLINE(0x2F3C, 0x0010, 0x0101, 0x7000, 0xA82A);		  		  		  //extern OSStatus NewAUGraph(AUGraph *outGraph);		  Declare Function MusicDeviceMIDIEvent  _		  Lib kAudioUnitLib _		  (inGraph as Ptr, inStatus as integer,inData1 as integer,inData2 as integer,inOffSetSampleFrame as integer) as integer		  		  		  'inGraph as memoryblock, 		  'inNode as memoryblock, 		  'outDescription as memoryblock, 		  'outClassDataSize as memoryblock, 		  'outClassData as memoryblock, 		  'outAudioUnit as memoryblock		  		  dim err as integer		  'dim outDescription as memoryblock		  'dim outClassDataSize as memoryblock		  'dim outClassData as memoryblock		  dim synthUnit as MemoryBlock		  		  'outDescription = newmemoryBlock(4)		  'outDescription.long(0) = 0		  'outClassDataSize = newmemoryBlock(4)		  'outClassDataSize.long(0) = 0		  'outClassData = newmemoryBlock(4)		  'outClassData.long(0) = 0		  		  //get the synth AudioUnit 		  synthUnit = newmemoryBlock(4)		  err = SAUGraphGetNodeInfo (graph, synthNode, 0,0,0, synthUnit)		  		  'return MusicDeviceMIDIEvent(synthUnit.Ptr(0), 144,60,127,0)		  return MusicDeviceMIDIEvent(synthUnit.Ptr(0), inStatus+channel,inData1+channel,inData2,0)		  		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function SMusicDeviceStartNote(instrumentID As Integer, channel As Integer, pitch As Double, velocity As Single) As Integer		  // Reference: MusicDevice.h (part of AudioUnit.framework)		  		  //-----------------------------------------------------------------------------		  //    MusicDeviceNoteParams		  //		  //    This is the structure that should be used as the		  //    const MusicDeviceNoteParams  *inParams argument with MusicDeviceStartNote.		  //		  //    This argument has 2 flavours		  //    (1) MusicDeviceStdNoteParams		  //        where argCount is 2, and the first argument is pitch (defined as		  //        0 < 128 MIDI NoteNum), the second velocity (0 < 128)		  //		  //    (2) ExtendedNoteParams		  //        where argCount is 2 + the number of contained		  //        NoteParamsControlValue structures - so the size of the mControls		  //        array is (argCount - 2)		  //-----------------------------------------------------------------------------		  '		  'struct NoteParamsControlValue		  '{		  '   UInt32                            mID;		  '   Float32                            mValue;		  '};		  'typedef struct NoteParamsControlValue        NoteParamsControlValue;		  '		  'struct MusicDeviceNoteParams		  '{		  '   UInt32                            argCount;		  '   Float32                            mPitch;		  '   Float32                            mVelocity;		  '   NoteParamsControlValue            mControls[1];                /* arbitrary length */		  '};		  'typedef struct MusicDeviceNoteParams    MusicDeviceNoteParams;		  		  Dim noteParams As New MemoryBlock( 28 )		  noteParams.UInt32Value( 0 ) = 2  // argCount		  noteParams.SingleValue( 4 ) = pitch   // mPitch (OK to have fractional values here!)		  noteParams.SingleValue( 8 ) = velocity		  		  '/*		  'The instrumentID that is passed in to the MusicDeviceStartNote can		  'specify a specific intrument ID. The constant		  'kMusicNoteEvent_UseGroupInstrument can alternatively be passed to use		  'the current instrument defined for that group. In MIDI this is the		  'typical usage of a bank and patch set for a specific channel where		  'all notes that start on that channel use that instrument.		  '*/		  'enum {		  'kMusicNoteEvent_UseGroupInstrument = 0xFFFFFFFF		  '};		  '		  '		  'typedef UInt32                          MusicDeviceGroupID;		  'typedef UInt32                          NoteInstanceID;		  'typedef ComponentInstance               MusicDeviceComponent;		  '		  		  'extern ComponentResult MusicDeviceStartNote(		  '  MusicDeviceComponent                ci,		  '  MusicDeviceInstrumentID                inInstrument,		  '  MusicDeviceGroupID                    inGroupID,		  '  NoteInstanceID *                    outNoteInstanceID,		  '  UInt32                                inOffsetSampleFrame,		  '  const MusicDeviceNoteParams *         inParams)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;		  		  		  Declare Function MusicDeviceStartNote Lib kAudioUnitLib ( _		  synthUnit as Ptr, _		  instrumentID as UInt32, _		  groupID as UInt32, _		  ByRef outNoteInstanceID as Integer, _		  inOffsetSampleFrame as UInt32, _		  inParams As Ptr) as Integer		  		  Dim err as integer		  		  // get the synth AudioUnit		  Dim synthUnit as New MemoryBlock(4)		  err = SAUGraphGetNodeInfo( graph, synthNode, 0, 0, 0, synthUnit )		  		  // start the note		  Dim midiPitch As Integer = pitch		  err = MusicDeviceStartNote( synthUnit.Ptr(0) , instrumentID, channel, midiPitch, 0, noteParams )		  System.DebugLog "SMusicDeviceStartNote started note " + Str( midiPitch ) + " (from " + Str( pitch ) + ")"		  		  if err = 0 then		    if notesStarted is nil then notesStarted = New Dictionary		    notesStarted.Value( pitch ) = midiPitch		    System.DebugLog "Stored dict value under double " + Str( pitch )		    pitchesPlaying.Append pitch		    notesPlaying.Append midiPitch		  end if		  		  return err		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function SMusicDeviceStopNote(channel As Integer, pitch As Single) As Integer		  // Reference: MusicDevice.h (part of AudioUnit.framework)		  		  		  'typedef UInt32                          MusicDeviceGroupID;		  'typedef UInt32                          NoteInstanceID;		  'typedef ComponentInstance               MusicDeviceComponent;		  '		  		  		  'extern ComponentResult MusicDeviceStopNote( 		  '  MusicDeviceComponent    ci,		  '  MusicDeviceGroupID        inGroupID,		  '  NoteInstanceID            inNoteInstanceID,		  '  UInt32                    inOffsetSampleFrame)                AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER;		  		  		  Declare Function MusicDeviceStopNote Lib kAudioUnitLib ( _		  synthUnit as Ptr, _		  groupID as UInt32, _		  inNoteInstanceID as Integer, _		  inOffsetSampleFrame as UInt32) as Integer		  		  Dim err as integer		  		  // get the synth AudioUnit		  Dim synthUnit as New MemoryBlock(4)		  err = SAUGraphGetNodeInfo( graph, synthNode, 0, 0, 0, synthUnit )		  		  // stop the note		  Dim midiPitch As Integer		  if notesStarted is nil or not notesStarted.HasKey( pitch ) then		    midiPitch = pitch		  else		    midiPitch = notesStarted.Value( pitch )		    notesStarted.Remove pitch		  end if		  err = MusicDeviceStopNote( synthUnit.Ptr(0) , channel, midiPitch, 0 )		  'System.DebugLog "Stopped note " + Str( midiPitch )		  		  return err		  		End Function	#tag EndMethod	#tag Method, Flags = &h1		Protected Function SNewAUGraph() As Integer		  //extern OSStatus NewAUGraph(AUGraph *outGraph);		  Declare Function NewAUGraph Lib kAudioToolboxLib _		  (graph as Ptr) as integer		  return NewAUGraph( graph )		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Sub TestHack(testVersion As Integer)		  // This is a hacked-out test to figure out why SMusicDeviceStopNote isn't working on 10.5.		  		  System.DebugLog "TestHack:"		  		  Declare Function MusicDeviceStartNote Lib kAudioUnitLib ( _		  synthUnit as Ptr, instrumentID as UInt32, groupID as UInt32, _		  ByRef outNoteInstanceID as Integer, inOffsetSampleFrame as UInt32, _		  inParams As Ptr) as Integer		  		  Declare Function MusicDeviceStopNote Lib kAudioUnitLib ( _		  synthUnit as Ptr, groupID as UInt32, _		  inNoteInstanceID as Integer, inOffsetSampleFrame as UInt32) as Integer		  		  		  Dim np As New CoreAudioNotePlayer		  np.SetInstrument 17		  Dim err as integer		  		  Dim channel As Integer = 0		  Dim instrumentID As Integer = 16		  Dim pitch As Single = 60		  Dim velocity As Single = 127		  		  Dim noteParams As New MemoryBlock( 28 )		  noteParams.UInt32Value( 0 ) = 2  // argCount		  noteParams.SingleValue( 4 ) = pitch   // mPitch (OK to have fractional values here!)		  noteParams.SingleValue( 8 ) = velocity		  		  // get the synth AudioUnit		  Dim synthUnit as New MemoryBlock(4)		  err = SAUGraphGetNodeInfo( np.graph, np.synthNode, 0, 0, 0, synthUnit )		  		  // start the note		  Dim midiPitch As Integer = pitch		  err = MusicDeviceStartNote( synthUnit.Ptr(0) , instrumentID, channel, midiPitch, 0, noteParams )		  System.DebugLog "Started note " + Str( midiPitch ) + " (from " + Str( pitch ) + ")" _		  + " (result code = " + Str( err ) + ")"		  		  // wait a bit...		  Dim now As Integer =Ticks		  do		  loop until Ticks > now + 60		  		  // stop the note		  err = MusicDeviceStopNote( synthUnit.Ptr(0) , channel, midiPitch, 0 )		  System.DebugLog "Stopped note " + Str( midiPitch ) _		  + " (result code = " + Str( err ) + ")"		  		  		  		End Sub	#tag EndMethod	#tag Note, Name = AUNotes		typedef UInt32  AudioUnitParameterUnit;				// if the "unit" field contains a value not in the enum above, then assume kAudioUnitParameterUnit_Generic		typedef struct AudioUnitParameterInfo		{		#if TARGET_API_MAC_OSX		 char      name[56];   // UTF8 encoded C string, may be treated as 56 characters		            // if kAudioUnitParameterFlag_HasCFNameString not set		 UInt32     clumpID;   // only valid if kAudioUnitParameterFlag_HasClump		 CFStringRef    cfNameString;  // only valid if kAudioUnitParameterFlag_HasCFNameString		#else		 char      name[64];   // UTF8 encoded C string		#endif		 AudioUnitParameterUnit unit;      		 Float32     minValue;   		 Float32     maxValue;   		 Float32     defaultValue;  		 UInt32     flags;    		} AudioUnitParameterInfo;										//delay params		// Parameters for the Delay Unit		enum {		  // Global, EqPow Crossfade, 0->100, 50		 kDelayParam_WetDryMix     = 0,		  		  // Global, Secs, 0->2, 1		 kDelayParam_DelayTime    = 1,		  		  // Global, Percent, -100->100, 50		 kDelayParam_Feedback     = 2,		  		  // Global, Hz, 10->(SampleRate/2), 15000		 kDelayParam_LopassCutoff    = 3		};					#tag EndNote	#tag Note, Name = componentcode						struct ComponentDescription {		   OSType componentType;		   OSType componentSubType;		   OSType componentManufacturer;		   unsigned long componentFlags;		   unsigned long componentFlagsMask;		};								  //theAIFFExportComponentInstance=OpenDefaultComponent(SAOSTypeToLong("spit"),SAOSTypeToLong("AIFF"))		  		  Dim i,osErr As Integer		  Dim s As String		  Dim theSpec,sdHandle,resourceBlock As MemoryBlock		  		  //Display "SAudioConverter Method: SAConvertMovieToFile"		  		  #If TargetMacOS then		    #If TargetCarbon then		      Declare Function NewHandleClear Lib "CarbonLib" (byteCount As Integer) As Integer		      Declare Function MovieExportSetSampleDescription Lib "Apple;Carbon;Multimedia" (ci As Integer, desc As Integer, mediaType As Integer) As Integer		      Declare Sub SetMovieProgressProc Lib "Apple;Carbon;Multimedia" (theMovie As Integer, p As Integer, refcon As Integer)		      Declare Function ConvertMovieToFile Lib "Apple;Carbon;Multimedia" (theMovie As Integer, onlyTrack As Integer, outputFile As Ptr, fileType As Integer, creator As Integer, scriptTag As Integer, resID As Ptr, flags As Integer, userComp As Integer) As Integer		      Declare Sub DisposeHandle Lib "CarbonLib" (h As Integer)		    #else		      Declare Function NewHandleClear Lib "InterfaceLib" (byteCount As Integer) As Integer		      Declare Function MovieExportSetSampleDescription Lib "QuickTimeLib" (ci As Integer, desc As Integer, mediaType As Integer) As Integer		      Declare Sub SetMovieProgressProc Lib "QuickTimeLib" (theMovie As Integer, p As Integer, refcon As Integer)		      Declare Function ConvertMovieToFile Lib "QuickTimeLib" (theMovie As Integer, onlyTrack As Integer, outputFile As Ptr, fileType As Integer, creator As Integer, scriptTag As Integer, resID As Ptr, flags As Integer, userComp As Integer) As Integer		      Declare Sub DisposeHandle Lib "InterfaceLib" (h As Integer)		    #endif		  #else		    Declare Function NewHandleClear Lib "qtmlClient.dll" (byteCount As Integer) As Integer		    Declare Function MovieExportSetSampleDescription Lib "qtmlClient.dll" (ci As Integer, desc As Integer, mediaType As Integer) As Integer		    Declare Sub SetMovieProgressProc Lib "qtmlClient.dll" (theMovie As Integer, p As Integer, refcon As Integer)		    Declare Function ConvertMovieToFile Lib "qtmlClient.dll" (theMovie As Integer, onlyTrack As Integer, outputFile As Ptr, fileType As Integer, creator As Integer, scriptTag As Integer, resID As Ptr, flags As Integer, userComp As Integer) As Integer		    Declare Sub DisposeHandle Lib "qtmlClient.dll" (h As Integer)		  #endif		  sdHandle=NewMemoryBlock(4)		  resourceBlock=NewMemoryBlock(4)		  theSpec=NewMemoryBlock(69)		  theSpec.short(0)=theWAVEFile.MacVRefNum		  theSpec.Long(2)=theWAVEFile.MacDirID		  theSpec.PString(6)=theWAVEFile.Name		  sdHandle.Long(0)=NewHandleClear(36)		  if sdHandle.Long(0)<>0 then		    sdHandle.ptr(0).ptr(0).long(0)=36 'long descSize;		    sdHandle.ptr(0).ptr(0).long(4)=SAOSTypeToLong("NONE")'twos")//("raw ") 'long dataFormat;		    sdHandle.ptr(0).ptr(0).long(8)=0 'long resvd1;		    sdHandle.ptr(0).ptr(0).short(12)=0 'short resvd2;		    sdHandle.ptr(0).ptr(0).short(14)=0 'short dataRefIndex;		    sdHandle.ptr(0).ptr(0).short(16)=1 'short version;		    sdHandle.ptr(0).ptr(0).short(18)=0 'short revlevel;		    sdHandle.ptr(0).ptr(0).long(20)=SAOSTypeToLong("SA") 'long vendor;		    sdHandle.ptr(0).ptr(0).short(24)=1 'short numChannels;		    sdHandle.ptr(0).ptr(0).short(26)=16 'short sampleSize;		    sdHandle.ptr(0).ptr(0).short(28)=0 'short compressionID;		    sdHandle.ptr(0).ptr(0).short(30)=0 'short packetSize;		    sdHandle.ptr(0).ptr(0).long(32)=44100*65536 'UnsignedFixed sampleRate;		    osErr=MovieExportSetSampleDescription(theAIFFExportComponentInstance,sdHandle.Long(0),SAOSTypeToLong("soun"))		    if osErr<>0 then				    else		      SetMovieProgressProc theMovie.Handle,-1,0		      'osErr=ConvertMovieToFile(theMovie.Handle,0,theSpec,SAOSTypeToLong("AIFF"),SAOSTypeToLong("TVOD"),0,resourceBlock,0,theAIFFExportComponentInstance)		      'osErr=ConvertMovieToFile(theMovie.Handle,0,theSpec,SAOSTypeToLong("AIFF"),SAOSTypeToLong("TVOD"),0,resourceBlock,0,0)		      osErr=ConvertMovieToFile(theMovie.Handle,0,theSpec,SAOSTypeToLong("sfil"),SAOSTypeToLong("TVOD"),0,resourceBlock,0,theAIFFExportComponentInstance)		      		      if osErr<>0 then				      else		        DisposeHandle sdHandle.Long(0)		      end if		    end if		  end if		  Return osErr		  			#tag EndNote	#tag Note, Name = constants				enum { 		kAudioUnitComponentType = FOUR_CHAR_CODE('aunt'), 		kAudioUnitSubType_Output = FOUR_CHAR_CODE('out '), 		kAudioUnitID_SoundManagerOutput = FOUR_CHAR_CODE('smgr'), 		kAudioUnitID_HALOutput = FOUR_CHAR_CODE('ahal'), 		kAudioUnitID_DefaultOutput = FOUR_CHAR_CODE('def '), 		kAudioUnitSubType_MusicDevice = FOUR_CHAR_CODE('musd'), 		kAudioUnitID_DLSSynth = FOUR_CHAR_CODE('dls '), 		kAudioUnitSubType_Encoder = FOUR_CHAR_CODE('aenc'), 		kAudioUnitSubType_Decoder = FOUR_CHAR_CODE('adec'), 		kAudioUnitSubType_BitDepthConverter = FOUR_CHAR_CODE('bdcv'), 		kAudioUnitSubType_SampleRateConverter = FOUR_CHAR_CODE('srcv'), 		kAudioUnitID_PolyphaseSRC = FOUR_CHAR_CODE('poly'), 		kAudioUnitSubType_FormatConverter = FOUR_CHAR_CODE('fmtc'), 		kAudioUnitID_Interleaver = FOUR_CHAR_CODE('inlv'), 		kAudioUnitID_Deinterleaver = FOUR_CHAR_CODE('dnlv'), 		kAudioUnitSubType_Effect = FOUR_CHAR_CODE('efct'), 		kAudioUnitID_MatrixReverb = FOUR_CHAR_CODE('mrev'), 		kAudioUnitID_Delay = FOUR_CHAR_CODE('dely'), 		kAudioUnitID_LowPassFilter = FOUR_CHAR_CODE('lpas'), 		kAudioUnitID_PeakLimiter = FOUR_CHAR_CODE('lmtr'), 		kAudioUnitSubType_Mixer = FOUR_CHAR_CODE('mixr'), 		kAudioUnitID_StereoMixer = FOUR_CHAR_CODE('smxr') 		}; 							#tag EndNote	#tag Note, Name = outline				Setting up an Audio Unit Graph				When using AUGraph, certain steps need to be followed in order for the		graph to function properly. These steps must be followed in this order:		•  Create the graph. Call NewAUGraph on an AUGraph instance.						•  Populate the graph. Use AUGraphNewNode and AUGraphNewNodeSubGraph to		populate the graph.						•  Make connections between nodes. AUGraphConnectNodeInput sets up		connections between the nodes. Nodes may have multiple inputs and		outputs, though sharing an input or output is not allowed. This is		otherwise known as “fan in” and “fan out,” and is not allowed in		AUGraph.						•  Open the graph. Up until this point, each node was being used in the		abstract AUNode representation. Upon calling AUGraphOpen, each node is		instantiated. This allows for properties to be set for each Audio Unit		inside of the graph.						•  Set output sample rates and channel layouts. A common error is for		sample rates and channel layouts to be mismatched between nodes. If any		format changes occur, it is imperative that sample rates and channel		number be set for all Audio Unit outputs prior to initialization						•  Initialize the graph. Once setup has occurred, AUGraphInitialize may		be called. This makes all the connections between the nodes, and		initializes all of the Audio Units that are part of a connection. At the		least, the output unit is initialized, even if no connections lead to		it.						•  Start the graph. Calling AUGraphStart begins rendering, starting		with the output unit and traversing through the graph.					#tag EndNote	#tag Note, Name = possiblyuseful				//audioToolbox.h		// this will return the name of a sound bank from a sound bank file		extern OSStatus GetNameFromSoundBank(const FSRef *inSoundBankRef, CFStringRef *outName);			#tag EndNote	#tag Note, Name = prototypes				'extern OSStatus NewAUGraph(AUGraph *outGraph);				  'extern OSStatus AUGraphNewNode(		  'AUGraph inGraph, 		  'const ComponentDescription *inDescription, 		  'UInt32 inClassDataSize, 		  'const void *inClassData, 		  'AUNode *outNode		  ');		  		  			#tag EndNote	#tag Note, Name = simplesynth		Defined Data Types				Typedefs are used to simplify the declaration of converters and the use of properties in the context of a graph.		 •  typedef SInt32 AUNode		 •  typedef struct OpaqueAUGraph *AUGraph 		 		 		@interface AudioSystem : NSObject {		    // Audio related		    AUGraph graph;		    AUNode synthNode;		    AUNode filterNode;		    AUNode outputNode;		    MusicDeviceInstrumentID channelInstrument[16];		    		    // MIDI related		    PYMIDIEndpoint* currentMIDIEndpoint;		}						- (void)setUpAudio;		{		    ComponentDescription description;		    AudioUnit    synthUnit;		    UInt32     usesReverb;		    int      i;		    		    // Create the graph		    NewAUGraph (&graph);		    		    // Open the DLS Synth		    description.componentType   = kAudioUnitComponentType;		    description.componentSubType  = kAudioUnitSubType_MusicDevice;		    description.componentManufacturer = kAudioUnitID_DLSSynth;		    description.componentFlags   = 0;		    description.componentFlagsMask  = 0;		    AUGraphNewNode (graph, &description, 0, NULL, &synthNode);		    		    for (i = 0; i < 16; i++) channelInstrument[i] = 0;				    // Open the filter		    description.componentType   = kAudioUnitComponentType;		    description.componentSubType  = kAudioUnitSubType_Effect;		    description.componentManufacturer = kAudioUnitID_LowPassFilter;		    description.componentFlags   = 0;		    description.componentFlagsMask  = 0;		    AUGraphNewNode (graph, &description, 0, NULL, &filterNode);				    // Open the output device		    description.componentType   = kAudioUnitComponentType;		    description.componentSubType  = kAudioUnitSubType_Output;		    description.componentManufacturer = kAudioUnitID_DefaultOutput;		    description.componentFlags   = 0;		    description.componentFlagsMask  = 0;		    AUGraphNewNode (graph, &description, 0, NULL, &outputNode);				    // Connect the devices up		    AUGraphConnectNodeInput (graph, synthNode, 1, filterNode, 0);		    AUGraphConnectNodeInput (graph, filterNode, 0, outputNode, 0);		    AUGraphUpdate (graph, NULL);		    		    // Open and initialize the audio units		    AUGraphOpen (graph);		    AUGraphInitialize (graph);				    // Turn off the reverb on the synth		    AUGraphGetNodeInfo (graph, synthNode, NULL, NULL, NULL, &synthUnit);		    usesReverb = 0;		    AudioUnitSetProperty (		        synthUnit,		        kMusicDeviceProperty_UsesInternalReverb, kAudioUnitScope_Global,		        0,		        &usesReverb, sizeof (usesReverb)		    );				    // Start playing		   AUGraphStart (graph);		}							#tag EndNote	#tag Property, Flags = &h21		Private curChannel As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private curInstrument As Integer	#tag EndProperty	#tag Property, Flags = &h21		Private description As memoryBlock	#tag EndProperty	#tag Property, Flags = &h21		Private filterNode As memoryBlock	#tag EndProperty	#tag Property, Flags = &h21		Private graph As memoryBlock	#tag EndProperty	#tag Property, Flags = &h21		Private notesPlaying() As Integer	#tag EndProperty	#tag Property, Flags = &h21		#tag Note			This dictionary keeps tracks of notes started with SMusicDeviceStartNote,			and not yet stopped with SMusicDeviceStopNote.						key: floating-point Pitch value			value: midi pitch (real or fake, as in generated by MusicDeviceStartNote) to specify to stop that note.		#tag EndNote		Private notesStarted As Dictionary	#tag EndProperty	#tag Property, Flags = &h21		Private outputNode As memoryBlock	#tag EndProperty	#tag Property, Flags = &h21		Private pitchesPlaying() As Double	#tag EndProperty	#tag Property, Flags = &h21		Private synthNode As MemoryBlock	#tag EndProperty	#tag Constant, Name = CarbonLib, Type = String, Dynamic = False, Default = \"", Scope = Public		#Tag Instance, Platform = Mac Mach-O, Language = Default, Definition  = \"/System/Library/Frameworks/Carbon.framework/Carbon"		#Tag Instance, Platform = Mac Carbon PEF, Language = Default, Definition  = \"CarbonLib"	#tag EndConstant	#tag Constant, Name = kAudioToolboxLib, Type = String, Dynamic = False, Default = \"/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitComponentType, Type = String, Dynamic = False, Default = \"aunt", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_DefaultOutput, Type = String, Dynamic = False, Default = \"def ", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_Delay, Type = String, Dynamic = False, Default = \"dely", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_DLSSynth, Type = String, Dynamic = False, Default = \"dls ", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_HALOutput, Type = String, Dynamic = False, Default = \"ahal", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_LowPassFilter, Type = String, Dynamic = False, Default = \"lpas", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_MatrixReverb, Type = String, Dynamic = False, Default = \"mrev", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitID_SoundManagerOutput, Type = String, Dynamic = False, Default = \"smgr", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitLib, Type = String, Dynamic = False, Default = \"/System/Library/Frameworks/AudioUnit.framework/AudioUnit", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitProperty_3DMixerRenderingFlags, Type = Double, Dynamic = False, Default = \"3003", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitProperty_ParameterInfo, Type = Double, Dynamic = False, Default = \"4", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitProperty_UsesInternalReverb, Type = Integer, Dynamic = False, Default = \"1005", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitScope_Global, Type = Integer, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitScope_Input, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitSubType_Effect, Type = String, Dynamic = False, Default = \"efct", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitSubType_MusicDevice, Type = String, Dynamic = False, Default = \"musd", Scope = Public	#tag EndConstant	#tag Constant, Name = kAudioUnitSubType_Output, Type = String, Dynamic = False, Default = \"out ", Scope = Public	#tag EndConstant	#tag Constant, Name = kDelayParam_DelayTime, Type = Integer, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = kDelayParam_Feedback, Type = Integer, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = kDelayParam_LopassCutoff, Type = Integer, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag Constant, Name = kDelayParam_WetDryMix, Type = Integer, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = kErr, Type = Boolean, Dynamic = False, Default = \"true", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_GroupOutputBus, Type = Integer, Dynamic = False, Default = \"1002", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_InstrumentCount, Type = Integer, Dynamic = False, Default = \"1000", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_InstrumentName, Type = Integer, Dynamic = False, Default = \"1001", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_InstrumentNumber, Type = Integer, Dynamic = False, Default = \"1004", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_SoundBankFSSpec, Type = Integer, Dynamic = False, Default = \"1003", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicDeviceProperty_UsesInternalReverb, Type = Integer, Dynamic = False, Default = \"1005", Scope = Public	#tag EndConstant	#tag Constant, Name = kMusicNoteEvent_UseGroupInstrument, Type = Double, Dynamic = False, Default = \"&hFFFFFFFF", Scope = Protected	#tag EndConstant	#tag Constant, Name = noErr, Type = Integer, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = QuickTimeLib, Type = String, Dynamic = False, Default = \"/System/Library/Frameworks/QuickTime.framework/QuickTime", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass