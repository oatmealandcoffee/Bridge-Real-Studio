#tag ClassProtected Class ChordObjInherits MusicObjImplements NoteListInterface	#tag Method, Flags = &h21		Private Sub AddExtensions()		  //called from CalculatePitches		  		  //Add on the extensions		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Sixth_Major, Settings) then StepValuesString.Append MusicLib.kChordExtension_Sixth_Major		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Sixth_Minor, Settings) then StepValuesString.Append MusicLib.kChordExtension_Sixth_Minor		  		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Seventh_Major, Settings) then StepValuesString.Append MusicLib.kChordExtension_Seventh_Major		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Seventh_Minor, Settings) then StepValuesString.Append MusicLib.kChordExtension_Seventh_Minor		  		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Ninth_Major, Settings) then StepValuesString.Append MusicLib.kChordExtension_Ninth_Major		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Ninth_Minor, Settings) then StepValuesString.Append MusicLib.kChordExtension_Ninth_Minor		  		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Eleventh_Major, Settings) then StepValuesString.Append MusicLib.kChordExtension_Eleventh_Major		  if DataLib.GetFlag(DataLib.kFlagChordExtension_Eleventh_Minor, Settings) then StepValuesString.Append MusicLib.kChordExtension_Eleventh_Minor		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub AddNote(StepValue as integer,  pitchModifier as integer)		  //now that we've sorted next pitch, get the rest of the values and make the note.		  dim NotePitchIndex as integer		  dim NotePitch, NoteLength, NoteStartBeat as integer		  dim Note as NoteObj		  		  NotePitchIndex = RootIndex + StepValue		  NotePitch = Track.TrackList.ParentWindow.SongMgr.Keys(0).Pitches(NotePitchIndex)		  NotePitch = NotePitch + pitchModifier		  NoteLength = me.Length		  NoteStartBeat = me.StartBeat		  #if kLogMethods		    'NoteStartBeat = NoteStartBeat + (MIDILib.kNoteLength_16 * i) //arpeggiate for testing.		  #endif		  Note = Track.TrackList.ParentWindow.NoteMgr.CreateNote(NoteStartBeat, NotePitch, NoteLength)		  Note.Track = me.Track		  		  //grab that last note made, and link everything together.		  Note.Chord = me		  me.Notes.Append Note		  me.Notes(Ubound(me.Notes)).Chord = me		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ApplyModifiers()		  //called from CalculatePitches		  		  //Do the modifiers		  //If the chord is suspended, change the 3 in the array into a 4		  if DataLib.GetFlag(DataLib.kFlagChordModifier_Suspended, Settings) then StepValuesString(1) = "4"		  		  //If the chord is a power chord, remove the 3 from the array		  if DataLib.GetFlag(DataLib.kFlagChordModifier_Power, Settings) then StepValuesString.Remove(1)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub ApplyRootSettingsToChord(Note as NoteObj)		  //this is called from EditMgr.MakeChord		  		  Root = Note		  //now that's set, we pull all of the information from the root to ensure we're grabbing the right info.		  Group = Root.Group		  		  Notes.Append Root		  Root.Chord = me		  Root.Selected = false		  		  Hidden = Root.Hidden		  Length = Root.Length		  Locked = Root.Locked		  OldLength = Root.OldLength		  OldStartBeat = Root.OldStartBeat		  Selected = Root.Selected		  StartBeat = Root.StartBeat		  Track = Root.Track		  Velocity = Root.Velocity		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Arpeggiate()		  //let's if we're arpeggiateing first of all		  if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_LowToHigh, Settings) OR DataLib.GetFlag(DataLib.kFlagChordArpeggiate_HighToLow, Settings) then		    		    //let's sort out by how much		    dim ArpeggioLengthMask as integer = 0		    		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_01, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_01		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_02, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_02		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_04, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_04		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_08, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_08		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_16, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_16		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_32, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_32		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_Length_64, settings) then ArpeggioLengthMask = ArpeggioLengthMask + DataLib.kFlagChordArpeggiate_Length_64		    		    dim ArpeggioLengthBeats as integer = 0		    		    Select Case ArpeggioLengthMask		    Case DataLib.kFlagChordArpeggiate_Length_01		      ArpeggioLengthBeats = MIDILib.kNoteLength_01		      		    Case DataLib.kFlagChordArpeggiate_Length_02		      ArpeggioLengthBeats = MIDILib.kNoteLength_02		      		    Case DataLib.kFlagChordArpeggiate_Length_02 + DataLib.kFlagChordArpeggiate_Length_04		      ArpeggioLengthBeats = MIDILib.kNoteLength_02 + MIDILib.kNoteLength_04		      		    Case DataLib.kFlagChordArpeggiate_Length_04		      ArpeggioLengthBeats = MIDILib.kNoteLength_04		      		    Case DataLib.kFlagChordArpeggiate_Length_04 + DataLib.kFlagChordArpeggiate_Length_08		      ArpeggioLengthBeats = MIDILib.kNoteLength_04 + MIDILib.kNoteLength_08		      		    Case DataLib.kFlagChordArpeggiate_Length_08		      ArpeggioLengthBeats = MIDILib.kNoteLength_08		      		    Case DataLib.kFlagChordArpeggiate_Length_08 + DataLib.kFlagChordArpeggiate_Length_16		      ArpeggioLengthBeats = MIDILib.kNoteLength_08 + MIDILib.kNoteLength_16		      		    Case DataLib.kFlagChordArpeggiate_Length_16		      ArpeggioLengthBeats = MIDILib.kNoteLength_16		      		    Case DataLib.kFlagChordArpeggiate_Length_16 + DataLib.kFlagChordArpeggiate_Length_32		      ArpeggioLengthBeats = MIDILib.kNoteLength_16 + MIDILib.kNoteLength_32		      		    Case DataLib.kFlagChordArpeggiate_Length_32		      ArpeggioLengthBeats = MIDILib.kNoteLength_32		      		    Case DataLib.kFlagChordArpeggiate_Length_32 + DataLib.kFlagChordArpeggiate_Length_64		      ArpeggioLengthBeats = MIDILib.kNoteLength_32 + MIDILib.kNoteLength_64		      		    Case DataLib.kFlagChordArpeggiate_Length_64		      ArpeggioLengthBeats = MIDILib.kNoteLength_64		      		    else		      //ArpeggioLengthBeats = 0		    End Select		    		    //now let's sort which direction and arpeggiate		    dim thisNote as Integer		    dim firstNote as integer = 0		    dim lastNote as integer = UBound(me.Notes)		    		    if DataLib.GetFlag(DataLib.kFlagChordArpeggiate_LowToHigh, Settings) then		      		      		      for thisNote = firstNote to lastNote		        if me.Notes(thisNote) <> nil then		          dim note as NoteObj = me.Notes(thisNote)		          note.StartBeat = note.StartBeat + (ArpeggioLengthBeats * thisNote)		        end if		      next		      		    elseif DataLib.GetFlag(DataLib.kFlagChordArpeggiate_HighToLow, Settings) then		      		      for thisNote = lastNote DownTo firstNote		        if me.Notes(thisNote) <> nil then		          dim note as NoteObj = me.Notes(thisNote)		          note.StartBeat = note.StartBeat + (ArpeggioLengthBeats * InvertIterator(thisNote, lastNote))		        end if		      next		      		    end if		    		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Function CalculatePitches() As Boolean		  //called from EditMgr.MakeChord		  		  if me.Settings = 0 then return false		  		  if Root = nil then		    MsgBox "ChordObj.CalculatePitches: A root note must be selected and applied to the chord before it can calculate the pitches."		    return false		  end if		  		  RootIndex = Track.TrackList.ParentWindow.SongMgr.Keys(0).IsPitchWithinKey(Root.Pitch) //NilObjectException on SongMgrObj		  		  if RootIndex = -1 then		    MsgBox "ChordObj.CalculatePitches: The selected note must be in key to create a chord."		    return false		  end if		  		  RemoveArpeggio		  ClearNotes		  GetChordInformation		  AddExtensions		  ApplyModifiers		  		  dim i as integer		  for i = 1 to Ubound(StepValuesString)		    		    dim StepValue as Integer = GetStepValue(StepValuesString(i))		    dim pitchModifier as integer = GetPitchModifer(StepValuesString(i))		    		    AddNote(StepValue, pitchModifier)		  next		  		  //Arpeggios are keen! Let's make one!		  Arpeggiate		  		  SetNoteList		  		  return true		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ClearNotes()		  dim i, n, x, y, z as integer		  		  if Ubound(Notes) <> -1 then		    for i = Ubound(Notes) DownTo 1 //only down to 1 because note 0 is the root note.		      if Notes(i) <> nil and Notes(i) <> Root then		        Notes(i).Chord = nil //destroyNote also destroys the chord, so we break the link		        Track.TrackList.ParentWindow.NoteMgr.DestroyNote(Notes(i))		        Notes.Remove(i)		      end if		    next		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Constructor()		  // Calling the overridden superclass constructor.		  Super.Constructor		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub DeselectObj()		  #if kLogMethods		    Log("ChordObj.DeselectObj")		  #endif		  		  if me.Selected = false then return		  me.Selected = false		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer  = Ubound(me.Notes)		  for thisNote = firstNote to lastNote		    if Notes(thisNote) <> nil then		      Notes(thisNote).DeselectObj		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub GetChordInformation()		  //called from CalculatePitches		  		  //get the chord information		  if DataLib.GetFlag(DataLib.kFlagChordType_Major, Settings) then Type = MusicLib.kChordType_Major		  if DataLib.GetFlag(DataLib.kFlagChordType_Minor, Settings) then Type = MusicLib.kChordType_Minor		  if DataLib.GetFlag(DataLib.kFlagChordType_Diminished, Settings) then Type = MusicLib.kChordType_Diminished		  if DataLib.GetFlag(DataLib.kFlagChordType_Augmented, Settings) then Type = MusicLib.kChordType_Augmented		  		  dim ChordInfo(-1) as string		  ChordInfo = Split(Type, "=")		  		  //parse key name		  Name = MusicLib.GetNoteName(Root.Pitch) + " " + ChordInfo(0)		  		  //Make step values string array out of second part		  StepValuesString = Split(ChordInfo(1), " ")		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetPitchModifer(TheStepValue as string) As Integer		  dim stepChr as string = GetStepCharacter(TheStepValue)		  		  dim pitchModifier as integer = 0		  		  if stepChr = "b" then		    pitchModifier = -1		  elseif stepChr = "#" then		    pitchModifier = 1		  end if		  		  return pitchModifier		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetStepCharacter(TheStep as String) As String		  dim stepChr as string = Left(TheStep, 1)		  		  return stepChr		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetStepValue(TheStepValue as string) As Integer		  //calculate the pitches for the chord.		  //Major=1 3 5		  //Minor=1 b3 5		  //All possibilities		  //1 [b]3 [#]5 [6|[b]7] [b]9 [b]11		  		  //here we parse the step value		  dim StepValue as integer		  dim stepChr as string		  		  stepChr = GetStepCharacter(TheStepValue)		  		  if InStr(0, "1234567890", stepChr) > 0 then //it's a number		    		    StepValue = Val(TheStepValue) - 1		    		  else //it's a modifier		    		    StepValue = Val(Right(TheStepValue, Len(TheStepValue) - 1)) - 1		    		  end if		  		  return StepValue		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Function GetStepValuesString() As String		  '//FOR TROUBLESHOOTING PURPOSES ONLY		  '		  'dim returnString as string = ""		  '		  '//GET THE STEP STRING		  'dim thisString as integer		  'dim firstString as integer = 0		  'dim lastString as integer = Ubound(StepValuesString)		  '		  'for thisString = firstString to lastString		  'returnString = returnString + " " + StepValuesString(thisString)		  'next		  '		  '//GET THE NOTE VALUES		  'returnString = returnString + " : "		  '		  'dim thisNote as integer		  'dim firstNote as integer = 0		  'dim lastNote as integer = Ubound(me.Notes)		  '		  'for thisNote = firstNote to lastNote		  'dim note as noteObj = me.Notes(thisNote)		  '		  'if note <> nil then		  'returnString = returnString + " " + Str(Note.Pitch)		  'end if		  'next		  '		  'return returnString		  		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub GroupObj()		  // Part of the GroupInterfaceObj interface.		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Function InvertIterator(theAmount as integer, theUbound as integer) As Integer		  dim theInvertedAmount as integer		  theInvertedAmount = Abs(theAmount - theUbound)		  return theInvertedAmount		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Sub Log(theText as string)		  WindowLog.Log(theText)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub RemoveArpeggio()		  dim i, n, x, y, z as integer		  		  dim thisNote as integer		  dim ChordStartBeat as integer = me.Root.StartBeat		  		  if Ubound(Notes) <> -1 then		    for thisNote = Ubound(Notes) DownTo 0		      if Notes(thisNote) <> nil then		        		        dim note as NoteObj = Notes(thisNote)		        		        ChordStartBeat = min(ChordStartBeat, Note.StartBeat)		        		      end if		    next		  end if		  		  me.Root.StartBeat = ChordStartBeat		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub RemoveNote(Note as NoteObj)		  dim firstObject as integer = 0		  dim thisObject as integer = 0		  dim lastObject as integer = Ubound(Notes)		  		  for thisObject = lastObject DownTo firstObject		    if Notes(thisObject) <> nil then		      if Notes(thisObject) IsA NoteObj then		        if Notes(thisObject) = Note then		          Notes.Remove(thisObject)		        end if		      end if		    end if		  next		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub ResetNoteList()		  // Part of the NoteListInterface interface.		  		  redim NoteList(-1)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SelectObj()		  if me.Selected = true then return		  me.Selected = true		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer  = Ubound(me.Notes)		  		  for thisNote = firstNote to lastNote		    if Notes(thisNote) <> nil then		      Notes(thisNote).SelectObj		    end if		  next		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub SetNoteList()		  // Part of the NoteListInterface interface.		  // called when the chord has been created and the notes added to the list.		  		  ResetNoteList		  		  dim thisNote as integer = 0		  dim firstNote as integer = 0		  dim lastNote as integer = Ubound(Notes)		  		  for thisNote = firstNote to lastNote		    if Notes(thisNote) <> nil then		      dim theNote as NoteObj = Notes(thisNote)		      		      dim thisNestedNote as integer = 0		      dim firstNestedNote as integer = 0		      dim lastNestedNote as integer = UBound(theNote.NoteList)		      		      for thisNestedNote = firstNestedNote to lastNestedNote		        if theNote.NoteList(thisNestedNote) <> nil then		          dim theNestedNote as NoteObj = theNote.NoteList(thisNestedNote)		          NoteList.Append theNestedNote		        end if		      next		      		    end if		  next		  		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub UnGroupObj()		  // Part of the GroupInterfaceObj interface.		  		  		End Sub	#tag EndMethod	#tag Note, Name = How Chords Are Made		Chords are complicated, so we need to be sure we can do this in a manageable order.				Essentially, they way it will work is we're going to build a string that will tell us what perfects and modified perfects to add the music.				In each step below, the chord name is built as well...				[ ] Get the basic chord type. This builds the initial string.		[ ] Check the extensions; in all positive cases, add the name of the extension to the chord's name (which should still be a buffer).		   [ ] If the extension is an Eleventh, select the Ninth and Seventh		   [ ] if the extension is a Ninth, select the Seventh		   [ ] if the extension is a Seventh, do nothing.		   [ ] otherwise, leave the controls alone		[ ] Check the modfiers		   [ ] If the chord is suspended, change the 3 in the string into a 4		   [ ] If the chord is a power chord, remove the 3 (or 4) from the string		   [ ] Handle inversions (TK)				Once the string is built, loop through the values and make the chord.					#tag EndNote	#tag Property, Flags = &h0		Notes(-1) As NoteObj	#tag EndProperty	#tag Property, Flags = &h0		Root As NoteObj	#tag EndProperty	#tag Property, Flags = &h0		RootIndex As Integer = -1	#tag EndProperty	#tag Property, Flags = &h0		Settings As Integer	#tag EndProperty	#tag Property, Flags = &h0		StepValuesString(-1) As String	#tag EndProperty	#tag Property, Flags = &h0		Type As String	#tag EndProperty	#tag ViewBehavior		#tag ViewProperty			Name="Description"			Group="Behavior"			Type="String"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="Hidden"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="ID"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Label"			Group="Behavior"			Type="String"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Length"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="PlayObj"		#tag EndViewProperty		#tag ViewProperty			Name="Locked"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="OldLength"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="PlayObj"		#tag EndViewProperty		#tag ViewProperty			Name="OldPitch"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="OldStartBeat"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="PlayObj"		#tag EndViewProperty		#tag ViewProperty			Name="Pitch"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="MusicObj"		#tag EndViewProperty		#tag ViewProperty			Name="RootIndex"			Group="Behavior"			InitialValue="-1"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Selected"			Group="Behavior"			InitialValue="0"			Type="Boolean"			InheritedFrom="PlayObj"		#tag EndViewProperty		#tag ViewProperty			Name="Settings"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="StartBeat"			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="PlayObj"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Type"			Group="Behavior"			InitialValue="0"			Type="String"			EditorType="MultiLineEditor"		#tag EndViewProperty		#tag ViewProperty			Name="Velocity"			Group="Behavior"			InitialValue="60"			Type="Integer"			InheritedFrom="PlayObj"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass